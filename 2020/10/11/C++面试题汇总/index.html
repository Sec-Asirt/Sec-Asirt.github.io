<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C语言————总结 | Mr.Hu</title><meta name="description" content="C 语言第一部分：基本概念及其它问答题1、关键字 static 的作用是什么？这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。3). 在模块内，一个"><meta name="keywords" content="C++"><meta name="author" content="胡先森"><meta name="copyright" content="胡先森"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://yoursite.com/2020/10/11/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><meta property="og:type" content="article"><meta property="og:title" content="C语言————总结"><meta property="og:url" content="http://yoursite.com/2020/10/11/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"><meta property="og:site_name" content="Mr.Hu"><meta property="og:description" content="C 语言第一部分：基本概念及其它问答题1、关键字 static 的作用是什么？这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其它函数访问。它是一个本地的全局变量。3). 在模块内，一个"><meta property="og:image" content="http://yoursite.com/img/10.png"><meta property="article:published_time" content="2020-10-11T05:17:36.000Z"><meta property="article:modified_time" content="2020-12-08T12:34:05.018Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"❤富强❤,❤民主❤,❤和谐❤,❤友善❤,❤敬业❤,❤文明❤,❤自由❤,❤平等❤,❤公正❤,❤法治❤,❤爱国❤,❤诚信❤","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-12-08 20:34:05'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 5.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">24</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/projects/clock/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-bookmark"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-archive"></i><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 放松</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 学习</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/projects/photo/"><i class="fa-fw fas fa-images"></i><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 游戏</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/projects/game1/"><i class="fa-fw fas fa-heart"></i><span> 保卫星球</span></a></li><li><a class="site-page" href="/projects/game2/"><i class="fa-fw fas fa-heart"></i><span> 飞字快打</span></a></li><li><a class="site-page" href="/projects/game3/"><i class="fa-fw fas fa-heart"></i><span> 俄罗斯方块</span></a></li><li><a class="site-page" href="/projects/game4/"><i class="fa-fw fas fa-heart"></i><span> 特效画笔</span></a></li><li><a class="site-page" href="/projects/game5/"><i class="fa-fw fas fa-heart"></i><span> 音速小子</span></a></li><li><a class="site-page" href="/projects/game6/"><i class="fa-fw fas fa-heart"></i><span> 植物大战僵尸</span></a></li><li><a class="site-page" href="/projects/zifuyu/"><i class="fa-fw fas fa-heart"></i><span> 字符雨</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="/projects/link/"><i class="fa-fw fas fa-link"></i><span> 网站导航</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 留言板</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">C 语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%AE%83%E9%97%AE%E7%AD%94%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">第一部分：基本概念及其它问答题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97-static-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、关键字 static 的作用是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E2%80%9C%E5%BC%95%E7%94%A8%E2%80%9D%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、“引用”与指针的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81-h-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84-ifndef-define-endif-%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、.h 头文件中的 ifndef&#x2F;define&#x2F;endif 的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81-include-%E4%B8%8E-include-%E2%80%9Cfile-h%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">4、#include 与 #include “file.h”的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E6%8F%8F%E8%BF%B0%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.5.</span> <span class="toc-text">5、描述实时系统的基本特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%9C%89%EF%BC%8C%E6%98%AF%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.6.</span> <span class="toc-text">6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9F"><span class="toc-number">1.1.7.</span> <span class="toc-text">7、什么是平衡二叉树？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%A0%86%E6%A0%88%E6%BA%A2%E5%87%BA%E4%B8%80%E8%88%AC%E6%98%AF%E7%94%B1%E4%BB%80%E4%B9%88%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.8.</span> <span class="toc-text">8、堆栈溢出一般是由什么原因导致的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B1%82%E6%AC%A1%E5%A4%AA%E6%B7%B1%E7%9A%84%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8"><span class="toc-number">1.1.9.</span> <span class="toc-text">2.层次太深的递归调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.10.</span> <span class="toc-text">9、冒泡排序算法的时间复杂度是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.1.11.</span> <span class="toc-text">10、什么函数不能声明为虚函数？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.12.</span> <span class="toc-text">11、队列和栈有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81%E4%B8%8D%E8%83%BD%E5%81%9A-switch-%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.13.</span> <span class="toc-text">12、不能做 switch()的参数类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%83%BD%E5%90%A6%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%87%8D%E5%90%8D%EF%BC%9F"><span class="toc-number">1.1.14.</span> <span class="toc-text">13、局部变量能否和全局变量重名？</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/img/10.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Mr.Hu</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/projects/clock/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-bookmark"></i><span> 时光轴</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fas fa-archive"></i><span> 工具</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 放松</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 学习</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/projects/photo/"><i class="fa-fw fas fa-images"></i><span> 照片墙</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-film"></i><span> 游戏</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/projects/game1/"><i class="fa-fw fas fa-heart"></i><span> 保卫星球</span></a></li><li><a class="site-page" href="/projects/game2/"><i class="fa-fw fas fa-heart"></i><span> 飞字快打</span></a></li><li><a class="site-page" href="/projects/game3/"><i class="fa-fw fas fa-heart"></i><span> 俄罗斯方块</span></a></li><li><a class="site-page" href="/projects/game4/"><i class="fa-fw fas fa-heart"></i><span> 特效画笔</span></a></li><li><a class="site-page" href="/projects/game5/"><i class="fa-fw fas fa-heart"></i><span> 音速小子</span></a></li><li><a class="site-page" href="/projects/game6/"><i class="fa-fw fas fa-heart"></i><span> 植物大战僵尸</span></a></li><li><a class="site-page" href="/projects/zifuyu/"><i class="fa-fw fas fa-heart"></i><span> 字符雨</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-link"></i><span> 链接</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="/projects/link/"><i class="fa-fw fas fa-link"></i><span> 网站导航</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user-circle"></i><span> 留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">C语言————总结</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-11T05:17:36.000Z" title="发表于 2020-10-11 13:17:36">2020-10-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-08T12:34:05.018Z" title="更新于 2020-12-08 20:34:05">2020-12-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">20.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><h3 id="第一部分：基本概念及其它问答题"><a href="#第一部分：基本概念及其它问答题" class="headerlink" title="第一部分：基本概念及其它问答题"></a>第一部分：基本概念及其它问答题</h3><h4 id="1、关键字-static-的作用是什么？"><a href="#1、关键字-static-的作用是什么？" class="headerlink" title="1、关键字 static 的作用是什么？"></a>1、关键字 static 的作用是什么？</h4><p>这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：<br>1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但<br>不能被模块外其它函数访问。它是一个本地的全局变量。<br>3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个<br>函数被限制在声明它的模块的本地范围内使用。<br>大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三<br>部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重<br>要性。</p>
<h4 id="2、“引用”与指针的区别是什么？"><a href="#2、“引用”与指针的区别是什么？" class="headerlink" title="2、“引用”与指针的区别是什么？"></a>2、“引用”与指针的区别是什么？</h4><p>答 、1) 引用必须被初始化，指针不必。<br>2) 引用初始化以后不能被改变，指针可以改变所指的对象。<br>3) 不存在指向空值的引用，但是存在指向空值的指针。<br>指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程<br>序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。<br>流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其<br>它情况都推荐使用引用。</p>
<h4 id="3、-h-头文件中的-ifndef-define-endif-的作用？"><a href="#3、-h-头文件中的-ifndef-define-endif-的作用？" class="headerlink" title="3、.h 头文件中的 ifndef/define/endif 的作用？"></a>3、.h 头文件中的 ifndef/define/endif 的作用？</h4><p>答：防止该头文件被重复引用。</p>
<h4 id="4、-include-与-include-“file-h”的区别？"><a href="#4、-include-与-include-“file-h”的区别？" class="headerlink" title="4、#include 与 #include “file.h”的区别？"></a>4、#include 与 #include “file.h”的区别？</h4><p>答：前者是从 Standard Library 的路径寻找和引用 file.h，而后者是从当前工作路径搜寻并引<br>用 file.h。</p>
<h4 id="5、描述实时系统的基本特性"><a href="#5、描述实时系统的基本特性" class="headerlink" title="5、描述实时系统的基本特性"></a>5、描述实时系统的基本特性</h4><p>答 ：在特定时间内完成特定的任务，实时性与可靠性。</p>
<h4 id="6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"><a href="#6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？" class="headerlink" title="6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"></a>6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</h4><p>答 ：全局变量储存在静态数据区，局部变量在堆栈中。</p>
<h4 id="7、什么是平衡二叉树？"><a href="#7、什么是平衡二叉树？" class="headerlink" title="7、什么是平衡二叉树？"></a>7、什么是平衡二叉树？</h4><p>答 ：左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。</p>
<h4 id="8、堆栈溢出一般是由什么原因导致的？"><a href="#8、堆栈溢出一般是由什么原因导致的？" class="headerlink" title="8、堆栈溢出一般是由什么原因导致的？"></a>8、堆栈溢出一般是由什么原因导致的？</h4><p>答 ：1.没有回收垃圾资源</p>
<h4 id="2-层次太深的递归调用"><a href="#2-层次太深的递归调用" class="headerlink" title="2.层次太深的递归调用"></a>2.层次太深的递归调用</h4><h4 id="9、冒泡排序算法的时间复杂度是什么？"><a href="#9、冒泡排序算法的时间复杂度是什么？" class="headerlink" title="9、冒泡排序算法的时间复杂度是什么？"></a>9、冒泡排序算法的时间复杂度是什么？</h4><p>答 ：O(n^2)</p>
<h4 id="10、什么函数不能声明为虚函数？"><a href="#10、什么函数不能声明为虚函数？" class="headerlink" title="10、什么函数不能声明为虚函数？"></a>10、什么函数不能声明为虚函数？</h4><p>答：constructor</p>
<h4 id="11、队列和栈有什么区别？"><a href="#11、队列和栈有什么区别？" class="headerlink" title="11、队列和栈有什么区别？"></a>11、队列和栈有什么区别？</h4><p>答：队列先进先出，栈后进先出</p>
<h4 id="12、不能做-switch-的参数类型"><a href="#12、不能做-switch-的参数类型" class="headerlink" title="12、不能做 switch()的参数类型"></a>12、不能做 switch()的参数类型</h4><p>答 ：switch 的参数不能为实型。</p>
<h4 id="13、局部变量能否和全局变量重名？"><a href="#13、局部变量能否和全局变量重名？" class="headerlink" title="13、局部变量能否和全局变量重名？"></a>13、局部变量能否和全局变量重名？</h4><p>答：能，局部会屏蔽全局。要用全局变量，需要使用”::”<br>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会<br>用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如<br>在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内<br>14、如何引用一个已经定义过的全局变量？<br>答 、可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用某<br>个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你<br>用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报<br>错。<br>15、全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？<br>答 、可以，在不同的 C 文件中以 static 形式来声明同名全局变量。<br>可以在不同的 C 文件中声明同名的全局变量，前提是其中只能有一个 C 文件中对此变量赋<br>初值，此时连接不会出错。<br>16、语句 for( ；1 ；)有什么问题？它是什么意思？<br>答 、和 while(1)相同，无限循环。<br>17、do……while 和 while……do 有什么区别？<br>答 、前一个循环一遍再判断，后一个判断以后再循环。<br>18、statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数<br>static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？<br>static 函数与普通函数有什么区别？<br>答 、全局变量(外部变量)的说明之前再冠以 static 就构成了静态的全局变量。全局变量本身<br>就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。<br>这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件<br>组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用<br>域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于<br>静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避<br>免在其它源文件中引起错误。<br>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的<br>生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。<br>static 函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为<br>内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用<br>的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件<br>static 全局变量与普通的全局变量有什么区别：static 全局变量只初使化一次，防止在其他文<br>件单元中被引用;<br>static 局部变量和普通局部变量有什么区别：static 局部变量只被初始化一次，下一次依据上<br>一次结果值；<br>static 函数与普通函数有什么区别：static 函数在内存中只有一份，普通函数在每个被调用中<br>维持一份拷贝<br>19、程序的内存分配<br>答：一个由 c/C++编译的程序占用的内存分为以下几个部分<br>1、栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作<br>方式类似于数据结构中的栈。<br>2、堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。<br>注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。<br>3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局<br>变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区<br>域。程序结束后由系统释放。<br>4、文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区—存放函数体的二进制代码<br>例子程序<br>这是一个前辈写的，非常详细<br>//main.cpp<br>int a=0; //全局初始化区<br>char <em>p1; //全局未初始化区<br>main()<br>{<br>intb;栈<br>char s[]=”abc”; //栈<br>char *p2; //栈<br>char *p3=”123456″; //123456\0在常量区，p3在栈上。<br>static int c=0； //全局（静态）初始化区<br>p1 = (char</em>)malloc(10);<br>p2 = (char*)malloc(20); //分配得来得10和20字节的区域就在堆区。<br>strcpy(p1,”123456″); //123456\0放在常量区，编译器可能会将它与 p3所向”123456″优化成一<br>个地方。<br>}<br>20、解释堆和栈的区别<br>答：堆（heap）和栈(stack)的区别<br>（1）申请方式<br>stack:由系统自动分配。例如，声明在函数中一个局部变量 int b;系统自动在栈中为 b 开辟空<br>间<br>heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数<br>如 p1=(char*)malloc(10);<br>在 C++中用 new 运算符<br>如 p2=(char*)malloc(10);<br>但是注意 p1、p2本身是在栈中的。<br>（2）申请后系统的响应<br>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，<br>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中<br>删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地<br>址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，<br>由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放<br>入空闲链表中。<br>（3）申请大小的限制<br>栈：在 Windows 下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意<br>思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是2M（也<br>有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将<br>提示 overflow。因此，能从栈获得的空间较小。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的<br>空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限<br>于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br>（4）申请效率的比较：<br>栈:由系统自动分配，速度较快。但程序员是无法控制的。<br>堆:是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br>另外，在 WINDOWS 下，最好的方式是用 Virtual Alloc 分配内存，他不是在堆，也不是在<br>栈,而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最<br>灵活。<br>（5）堆和栈中的存储内容<br>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执<br>行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈<br>的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，<br>也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。<br>（6）存取效率的比较<br>char s1[]=”aaaaaaaaaaaaaaa”;<br>char <em>s2=”bbbbbbbbbbbbbbbbb”;<br>aaaaaaaaaaa 是在运行时刻赋值的；<br>而 bbbbbbbbbbb 是在编译时就确定的；<br>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。<br>比如：<br>#include<br>voidmain()<br>{<br>char a=1;<br>char c[]=”1234567890″;<br>char *p=”1234567890″;<br>a = c[1];<br>a = p[1];<br>return;<br>}<br>对应的汇编代码<br>10:a=c[1];<br>004010678A4DF1movcl,byteptr[ebp-0Fh]<br>0040106A884DFCmovbyteptr[ebp-4],cl<br>11:a=p[1];<br>0040106D8B55ECmovedx,dwordptr[ebp-14h]<br>004010708A4201moval,byteptr[edx+1]<br>004010738845FCmovbyteptr[ebp-4],al<br>第一种在读取时直接就把字符串中的元素读到寄存器 cl 中，而第二种则要先把指针值读到<br>edx 中，在根据 edx 读取字符，显然慢了。<br>21、什么是预编译,何时需要预编译?<br>答：预编译又称为预处理,是做些代码文本的替换工作。处理#开头的指令,比如拷贝#include<br>包含的文件代码，#define 宏定义的替换,条件编译等，就是为编译做的预备工作的阶段，主<br>要处理#开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，<br>可以放在程序中的任何位置。<br>c 编译系统在对程序进行通常的编译之前，先进行预处理。c 提供的预处理功能主要有以下<br>三种：1）宏定义 2）文件包含 3）条件编译<br>1、 总是使用不经常改动的大型代码体。<br>２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种<br>情况下，可以将所有包含文件预编译为一个预编译头。<br>22、关键字 const 是什么含意？<br>答：我只要一听到被面试者说：“const 意味着常数”，我就知道我正在和一个业余者打交道。<br>去年 Dan Saks 已经在他的文章里完全概括了 const 的所有用法，因此 ESP(译者：Embedded<br>Systems Programming)的每一位读者应该非常熟悉 const 能做什么和不能做什么.如果你从没<br>有读到那篇文章，只要能说出 const 意味着“只读”就可以了。尽管这个答案不是完全的答案，<br>但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下 Saks 的文章<br>吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意<br>思？<br>const int a;<br>int const a;<br>const int *a;<br>int * const a;<br>int const * a const;<br>前两个的作用是一样，a 是一个常整型数。第三个意味着 a 是一个指向常整型数的指针（也<br>就是，整型数是不可修改的，但指针可以）。第四个意思 a 是一个指向整型数的常指针（也<br>就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着 a 是一<br>个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可<br>修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，<br>也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为<br>什么还要如此看重关键字 const 呢？我也如下的几下理由：<br>1). 关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数<br>为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃<br>圾，你就会很快学会感谢这点多余的信息。（当然，懂得用 const 的程序员很少会留下的垃<br>圾让别人来清理的。）<br>2). 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的代码。<br>3). 合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其<br>被无意的代码修改。简而言之，这样可以减少 bug 的出现<br>23、关键字 volatile 有什么含意 并给出三个不同的例子。<br>答：一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会<br>去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读<br>取这个变量的值，而不是使用保存在寄存器里的备份。下面是 volatile 变量的几个例子：<br>1). 并行设备的硬件寄存器（如：状态寄存器）<br>2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)<br>3). 多线程应用中被几个任务共享的变量<br>回答不出这个问题的人是不会被雇佣的。我认为这是区分 C 程序员和嵌入式系统程序员的<br>最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS 等等打交道，所用这些都要求<br>volatile 变量。不懂得 volatile 内容将会带来灾难。<br>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一<br>下这家伙是不是直正懂得 volatile 完全的重要性。<br>1). 一个参数既可以是 const 还可以是 volatile 吗？解释为什么。<br>2). 一个指针可以是 volatile 吗？解释为什么。<br>3). 下面的函数有什么错误：<br>int square(volatile int *ptr)<br>{<br>return *ptr * *ptr;<br>}<br>下面是答案：<br>1). 是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它<br>是 const 因为程序不应该试图去修改它。<br>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 buffer 的<br>指针时。<br>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针</em>ptr 指向值的平方，但是，由于<br><em>ptr 指向一个 volatile 型参数，编译器将产生类似下面的代码：<br>int square(volatile int *ptr)<br>{<br>int a,b;<br>a = *ptr;<br>b = *ptr;<br>return a * b;<br>}<br>由于</em>ptr 的值可能被意想不到地该变，因此 a 和 b 可能是不同的。结果，这段代码可能返不<br>是你所期望的平方值！正确的代码如下：<br>long square(volatile int <em>ptr)<br>{<br>int a;<br>a = *ptr;<br>return a * a;<br>}<br>24、三种基本的数据模型<br>答：按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。<br>25、结构与联合有和区别？<br>答：(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存<br>放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成<br>员的存放地址不同）。<br>(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结<br>构的不同成员赋值是互不影响的<br>26、描述内存分配方式以及它们的区别?<br>答：1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整<br>个运行期间都存在。例如全局变量，static 变量。<br>2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行<br>结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。<br>3） 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的<br>内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，<br>使用非常灵活，但问题也最多<br>27、请说出 const 与#define 相比，有何优点？<br>答：Const 作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被 Const 修饰的东<br>西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。<br>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。<br>而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。<br>2） 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。<br>28、简述数组与指针的区别？<br>答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向<br>任意类型的内存块。<br>(1)修改内容上的差别<br>char a[] = “hello”;<br>a[0] = ‘X’;<br>char *p = “world”; // 注意 p 指向常量字符串<br>p[0] = ‘X’; // 编译器不能发现该错误，运行时错误<br>(2) 用运算符 sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个 指<br>针变量的字节数，而不是 p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容<br>量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为<br>同类型的指针。<br>char a[] = “hello world”;<br>char *p = a;<br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节<br>cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节<br>计算数组和指针的内存容量<br>void Func(char a[100])<br>{<br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节<br>}<br>29、分别写出 BOOL,int,float,指针类型的变量 a 与“零”的比较语句。<br>答：BOOL : if ( !a ) or if(a)<br>int : if ( a == 0)<br>float : const EXPRESSION EXP = 0.000001<br>if ( a &lt; EXP &amp;&amp; a &gt;-EXP)<br>pointer : if ( a != NULL) or if(a == NULL)<br>30、如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？<br>答：#ifdef __cplusplus<br>cout&lt;&lt;”c++”;<br>#else<br>cout&lt;&lt;”c”;<br>#endif<br>31、论述含参数的宏与函数的优缺点<br>答： 带参宏 函数<br>处理时间 编译时 程序运行时<br>参数类型 没有参数类型问题 定义实参、形参类型<br>处理过程 不分配内存 分配内存<br>程序长度 变长 不变<br>运行速度 不占运行时间 调用和返回占用时间<br>32、用两个栈实现一个队列的功能？要求给出算法和思路！<br>答 、设2个栈为 A,B, 一开始均为空.<br>入队:<br>将新元素 push 入栈 A;<br>出队:<br>(1)判断栈 B 是否为空；<br>(2)如果不为空，则将栈 A 中所有元素依次 pop 出并 push 到栈 B；<br>(3)将栈 B 的栈顶元素 pop 出；<br>这样实现的队列入队和出队的平摊复杂度都还是 O(1), 比上面的几种方法要好<br>33、嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？<br>答：这个问题用几个解决方案。我首选的方案是：<br>while(1)<br>{<br>}<br>一些程序员更喜欢如下方案：<br>for(;;)<br>{<br>}<br>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这<br>个作为方案，我将用这个作为一个机会去探究他们这样做的<br>基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我<br>留下一个坏印象。<br>第三个方案是用 goto<br>Loop:<br>…<br>goto Loop;<br>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是<br>一个想进入新领域的 BASIC/FORTRAN 程序员。<br>34、位操作（Bit manipulation）<br>答： 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量 a，写两段代<br>码，第一个设置 a 的 bit 3，第二个清除 a 的 bit 3。在以上两个操作中，要保持其它位不变。<br>对这个问题有三种基本的反应<br>1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。<br>2) 用 bit fields。Bit fields 是被扔到 C 语言死角的东西，它保证你的代码在不同编译器之间<br>是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon 为其较<br>复杂的通信芯片写的驱动程序，它用到了 bit fields 因此完全对我无用，因为我的编译器用其<br>它的方式来实现 bit fields 的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。<br>3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。<br>最佳的解决方案如下：<br>#define BIT3 (0x1 &lt;&lt; 3)<br>static int a;<br>void set_bit3(void)<br>{<br>a |= BIT3;<br>}<br>void clear_bit3(void)<br>{<br>a &amp;= <del>BIT3;<br>}<br>一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我<br>希望看到几个要点：说明常数、|=和&amp;=</del>操作。<br>35、访问固定的内存位置（Accessing fixed memory locations）<br>答：嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设<br>置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的 ANSI 编译器。写代<br>码去完成这一任务。<br>这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针<br>是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：<br>int *ptr;<br>ptr = (int *)0x67a9;<br>*ptr = 0xaa66;<br>A more obscure approach is:<br>一个较晦涩的方法是：<br>*(int * const)(0x67a9) = 0xaa55;<br>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。<br>36、中断（Interrupts）<br>答： 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标<br>准 C 支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了<br>__interrupt 关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。<br>__interrupt double compute_area (double radius)<br>{<br>double area = PI * radius * radius;<br>printf(“\nArea = %f”, area);<br>return area;<br>}<br>这个函数有太多的错误了，以至让人不知从何说起了：<br>1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。<br>2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。<br>3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的<br>寄存器入栈，有些处理器/编译器就是不允许在 ISR 中做浮点运算。此外，ISR 应该是短而<br>有效率的，在 ISR 中做浮点运算是不明智的。<br>4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，<br>我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。<br>37、动态内存分配（Dynamic memory allocation）<br>答：尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的<br>过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？<br>这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已<br>经在 ESP 杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到<br>的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿<br>出这么一个小节目：<br>下面的代码片段的输出是什么，为什么？<br>char *ptr;<br>if ((ptr = (char *)malloc(0)) == NULL)<br>puts(“Got a null pointer”);<br>else<br>puts(“Got a valid pointer”);<br>这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数 malloc，得到了一个合<br>法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。<br>我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确<br>的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。<br>38、Typedef<br>答：Typedef 在 C 语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理<br>器做类似的事。例如，思考一下下面的例子：<br>#define dPS struct s *<br>typedef struct s * tPS;<br>以上两种情况的意图都是要定义 dPS 和 tPS 作为一个指向结构 s 指针。哪种方法更好呢？<br>（如果有的话）为什么？<br>这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：<br>typedef 更好。思考下面的例子：<br>dPS p1,p2;<br>tPS p3,p4;<br>第一个扩展为<br>struct s * p1, p2;<br>上面的代码定义 p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第<br>二个例子正确地定义了 p3 和 p4 两个指针。<br>39、用变量 a 给出下面的定义<br>答：a) 一个整型数（An integer）<br>b) 一个指向整型数的指针（A pointer to an integer）<br>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an<br>integer）<br>d) 一个有10个整型数的数组（An array of 10 integers）<br>e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）<br>f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function<br>that takes an integer as an argument and returns an integer）<br>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型<br>数（ An array of ten pointers to functions that take an integer<br>argument and return an integer ）<br>答案是：<br>a) int a; // An integer<br>b) int *a; // A pointer to an integer<br>c) int **a; // A pointer to a pointer to an integer<br>d) int a[10]; // An array of 10 integers<br>e) int *a[10]; // An array of 10 pointers to integers<br>f) int (*a)[10]; // A pointer to an array of 10 integers<br>g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer<br>h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return<br>an integer<br>40、解释局部变量、全局变量和静态变量的含义。<br>答：<br>41、写一个“标准”宏<br>答：交换两个参数值的宏定义为：. #define SWAP(a,b)<br>(a)=(a)+(b);<br>(b)=(a)-(b);<br>(a)=(a)-(b);<br>输入两个参数，输出较小的一个：#define MIN(A,B) ((A) &lt; (B))? (A) : (B))<br>表明1年中有多少秒（忽略闰年问题）：#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL<br>#define DOUBLE(x) x+x 与 #define DOUBLE(x) （（x）+（x））<br>i = 5*DOUBLE(5)； i 为30 i = 5*DOUBLE(5)； i 为50<br>已知一个数组 table，用一个宏定义，求出数据的元素个数<br>#define NTBL<br>#define NTBL (sizeof(table)/sizeof(table[0]))<br>42、A.c 和 B.c 两个 c 文件中使用了两个相同名字的 static 变量,编译的时候会不会有问题?<br>这两个 static 变量会保存到哪里（栈还是堆或者其他的）?<br>答：static 的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。<br>他们都放在数据区，但是编译器对他们的命名是不同的。<br>如果要使变量在其他模块也有意义的话，需要使用 extern 关键字。<br>43、一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指<br>向的节点？<br>答：将这个指针指向的 next 节点值 copy 到本节点，将 next 指向 next-&gt;next,并随后删除原 next<br>指向的节点。<br>第二部分：程序代码评价或者找错<br>1、下面的代码输出是什么，为什么？<br>void foo(void)<br>{<br>unsigned int a = 6;<br>int b = -20;<br>(a+b &gt; 6) ? puts(“&gt; 6″) : puts(“&lt;= 6”);<br>}<br>这个问题测试你是否懂得 C 语言中的整数自动转换原则，我发现有些开发者懂得极少这些<br>东西。不管如何，这无符号整型问题的答案是输出是 “&gt;6″。原因是当表达式中存在有符号<br>类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的<br>正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌<br>入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。<br>2、评价下面的代码片断：<br>unsigned int zero = 0;<br>unsigned int compzero = 0xFFFF;<br>/*1′s complement of zero */<br>对于一个 int 型不是16位的处理器为说，上面的代码是不正确的。应编写如下：<br>unsigned int compzero = ~0;<br>这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程<br>序员非常准确地明白硬件的细节和它的局限，然而 PC 机程序往往把硬件作为一个无法避免<br>的烦恼。<br>3、 C 语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？<br>int a = 5, b = 7, c;<br>c = a+++b;<br>这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法<br>的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原<br>则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：<br>c = a++ + b;<br>因此, 这段代码持行后 a = 6, b = 7, c = 12。<br>如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。<br>我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性<br>的好的话题。<br>4、设有以下说明和定义：<br>typedef union {long i; int k[5]; char c;} DATE;<br>struct data { int cat; DATE cow; double dog;} too;<br>DATE max;<br>则语句 printf(“%d”,sizeof(struct date)+sizeof(max));的执行结果是？<br>答 、结果是：52。DATE 是一个 union, 变量公用空间. 里面最大的变量类型是 int[5], 占用<br>20个字节. 所以它的大小是20<br>data 是一个 struct, 每个变量分开占用空间. 依次为 int4 + DATE20 + double8 = 32.<br>所以结果是 20 + 32 = 52.<br>当然…在某些16位编辑器下, int 可能是2字节,那么结果是 int2 + DATE10 + double8 = 20<br>5、请写出下列代码的输出内容<br>#include<br>main()<br>{<br>int a,b,c,d;<br>a=10;<br>b=a++;<br>c=++a;<br>d=10</em>a++;<br>printf(“b，c，d：%d，%d，%d”，b，c，d）;<br>return 0;<br>}<br>答：10，12，120<br>6、写出下列代码的输出内容<br>#include<br>int inc(int a)<br>{<br>return(++a);<br>}<br>int multi(int<em>a,int</em>b,int<em>c)<br>{<br>return(<em>c=<em>a</em></em>b);<br>}<br>typedef int(FUNC1)(int in);<br>typedef int(FUNC2) (int</em>,int*,int*);<br>void show(FUNC2 fun,int arg1, int<em>arg2)<br>{<br>INCp=&inc;<br>int temp =p(arg1);<br>fun(&amp;temp,&amp;arg1, arg2);<br>printf(“%d\n”,<em>arg2);<br>}<br>main()<br>{<br>int a;<br>show(multi,10,&amp;a);<br>return 0;<br>}<br>答：110<br>7、请找出下面代码中的所以错误<br>说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”<br>1、#include”string.h”<br>2、main()<br>3、{<br>4、 char</em>src=”hello,world”;<br>5、 char</em> dest=NULL;<br>6、 int len=strlen(src);<br>7、 dest=(char*)malloc(len);<br>8、 char* d=dest;<br>9、 char* s=src[len];<br>10、 while(len–!=0)<br>11、 d++=s–;<br>12、 printf(“%s”,dest);<br>13、 return 0;<br>14、}<br>答：<br>方法1：<br>int main(){<br>char* src = “hello,world”;<br>int len = strlen(src);<br>char* dest = (char*)malloc(len+1);//要为\0分配一个空间<br>char* d = dest;<br>char* s = &amp;src[len-1];//指向最后一个字符<br>while( len– != 0 )<br><em>d++=<em>s–;<br>*d = 0;//尾部要加\0<br>printf(“%s\n”,dest);<br>free(dest);// 使用完，应当释放空间，以免造成内存汇泄露<br>return 0;<br>}<br>方法2：<br>#include<br>#include<br>main()<br>{<br>char str[]=”hello,world”;<br>int len=strlen(str);<br>char t;<br>for(int i=0; i<br>{<br>t=str[i];<br>str[i]=str[len-i-1]; str[len-i-1]=t;<br>}<br>printf(“%s”,str);<br>return 0;<br>}<br>8、请问下面程序有什么错误?<br>int a[60][250][1000],i,j,k;<br>for(k=0;k&lt;=1000;k++)<br>for(j=0;j&lt;250;j++)<br>for(i=0;i&lt;60;i++)<br>a[i][j][k]=0;<br>答案：把循环语句内外换一下<br>9、请问下面程序会出现什么情况?<br>. #define Max_CB 500<br>void LmiQueryCSmd(Struct MSgCB * pmsg)<br>{<br>unsigned char ucCmdNum;<br>……<br>for(ucCmdNum=0;ucCmdNum<br>{<br>……;<br>}<br>答案：死循环<br>10、以下3个有什么区别<br>char * const p; //常量指针，p 的值不可以修改<br>char const * p；//指向常量的指针，指向的常量值不可以改<br>const char *p； //和 char const *p<br>11、写出下面的结果<br>char str1[] = “abc”;<br>char str2[] = “abc”;<br>const char str3[] = “abc”;<br>const char str4[] = “abc”;<br>const char *str5 = “abc”;<br>const char *str6 = “abc”;<br>char *str7 = “abc”;<br>char *str8 = “abc”;<br>cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;<br>结果是：0 0 1 1<br>解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；<br>而 str5,str6,str7,str8是指针，它们指向相同的常量区域。<br>12、以下代码中的两个 sizeof 用法有问题吗？<br>void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母<br>{<br>for( size_t i=0; i<br>if( ‘a’&lt;=str[i] &amp;&amp; str[i]&lt;=’z’ )<br>str[i] -= (‘a’-‘A’ );<br>}<br>char str[] = “aBcDe”;<br>cout &lt;&lt; “str 字符长度为: “ &lt;&lt; sizeof(str)/sizeof(str[0]) &lt;&lt; endl;<br>UpperCase( str );<br>cout &lt;&lt; str &lt;&lt; endl;<br>答：函数内的 sizeof 有问题。根据语法，sizeof 如用于数组，只能测出静态数组的大小，无<br>法检测动态分配的或外部数组大小。函数外的 str 是一个静态定义的数组，因此其大小为6，<br>函数内的 str 实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此<br>sizeof 作用于上只将其当指针看，一个指针为4个字节，因此返回4。<br>13、写出输出结果<br>main()<br>{<br>int a[5]={1,2,3,4,5};<br>int *ptr=(int *)(&amp;a+1);<br>printf(“%d,%d”,*(a+1),*(ptr-1));<br>}<br>输出：2,5<br>*(a+1）就是 a[1]，*(ptr-1)就是 a[4],执行结果是2，5<br>&amp;a+1不是首地址+1，系统会认为加一个 a 数组的偏移，是偏移了一个数组的大小（本例是5<br>个 int）<br>int *ptr=(int *)(&amp;a+1);<br>则 ptr 实际是&amp;(a[5]),也就是 a+5<br>原因如下：<br>&amp;a 是数组指针，其类型为 int (*)[5];<br>而指针加1要根据指针类型加上一定的值，<br>不同类型的指针+1之后增加的大小不同<br>a 是长度为5的 int 数组指针，所以要加 5*sizeof(int)<br>所以 ptr 实际是 a[5]<br>但是 prt 与(&amp;a+1)类型是不一样的(这点很重要)<br>所以 prt-1只会减去 sizeof(int*)<br>a,&amp;a 的地址是一样的，但意思不一样，a 是数组首地址，也就是 a[0]的地址，&amp;a 是对象（数<br>组）首地址，a+1是数组下一元素的地址，即 a[1],&amp;a+1是下一个对象的地址，即 a[5].<br>14、请问以下代码有什么问题：<br>int main()<br>{<br>char a;<br>char *str=&a;<br>strcpy(str,”hello”);<br>printf(str);<br>return 0;<br>}<br>没有为 str 分配内存空间，将会发生异常<br>问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为<br>越界进行内在读写而导致程序崩溃。<br>char* s=”AAA”;<br>printf(“%s”,s);<br>s[0]=’B’;<br>printf(“%s”,s);<br>有什么错？<br>“AAA”是字符串常量。s 是指针，指向这个字符串常量，所以声明 s 的时候就有问题。<br>cosnt char* s=”AAA”;<br>然后又因为是常量，所以对是 s[0]的赋值操作是不合法的。<br>15、有以下表达式：<br>int a=248; b=4;int const c=21;const int *d=&a;<br>int *const e=&b;int const *f const =&a;<br>请问下列表达式哪些会被编译器禁止？为什么？<br>*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f;<br>*c 这是个什么东东，禁止<br>*d 说了是 const， 禁止<br>e = &amp;a 说了是 const 禁止<br>const *f const =&a; 禁止<br>16、交换两个变量的值，不使用第三个变量。<br>即 a=3,b=5,交换之后 a=5,b=3;<br>有两种解法, 一种用算术算法, 一种用^(异或)<br>a = a + b;<br>b = a - b;<br>a = a - b;<br>or<br>a = a^b;// 只能对 int,char..<br>b = a^b;<br>a = a^b;<br>or<br>a ^= b ^= a;<br>17、下面的程序会出现什么结果<br>.#include<br>#include<br>void getmemory(char *p)<br>{<br>p=(char *) malloc(100);<br>strcpy(p,”hello world”);<br>}<br>int main( )<br>{<br>char *str=NULL;<br>getmemory(str);<br>printf(“%s/n”,str);<br>free(str);<br>return 0;<br>}<br>程序崩溃，getmemory 中的 malloc 不能返回动态内存， free（）对 str 操作很危险<br>18、下面的语句会出现什么结果？<br>char szstr[10];<br>strcpy(szstr,”0123456789″);<br>答案：长度不一样，会造成非法的 OS，应该改为 char szstr[11]；<br>19、(void *)ptr 和 (*(void**))ptr 的结果是否相同？<br>答：其中 ptr 为同一个指针<br>.(void *)ptr 和 (*(void**))ptr 值是相同的<br>20、问函数既然不会被其它函数调用，为什么要返回1？<br>int main()<br>{<br>int x=3;<br>printf(“%d”,x);<br>return 1;<br>}<br>答：mian 中，c 标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息<br>21、对绝对地址0×100000赋值且想让程序跳转到绝对地址是0×100000去执行<br>(unsigned int*)0×100000 = 1234;<br>首先要将0×100000强制转换成函数指针,即:<br>(void (*)())0×100000<br>然后再调用它:<br>*((void (*)())0×100000)();<br>用 typedef 可以看得更直观些:<br>typedef void(*)() voidFuncPtr;<br>*((voidFuncPtr)0×100000)();<br>22、输出多少？并分析过程<br>unsigned short A = 10;<br>printf(“~A = %u\n”, ~A);<br>char c=128;<br>printf(“c=%d\n”,c);<br>第一题，～A ＝0xfffffff5,int 值 为－11，但输出的是 uint。所以输出4294967285<br>第二题，c＝0×10,输出的是 int，最高位为1，是负数，所以它的值就是0×00的补码就是128，<br>所以输出－128。<br>这两道题都是在考察二进制向 int 或 uint 转换时的最高位处理。<br>23、分析下面的程序：<br>void GetMemory(char **p,int num)<br>{<br>*p=(char *)malloc(num);<br>}<br>int main()<br>{<br>char *str=NULL;<br>GetMemory(&amp;str,100);<br>strcpy(str,”hello”);<br>free(str);<br>if(str!=NULL)<br>{<br>strcpy(str,”world”);<br>}<br>printf(“\n str is %s”,str);<br>getchar();<br>}<br>问输出结果是什么？希望大家能说说原因，先谢谢了<br>输出 str is world。<br>free 只是释放的 str 指向的内存空间,它本身的值还是存在的.<br>所以 free 之后，有一个好的习惯就是将 str=NULL.<br>此时 str 指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储<br>空间是可能被重新分配给其他变量的,<br>尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出<br>world 来。<br>这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。<br>当你 malloc 一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），<br>然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的<br>地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继<br>续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。<br>24、char a[10],strlen(a)为什么等于15？运行的结果<br>#include “stdio.h”<br>#include “string.h”<br>void main()<br>{<br>char aa[10];<br>printf(“%d”,strlen(aa));<br>}<br>sizeof()和初不初始化，没有关系；<br>strlen()和初始化有关。<br>char (*str)[20];/*str 是一个数组指针，即指向数组的指针．*/<br>char *str[20];/*str 是一个指针数组，其元素为指针型数据．*/<br>25、long a=0×801010;a+5=?<br>答：0×801010用二进制表示为：“1000 0000 0001 0000 0001 0000”，十进制的值为8392720，<br>再加上5就是8392725<br>26、给定结构 struct A<br>{<br>char t:：4;<br>char k:4;<br>unsigned short i:8;<br>unsigned long m;<br>};问 sizeof(A) = ?<br>给定结构 struct A<br>{<br>char t:4; 4位<br>char k:4; 4位<br>unsigned short i:8; 8位<br>unsigned long m; // 偏移2字节保证4字节对齐<br>}; // 共8字节<br>27、下面的函数实现在一个数上加一个数，有什么错误？请改正。<br>int add_n ( int n )<br>{<br>static int i = 100;<br>i += n;<br>return i;<br>}<br>当你第二次调用时得不到正确的结果，难道你写个函数就是为了调用一次？问题就出在<br>static 上<br>28、给出下面程序的答案<br>#include<br>#include<br>#include<br>#include<br>#include<br>#include<br>typedef struct AA<br>{<br>int b1:5;<br>int b2:2;<br>}AA;<br>void main()<br>{<br>AA aa;<br>char cc[100];<br>strcpy(cc,”0123456789abcdefghijklmnopqrstuvwxyz”);<br>memcpy(&amp;aa,cc,sizeof(AA));<br>cout &lt;&lt; aa.b1 &lt;<br>cout &lt;&lt; aa.b2 &lt;<br>}<br>答案是 -16和１<br>首先 sizeof(AA)的大小为4,b1和 b2分别占5bit 和2bit.<br>经过 strcpy 和 memcpy 后,aa 的4个字节所存放的值是:<br>0,1,2,3的 ASC 码，即00110000,00110001,00110010,00110011<br>所以，最后一步：显示的是这４个字节的前５位，和之后的２位<br>分别为：10000,和01<br>因为 int 是有正负之分 所以：答案是-16和１<br>29、求函数返回值，输入 x=9999;<br>int func （ x ）<br>{<br>int countx = 0;<br>while ( x )<br>{<br>countx ++;<br>x = x&amp;(x-1);<br>}<br>return countx;<br>}<br>结果呢？<br>知道了这是统计9999的二进制数值中有多少个1的函数，且有<br>9999＝9×1024＋512＋256＋15<br>9×1024中含有1的个数为2；<br>512中含有1的个数为1；<br>256中含有1的个数为1；<br>15中含有1的个数为4；<br>故共有1的个数为8，结果为8。<br>1000 - 1 = 0111，正好是原数取反。这就是原理。<br>用这种方法来求1的个数是很效率很高的。<br>不必去一个一个地移位。循环次数最少。<br>30、分析：<br>struct bit<br>{ int a:3;<br>int b:2;<br>int c:3;<br>};<br>int main()<br>{<br>bit s;<br>char *c=(char*)&s;<br>cout&lt;&lt;&lt;endl;<br>*c=0x99;<br>cout &lt;&lt; s.a &lt;&lt;&lt;s.b&lt;&lt;endl&lt;&lt;s.c&lt;&lt;endl;<br>int a=-1;<br>printf(“%x”,a);<br>return 0;<br>}<br>输出为什么是<br>4<br>1<br>-1<br>-4<br>ffffffff<br>因为0x99在内存中表示为 100 11 001 , a = 001, b = 11, c = 100<br>当 c 为有符合数时, c = 100, 最高1为表示 c 为负数，负数在计算机用补码表示，所以 c = -4;<br>同理<br>b = -1;<br>当 c 为有符合数时, c = 100,即 c = 4,同理 b = 3<br>31、下面这个程序执行后会有什么错误或者效果:<br>#define MAX 255<br>int main()<br>{<br>unsigned char A[MAX],i;//i 被定义为 unsigned char<br>for (i=0;i&lt;=MAX;i++)<br>A[i]=i;<br>}<br>解答：死循环加数组越界访问（C/C++不进行数组越界检查）<br>MAX=255<br>数组 A 的下标范围为:0..MAX-1,这是其一..<br>其二.当 i 循环到255时,循环内执行:<br>A[255]=255;<br>这句本身没有问题..但是返回 for (i=0;i&lt;=MAX;i++)语句时,<br>由于 unsigned char 的取值范围在(0..255),i++以后 i 又为0了..无限循环下去.<br>32、写出 sizeof(struct name1)=,sizeof(struct name2)=的结果<br>struct name1{<br>char str;<br>short x;<br>int num;<br>}<br>struct name2{<br>char str;<br>int num;<br>short x;<br>}<br>sizeof(struct name1)=8,sizeof(struct name2)=12<br>在第二个结构中，为保证 num 按四个字节对齐，char 后必须留出3字节的空间；同时为保证<br>整个结构的自然对齐（这里是4字节对齐），在 x 后还要补齐2个字节，这样就是12字节。<br>33、struct s1<br>{<br>int i: 8;<br>int j: 4;<br>int a: 3;<br>double b;<br>};<br>struct s2<br>{<br>int i: 8;<br>int j: 4;<br>double b;<br>int a:3;<br>};<br>printf(“sizeof(s1)= %d\n”, sizeof(s1));<br>printf(“sizeof(s2)= %d\n”, sizeof(s2));<br>result: 16, 24<br>第一个 struct s1<br>{<br>int i: 8;<br>int j: 4;<br>int a: 3;<br>double b;<br>};<br>理论上是这样的，首先是 i 在相对0的位置，占8位一个字节，然后，j 就在相对一个字节的<br>位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放在那里了，然后是 a，要<br>在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算<br>过来是2字节2位的样子，由于 double 是8字节的，因此要在相对0要是8个字节的位置上放下，<br>因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16<br>字节。<br>第二个最后会对照是不是结构体内最大数据的倍数，不是的话，会补成是最大数据的倍数<br>34、在对齐为4的情况下<br>struct BBB<br>{<br>long num；<br>char *name;<br>short int data;<br>char ha;<br>short ba[5];<br>}*p;<br>p=0x1000000;<br>p+0x200=____;<br>(Ulong)p+0x200=____;<br>(char*)p+0x200=____;<br>希望各位达人给出答案和原因，谢谢拉<br>解答：假设在32位 CPU 上，<br>sizeof(long) = 4 bytes<br>sizeof(char *) = 4 bytes<br>sizeof(short int) = sizeof(short) = 2 bytes<br>sizeof(char) = 1 bytes<br>由于是4字节对齐，<br>sizeof(struct BBB) = sizeof(*p)<br>= 4 + 4 + 2 + 1 + 1/*补齐*/ + 2*5 + 2/*补齐*/ = 24 bytes (经 Dev-C++验证)<br>p=0x1000000;<br>p+0x200=____;<br>= 0x1000000 + 0x200*24<br>(Ulong)p+0x200=____;<br>= 0x1000000 + 0x200<br>(char*)p+0x200=____;<br>= 0x1000000 + 0x200*4<br>35、找错<br>Void test1()<br>{<br>char string[10];<br>char* str1=”0123456789”;<br>strcpy(string, str1);// 溢出，应该包括一个存放’\0’的字符 string[11]<br>}<br>Void test2()<br>{<br>char string[10], str1[10];<br>for(I=0; I&lt;10;I++)<br>{<br>str1[i] =’a’;<br>}<br>strcpy(string, str1);// I，i 没有声明。<br>}<br>Void test3(char* str1)<br>{<br>char string[10];<br>if(strlen(str1)&lt;=10)// 改成&lt;10,字符溢出，将 strlen 改为 sizeof 也可以<br>{<br>strcpy(string, str1);<br>}<br>}<br>36、写出输出结果<br>void g(int**);<br>int main()<br>{<br>int line[10],i;<br>int *p=line; //p 是地址的地址<br>for (i=0;i&lt;10;i++)<br>{<br>*p=i;<br>g(&amp;p);//数组对应的值加1<br>}<br>for(i=0;i&lt;10;i++)<br>printf(“%d\n”,line[i]);<br>return 0;<br>}<br>void g(int**p)<br>{<br>(**p)++;<br>(*p)++;// 无效<br>}<br>输出：<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>37、写出程序运行结果<br>int sum(int a)<br>{<br>auto int c=0;<br>static int b=3;<br>c+=1;<br>b+=2;<br>return(a+b+c);<br>}<br>void main()<br>{<br>int I;<br>int a=2;<br>for(I=0;I&lt;5;I++)<br>{<br>printf(“%d,”, sum(a));<br>}<br>}<br>// static 会保存上次结果，记住这一点，剩下的自己写<br>输出：8,10,12,14,16,<br>38、评价代码<br>int func(int a)<br>{<br>int b;<br>switch(a)<br>{<br>case 1: 30;<br>case 2: 20;<br>case 3: 16;<br>default: 0<br>}<br>return b;<br>}<br>则 func(1)=?<br>// b 定义后就没有赋值<br>int a[3];<br>a[0]=0; a[1]=1; a[2]=2;<br>int *p, *q;<br>p=a;<br>q=&amp;a[2];<br>则 a[q-p]=a[2]<br>解释：指针一次移动一个 int 但计数为1<br>39、请问一下程序将输出什么结果？<br>char *RetMenory(void)<br>{<br>char p[] = “hellow world”;<br>return p;<br>}<br>void Test(void)<br>{<br>char *str = NULL;<br>str = RetMemory();<br>printf(str);<br>}<br>RetMenory 执行完毕，p 资源被回收，指向未知地址。返回地址，str 的内容应是不可预测的,<br>打印的应该是 str 的地址<br>40、写出输出结果<br>typedef struct<br>{<br>int a:2;<br>int b:2;<br>int c:1;<br>}test;<br>test t;<br>t.a = 1;<br>t.b = 3;<br>t.c = 1;<br>printf(“%d”,t.a);<br>printf(“%d”,t.b);<br>printf(“%d”,t.c);<br>t.a 为01,输出就是1<br>t.b 为11，输出就是－1<br>t.c 为1，输出也是-1<br>3个都是有符号数 int 嘛。<br>这是位扩展问题<br>01<br>11<br>1<br>编译器进行符号扩展<br>41、对下面程序进行分析<br>void test2()<br>{<br>char string[10], str1[10];<br>int i;<br>for(i=0; i&lt;10; i++)<br>{<br>str1[i] = ‘a’;<br>}<br>strcpy( string, str1 );<br>}<br>解答：如果面试者指出字符数组 str1不能在数组内结束可以给3分；如果面试者指出<br>strcpy(string, str1)调用使得从str1内存起复制到string内存起所复制的字节数具有不确定性可<br>以给7分，在此基础上指出库函数 strcpy 工作方式的给10分；<br>str1不能在数组内结束:因为 str1的存储为：{a,a,a,a,a,a,a,a,a,a},没有’\0’(字符串结束符)，所以<br>不能结束<br>strcpy( char *s1,char *s2)他的工作原理是，扫描 s2指向的内存，逐个字符付到 s1所指向的内<br>存，直到碰到’\0’,因为 str1结尾没有’\0’，所以具有不确定性，不知道他后面还会付什么东东。<br>正确应如下<br>void test2()<br>{<br>char string[10], str1[10];<br>int i;<br>for(i=0; i&lt;9; i++)<br>{<br>str1[i] = ‘a’+i; //把 abcdefghi 赋值给字符数组<br>}<br>str[i]=’\0’;//加上结束符<br>strcpy( string, str1 );<br>}<br>42、分析：<br>int arr[] = {6,7,8,9,10};<br>int *ptr = arr;<br>*(ptr++)+=123;<br>printf(“ %d %d ”, *ptr, *(++ptr));<br>输出：8 8<br>过程：对于*(ptr++)+=123;先做加法6+123，然后++，指针指向7；对于 printf(“ %d %d ”, *ptr,<br>*(++ptr));从后往前执行，指针先++，指向8，然后输出8，紧接着再输出8<br>43、分析下面的代码：<br>char *a = “hello”;<br>char *b = “hello”;<br>if(a= =b)<br>printf(“YES”);<br>else<br>printf(“NO”);<br>这个简单的面试题目,我选输出 no(对比的应该是指针地址吧),可在 VC 是 YES 在 C 是 NO<br>lz 的呢，是一个常量字符串。位于静态存储区，它在程序生命期内恒定不变。如果编译器优<br>化的话，会有可能 a 和 b 同时指向同一个 hello 的。则地址相同。如果编译器没有优化，那<br>么就是两个不同的地址，则不同<br>44、写出输出结果<br>#include<br>void foo(int m, int n)<br>{<br>printf(“m=%d, n=%d\n”, m, n);<br>}<br>int main()<br>{<br>int b = 3;<br>foo(b+=3, ++b);<br>printf(“b=%d\n”, b);<br>return 0;<br>}<br>输出：m=7,n=4,b=7(VC6.0)<br>这种方式和编译器中得函数调用关系相关即先后入栈顺序。不过不同<br>编译器得处理不同。也是因为 C 标准中对这种方式说明为未定义，所以<br>各个编译器厂商都有自己得理解，所以最后产生得结果完全不同。<br>因为这样，所以遇见这种函数，我们首先要考虑我们得编译器会如何处理<br>这样得函数，其次看函数得调用方式，不同得调用方式，可能产生不同得<br>结果。最后是看编译器优化。<br>45、找出错误<br>#include string.h<br>main(void)<br>{ char *src=”hello,world”;<br>char *dest=NULL;<br>dest=(char *)malloc(strlen(src));<br>int len=strlen(str);<br>char *d=dest;<br>char *s=src[len];<br>while(len–!=0)<br>d++=s–;<br>printf(“%s”,dest);<br>}<br>找出错误！！<br>#include “string.h”<br>#include “stdio.h”<br>#include “malloc.h”<br>main(void)<br>{<br>char *src=”hello,world”;<br>char *dest=NULL;<br>dest=(char *)malloc(sizeof(char)*(strlen(src)+1));<br>int len=strlen(src);<br>char *d=dest;<br>char *s=src+len-1;<br>while(len–!=0)<br>*d++=*s–;<br>*d=’\0′;<br>printf(“%s”,dest);<br>}<br>第三部分：编程题<br>1、读文件 file1.txt 的内容（例如）：<br>12<br>34<br>56<br>输出到 file2.txt：<br>56<br>34<br>12<br>#include<br>#include<br>int main(void)<br>{<br>int MAX = 10;<br>int *a = (int *)malloc(MAX * sizeof(int));<br>int *b;<br>FILE *fp1;<br>FILE *fp2;<br>fp1 = fopen(“a.txt”,”r”);<br>if(fp1 == NULL)<br>{printf(“error1″);<br>exit(-1);<br>}<br>fp2 = fopen(“b.txt”,”w”);<br>if(fp2 == NULL)<br>{printf(“error2″);<br>exit(-1);<br>}<br>int i = 0;<br>int j = 0;<br>while(fscanf(fp1,”%d”,&amp;a[i]) != EOF)<br>{<br>i++;<br>j++;<br>if(i &gt;= MAX)<br>{<br>MAX = 2 * MAX;<br>b = (int</em>)realloc(a,MAX * sizeof(int));<br>if(b == NULL)<br>{<br>printf(“error3″);<br>exit(-1);<br>}<br>a = b;<br>}<br>}<br>for(;–j &gt;= 0;)<br>fprintf(fp2,”%d\n”,a[j]);<br>fclose(fp1);<br>fclose(fp2);<br>return 0;<br>}<br>2、输出和为一个给定整数的所有组合<br>例如 n=5<br>5=1+4；5=2+3（相加的数不能重复）<br>则输出<br>1，4；2，3。<br>#include<br>int main(void)<br>{<br>unsigned long int i,j,k;<br>printf(“please input the number\n”);<br>scanf(“%d”,&amp;i);<br>if( i % 2 == 0)<br>j = i / 2;<br>else<br>j = i / 2 + 1;<br>printf(“The result is \n”);<br>for(k = 0; k &lt; j; k++)<br>printf(“%d = %d + %d\n”,i,k,i - k);<br>return 0;<br>}<br>#include<br>void main()<br>{<br>unsigned long int a,i=1;<br>scanf(“%d”,&amp;a);<br>if(a%2==0)<br>{<br>for(i=1;i<br>printf(“%d”,a,a-i);<br>}<br>else<br>for(i=1;i&lt;=a/2;i++)<br>printf(“ %d, %d”,i,a-i);<br>}<br>3、递规反向输出字符串的例子,可谓是反序的经典例程.<br>void inverse(char *p)<br>{<br>if( *p = = ‘\0’ )<br>return;<br>inverse( p+1 );<br>printf( “%c”, *p );<br>}<br>int main(int argc, char *argv[])<br>{<br>inverse(“abc\0”);<br>return 0;<br>}<br>对1的另一种做法：<br>#include<br>void test(FILE *fread, FILE *fwrite)<br>{<br>char buf[1024] = {0};<br>if (!fgets(buf, sizeof(buf), fread))<br>return;<br>test( fread, fwrite );<br>fputs(buf, fwrite);<br>}<br>int main(int argc, char *argv[])<br>{<br>FILE *fr = NULL;<br>FILE *fw = NULL;<br>fr = fopen(“data”, “rb”);<br>fw = fopen(“dataout”, “wb”);<br>test(fr, fw);<br>fclose(fr);<br>fclose(fw);<br>return 0;<br>}<br>4、写一段程序，找出数组中第 k 大小的数，输出数所在的位置。例如{2，4，3，4，7}中，<br>第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。<br>函数接口为：int find_orderk(const int* narry,const int n,const int k)<br>要求算法复杂度不能是 O(n^2）<br>谢谢！<br>可以先用快速排序进行排序，其中用另外一个进行地址查找<br>代码如下，在 VC++6.0运行通过。给分吧^-^<br>//快速排序<br>#include<br>usingnamespacestd;<br>intPartition (int*L,intlow,int high)<br>{<br>inttemp = L[low];<br>intpt = L[low];<br>while (low &lt; high)<br>{<br>while (low &lt; high &amp;&amp; L[high] &gt;= pt)<br>–high;<br>L[low] = L[high];<br>while (low &lt; high &amp;&amp; L[low] &lt;= pt)<br>++low;<br>L[low] = temp;<br>}<br>L[low] = temp;<br>returnlow;<br>}<br>voidQSort (int*L,intlow,int high)<br>{<br>if (low &lt; high)<br>{<br>intpl = Partition (L,low,high);<br>QSort (L,low,pl - 1);<br>QSort (L,pl + 1,high);<br>}<br>}<br>intmain ()<br>{<br>intnarry[100],addr[100];<br>intsum = 1,t;<br>cout &lt;&lt; “Input number:” &lt;&lt; endl;<br>cin &gt;&gt; t;<br>while (t != -1)<br>{<br>narry[sum] = t;<br>addr[sum - 1] = t;<br>sum++;<br>cin &gt;&gt; t;<br>}<br>sum -= 1;<br>QSort (narry,1,sum);<br>for (int i = 1; i &lt;= sum;i++)<br>cout &lt;&lt; narry[i] &lt;&lt; ‘\t’;<br>cout &lt;&lt; endl;<br>intk;<br>cout &lt;&lt; “Please input place you want:” &lt;&lt; endl;<br>cin &gt;&gt; k;<br>intaa = 1;<br>intkk = 0;<br>for (;;)<br>{<br>if (aa == k)<br>break;<br>if (narry[kk] != narry[kk + 1])<br>{<br>aa += 1;<br>kk++;<br>}<br>}<br>cout &lt;&lt; “The NO.” &lt;&lt; k &lt;&lt; “number is:” &lt;&lt; narry[sum - kk] &lt;&lt; endl;<br>cout &lt;&lt; “And it’s place is:” ;<br>for (i = 0;i &lt; sum;i++)<br>{<br>if (addr[i] == narry[sum - kk])<br>cout &lt;&lt; i &lt;&lt; ‘\t’;<br>}<br>return0;<br>}<br>5、两路归并排序<br>Linklist *unio(Linklist *p,Linklist *q){<br>linklist *R,*pa,*qa,*ra;<br>pa=p;<br>qa=q;<br>R=ra=p;<br>while(pa-&gt;next!=NULL&amp;&amp;qa-&gt;next!=NULL){<br>if(pa-&gt;data&gt;qa-&gt;data){<br>ra-&gt;next=qa;<br>qa=qa-&gt;next;<br>}<br>else{<br>ra-&gt;next=pa;<br>pa=pa-&gt;next;<br>}<br>}<br>if(pa-&gt;next!=NULL)<br>ra-&gt;next=pa;<br>if(qa-&gt;next!=NULL)<br>ra-&gt;next==qa;<br>return R;<br>}<br>6、用递归算法判断数组 a[N]是否为一个递增数组。<br>递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回 false<br>结束：<br>bool fun( int a[], int n )<br>{<br>if( n= =1 )<br>return true;<br>if( n= =2 )<br>return a[n-1] &gt;= a[n-2];<br>return fun( a,n-1) &amp;&amp; ( a[n-1] &gt;= a[n-2] );<br>}<br>7、单连表的建立，把’a’–’z’26个字母插入到连表中，并且倒叙，还要打印！<br>方法1：<br>typedef struct val<br>{ int date_1;<br>struct val *next;<br>}*p;<br>void main(void)<br>{ char c;<br>for(c=122;c&gt;=97;c–)<br>{ p.date=c;<br>p=p-&gt;next;<br>}<br>p.next=NULL;<br>}<br>}<br>方法2：<br>node *p = NULL;<br>node *q = NULL;<br>node *head = (node</em>)malloc(sizeof(node));<br>head-&gt;data = ‘ ‘;head-&gt;next=NULL;<br>node <em>first = (node</em>)malloc(sizeof(node));<br>first-&gt;data = ‘a’;first-&gt;next=NULL;head-&gt;next = first;<br>p = first;<br>int longth = ‘z’ – ‘b’;<br>int i=0;<br>while ( i&lt;=longth )<br>{<br>node *temp = (node*)malloc(sizeof(node));<br>temp-&gt;data = ‘b’+i;temp-&gt;next=NULL;q=temp;<br>head-&gt;next = temp; temp-&gt;next=p;p=q;<br>i++;<br>}<br>print(head);<br>8、请列举一个软件中时间换空间或者空间换时间的例子。<br>void swap(int a,int b)<br>{<br>int c; c=a;a=b;b=a;<br>}<br>—&gt;空优<br>void swap(int a,int b)<br>{<br>a=a+b;b=a-b;a=a-b;<br>}<br>9、outputstr 所指的值为123456789<br>int continumax(char <em>outputstr, char *inputstr)<br>{<br>char *in = inputstr, *out = outputstr, *temp, *final;<br>int count = 0, maxlen = 0;<br>while( *in != ‘\0′ )<br>{<br>if( *in &gt; 47 &amp;&amp; *in &lt; 58 )<br>{<br>for(temp = in; *in &gt; 47 &amp;&amp; *in &lt; 58 ; in++ )<br>count++;<br>}<br>else<br>in++;<br>if( maxlen &lt; count )<br>{<br>maxlen = count;<br>count = 0;<br>final = temp;<br>}<br>}<br>for(int i = 0; i &lt; maxlen; i++)<br>{<br>*out = *final;<br>out++;<br>final++;<br>}<br>*out = ‘\0’;<br>return maxlen;<br>}<br>10、不用库函数,用 C 语言实现将一整型数字转化为字符串<br>方法1：<br>int getlen(char *s){<br>int n;<br>for(n = 0; *s != ‘\0’; s++)<br>n++;<br>return n;<br>}<br>void reverse(char s[])<br>{<br>int c,i,j;<br>for(i = 0,j = getlen(s) - 1; i &lt; j; i++,j–){<br>c = s[i];<br>s[i] = s[j];<br>s[j] = c;<br>}<br>}<br>void itoa(int n,char s[])<br>{<br>int i,sign;<br>if((sign = n) &lt; 0)<br>n = -n;<br>i = 0;<br>do{/*以反序生成数字*/<br>s[i++] = n%10 + ‘0’;/*get next number*/<br>}while((n /= 10) &gt; 0);/*delete the number</em>/<br>if(sign &lt; 0)<br>s[i++] = ‘-‘;<br>s[i] = ‘\0’;<br>reverse(s);<br>}<br>方法2:<br>#include<br>using namespace std;<br>void itochar(int num);<br>void itochar(int num)<br>{<br>int i = 0;<br>int j ;<br>char stra[10];<br>char strb[10];<br>while ( num )<br>{<br>stra[i++]=num%10+48;<br>num=num/10;<br>}<br>stra[i] = ‘\0′;<br>for( j=0; j &lt; i; j++)<br>{<br>strb[j] = stra[i-j-1];<br>}<br>strb[j] = ‘\0’;<br>cout&lt;&lt; p=””&gt;<br>}<br>int main()<br>{<br>int num;<br>cin&gt;&gt;num;<br>itochar(num);<br>return 0;<br>}<br>11、求组合数： 求 n 个数（1….n）中 k 个数的组合….<br>如：combination(5,3)<br>要求输出：543，542，541，532，531，521，432，431，421，321，<br>#include<br>int pop(int <em>);<br>int push(int );<br>void combination(int ,int );<br>int stack[3]={0};<br>top=-1;<br>int main()<br>{<br>int n,m;<br>printf(“Input two numbers:\n”);<br>while( (2!=scanf(“%d%<em>c%d”,&amp;n,&amp;m)) )<br>{<br>fflush(stdin);<br>printf(“Input error! Again:\n”);<br>}<br>combination(n,m);<br>printf(“\n”);<br>}<br>void combination(int m,int n)<br>{<br>int temp=m;<br>push(temp);<br>while(1)<br>{<br>if(1==temp)<br>{<br>if(pop(&amp;temp)&amp;&amp;stack[0]==n) //当栈底元素弹出&amp;&amp;为可能取的最小值，循环退出<br>break;<br>}<br>else if( push(–temp))<br>{<br>printf(“%d%d%d “,stack[0],stack[1],stack[2]);//§ä¨ì¤@?<br>pop(&amp;temp);<br>}<br>}<br>}<br>int push(int i)<br>{<br>stack[++top]=i;<br>if(top&lt;2)<br>return 0;<br>else<br>return 1;<br>}<br>int pop(int *i)<br>{<br>*i=stack[top–];<br>if(top&gt;=0)<br>return 0;<br>else<br>return 1;<br>}<br>12、用指针的方法，将字符串“ABCD1234efgh”前后对调显示<br>#include<br>#include<br>#include<br>int main()<br>{<br>char str[] = “ABCD1234efgh”;<br>int length = strlen(str);<br>char * p1 = str;<br>char * p2 = str + length – 1;<br>while(p1 &lt; p2)<br>{<br>char c = *p1;<br>*p1 = *p2;<br>*p2 = c;<br>++p1;<br>–p2;<br>}<br>printf(“str now is %s\n”,str);<br>system(“pause”);<br>return 0;<br>}<br>13、有一分数序列：1/2,1/4,1/6,1/8……，用函数调用的方法，求此数列前20项的和<br>#include<br>double getValue()<br>{<br>double result = 0;<br>int i = 2;<br>while(i &lt; 42)<br>{<br>result += 1.0 / i;//一定要使用1.0做除数，不能用1，否则结果将自动转化成整数，即0.000000<br>i += 2;<br>}<br>return result;<br>}<br>int main()<br>{<br>printf(“result is %f\n”, getValue());<br>system(“pause”);<br>return 0;<br>}<br>14、有一个数组 a[1000]存放0–1000;要求每隔二个数删掉一个数，到末尾时循环至开头继续<br>进行，求最后一个被删掉的数的原始下标位置。<br>以7个数为例：<br>{0,1,2,3,4,5,6,7} 0–&gt;1–&gt;2（删除）–&gt;3–&gt;4–&gt;5(删除)–&gt;6–&gt;7–&gt;0（删除），如此循环直到最后<br>一个数被删除。<br>方法1：数组<br>#include<br>using namespace std;<br>#define null 1000<br>int main()<br>{<br>int arr[1000];<br>for (int i=0;i&lt;1000;++i)<br>arr[i]=i;<br>int j=0;<br>int count=0;<br>while(count&lt;999)<br>{<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>j=(++j)%1000;<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>j=(++j)%1000;<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>arr[j]=null;<br>++count;<br>}<br>while(arr[j]==null)<br>j=(++j)%1000;<br>cout&lt;<br>return 0;<br>}方法2：链表<br>#include<br>using namespace std;<br>#define null 0<br>struct node<br>{<br>int data;<br>node* next;<br>};<br>int main()<br>{<br>node* head=new node;<br>head-&gt;data=0;<br>head-&gt;next=null;<br>node</em> p=head;<br>for(int i=1;i&lt;1000;i++)<br>{<br>node* tmp=new node;<br>tmp-&gt;data=i;<br>tmp-&gt;next=null;<br>head-&gt;next=tmp;<br>head=head-&gt;next;<br>}<br>head-&gt;next=p;<br>while(p!=p-&gt;next)<br>{<br>p-&gt;next-&gt;next=p-&gt;next-&gt;next-&gt;next;<br>p=p-&gt;next-&gt;next;<br>}<br>cout&lt; data;<br>return 0;<br>}<br>方法3：通用算法<br>#include<br>#define MAXLINE 1000 //元素个数<br>/*<br>MAXLINE 元素个数<br>a[] 元素数组<br>R[] 指针场<br>suffix 下标<br>index 返回最后的下标序号<br>values 返回最后的下标对应的值<br>start 从第几个开始<br>K 间隔<br>*/<br>int find_n(int a[],int R[],int K,int&amp; index,int&amp; values,int s=0) {<br>int suffix;<br>int front_node,current_node;<br>suffix=0;<br>if(s==0) {<br>current_node=0;<br>front_node=MAXLINE-1;<br>}<br>else {<br>current_node=s;<br>front_node=s-1;<br>}<br>while(R[front_node]!=front_node) {<br>printf(“%d\n”,a[current_node]);<br>R[front_node]=R[current_node];<br>if(K==1) {<br>current_node=R[front_node];<br>continue;<br>}<br>for(int i=0;i<br>front_node=R[front_node];<br>}<br>current_node=R[front_node];<br>}<br>index=front_node;<br>values=a[front_node];<br>return 0;<br>}<br>int main(void) {<br>int a[MAXLINE],R[MAXLINE],suffix,index,values,start,i,K;<br>suffix=index=values=start=0;<br>K=2;<br>for(i=0;i<br>a[i]=i;<br>R[i]=i+1;<br>}<br>R[i-1]=0;<br>find_n(a,R,K,index,values,2);<br>printf(“the value is %d,%d\n”,index,values);<br>return 0;<br>}<br>15、实现 strcmp<br>int StrCmp(const char *str1, const char *str2)<br>做是做对了，没有抄搞，比较乱<br>int StrCmp(const char *str1, const char *str2)<br>{<br>assert(str1 &amp;&amp; srt2);<br>while (*str1 &amp;&amp; *str2 &amp;&amp; *str1 == *str2) {<br>str1++, str2++;<br>}<br>if (*str1 &amp;&amp; *str2)<br>return (*str1-*str2);<br>elseif (*str1 &amp;&amp; *str2==0)<br>return 1;<br>elseif (*str1 = = 0 &amp;&amp; *str2)<br>return -1;<br>else<br>return 0;<br>}<br>int StrCmp(const char *str1, const char *str2)<br>{<br>//省略判断空指针(自己保证)<br>while(*str1 &amp;&amp; *str1++ = = *str2++);<br>return *str1-*str2;<br>}<br>16、实现子串定位<br>int FindSubStr(const char *MainStr, const char *SubStr)<br>做是做对了，没有抄搞，比较乱<br>int MyStrstr(const char* MainStr, const char* SubStr)<br>{<br>const char *p;<br>const char *q;<br>const char * u = MainStr;<br>//assert((MainStr!=NULL)&amp;&amp;( SubStr!=NULL));//用断言对输入进行判断<br>while(*MainStr) //内部进行递增<br>{<br>p = MainStr;<br>q = SubStr;<br>while(*q &amp;&amp; *p &amp;&amp; *p++ == *q++);<br>if(!*q )<br>{<br>return MainStr - u +1 ;//MainStr 指向当前起始位，u 指向<br>}<br>MainStr ++;<br>}<br>return -1;<br>}<br>17、已知一个单向链表的头，请写出删除其某一个结点的算法，要求，先找到此结点，然后<br>删除。<br>slnodetype *Delete(slnodetype *Head,int key){}中 if(Head-&gt;number==key)<br>{<br>Head=Pointer-&gt;next;<br>free(Pointer);<br>break;<br>}<br>Back = Pointer;<br>Pointer=Pointer-&gt;next;<br>if(Pointer-&gt;number==key)<br>{<br>Back-&gt;next=Pointer-&gt;next;<br>free(Pointer);<br>break;<br>}<br>void delete(Node</em> p)<br>{<br>if(Head = Node)<br>while(p)<br>}<br>18、有1,2,….一直到 n 的无序数组,求排序算法,并且要求时间复杂度为 O(n),空间复杂度 O(1),<br>使用交换,而且一次只能交换两个数.（华为）<br>#include<br>int main()<br>{<br>int a[] = {10,6,9,5,2,8,4,7,1,3};<br>int len = sizeof(a) / sizeof(int);<br>int temp;<br>for(int i = 0; i &lt; len; )<br>{<br>temp = a[a[i] - 1];<br>a[a[i] - 1] = a[i];<br>a[i] = temp;<br>if ( a[i] == i + 1)<br>i++;<br>}<br>for (int j = 0; j &lt; len; j++)<br>cout&lt;&lt;&lt;”,”;&lt; p=””&gt;<br>return 0;<br>}<br>19、写出程序把一个链表中的接点顺序倒排<br>typedef struct linknode<br>{<br>int data;<br>struct linknode <em>next;<br>}node;<br>//将一个链表逆置<br>node <em>reverse(node *head)<br>{<br>node *p,*q,*r;<br>p=head;<br>q=p-&gt;next;<br>while(q!=NULL)<br>{<br>r=q-&gt;next;<br>q-&gt;next=p;<br>p=q;<br>q=r;<br>}<br>head-&gt;next=NULL;<br>head=p;<br>return head;<br>}<br>20、写出程序删除链表中的所有接点<br>void del_all(node *head)<br>{<br>node *p;<br>while(head!=NULL)<br>{<br>p=head-&gt;next;<br>free(head);<br>head=p;<br>}<br>cout&lt;&lt;”释放空间成功!”&lt;<br>}<br>21、两个字符串，s,t;把 t 字符串插入到 s 字符串中，s 字符串有足够的空间存放 t 字符串<br>void insert(char *s, char *t, int i)<br>{<br>char *q = t;<br>char *p =s;<br>if(q == NULL)return;<br>while(*p!=’\0’)<br>{<br>p++;<br>}<br>while(*q!=0)<br>{<br>*p=*q;<br>p++;<br>q++;<br>}<br>*p = ‘\0’;<br>}<br>22、写一个函数，功能：完成内存之间的拷贝<br>memcpy source code:<br>270 void* memcpy( void *dst, const void *src, unsigned int len )<br>271 {<br>272 register char *d;<br>273 register char *s;<br>27<br>275 if (len == 0)<br>276 return dst;<br>277<br>278 if (is_overlap(dst, src, len, len))<br>279 complain3(“memcpy”, dst, src, len);<br>280<br>281 if ( dst &gt; src ) {<br>282 d = (char *)dst + len – 1;<br>283 s = (char *)src + len – 1;<br>284 while ( len &gt;= 4 ) {<br>285 *d– = *s–;<br>286 *d– = *s–;<br>287 *d– = *s–;<br>288 *d– = *s–;<br>289 len -= 4;<br>290 }<br>291 while ( len– ) {<br>292 *d– = *s–;<br>293 }<br>294 } else if ( dst &lt; src ) {<br>295 d = (char *)dst;<br>296 s = (char *)src;<br>297 while ( len &gt;= 4 ) {<br>298 *d++ = *s++;<br>299 *d++ = *s++;<br>300 *d++ = *s++;<br>301 *d++ = *s++;<br>302 len -= 4;<br>303 }<br>304 while ( len– ) {<br>305 *d++ = *s++;<br>306 }<br>307 }<br>308 return dst;<br>309 }<br>23、公司考试这种题目主要考你编写的代码是否考虑到各种情况，是否安全（不会溢出）<br>各种情况包括：<br>１、参数是指针，检查指针是否有效<br>２、检查复制的源目标和目的地是否为同一个，若为同一个，则直接跳出<br>３、读写权限检查<br>４、安全检查，是否会溢出<br>memcpy 拷贝一块内存，内存的大小你告诉它<br>strcpy 是字符串拷贝，遇到’\0′结束<br>/</em> memcpy ─── 拷贝不重叠的内存块 <em>/<br>void memcpy(void</em> pvTo, void</em> pvFrom, size_t size)<br>{<br>void* pbTo = (byte*)pvTo;<br>void* pbFrom = (byte*)pvFrom;<br>ASSERT(pvTo != NULL &amp;&amp; pvFrom != NULL); //检查输入指针的有效性<br>ASSERT(pbTo&gt;=pbFrom+size || pbFrom&gt;=pbTo+size);//检查两个指针指向的内存是否重叠<br>while(size–&gt;0)<br><em>pbTo++ == *pbFrom++;<br>return(pvTo);<br>}<br>24、两个字符串，s,t;把 t 字符串插入到 s 字符串中，s 字符串有足够的空间存放 t 字符串<br>void insert(char *s, char *t, int i)<br>{<br>memcpy(&amp;s[strlen(t)+i],&amp;s[i],strlen(s)-i);<br>memcpy(&amp;s[i],t,strlen(t));<br>s[strlen(s)+strlen(t)]=’\0′;<br>}<br>25、编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是<br>由同一字符组成的。<br>char * search(char *cpSource, char ch)<br>{<br>char *cpTemp=NULL, *cpDest=NULL;<br>int iTemp, iCount=0;<br>while(*cpSource)<br>{<br>if(*cpSource == ch)<br>{<br>iTemp = 0;<br>cpTemp = cpSource;<br>while(*cpSource == ch)<br>++iTemp, ++cpSource;<br>if(iTemp &gt; iCount)<br>iCount = iTemp, cpDest = cpTemp;<br>if(!*cpSource)<br>break;<br>}<br>++cpSource;<br>}<br>return cpDest;<br>}<br>26、请编写一个 C 函数，该函数在给定的内存区域搜索给定的字符，并返回该字符所在位<br>置索引值。<br>int search(char *cpSource, int n, char ch)<br>{<br>int i;<br>for(i=0; i<br>return i;<br>}<br>27、给定字符串 A 和 B,输出 A 和 B 中的最大公共子串。<br>比如 A=”aocdfe” B=”pmcdfa” 则输出”cdf”<br>*/<br>//Author: azhen<br>#include<br>#include<br>#include<br>char *commanstring(char shortstring[], char longstring[])<br>{<br>int i, j;<br>char *substring=malloc(256);<br>if(strstr(longstring, shortstring)!=NULL) //如果……，那么返回 shortstring<br>return shortstring;<br>for(i=strlen(shortstring)-1;i&gt;0; i–) //否则，开始循环计算<br>{<br>for(j=0; j&lt;=strlen(shortstring)-i; j++){<br>memcpy(substring, &amp;shortstring[j], i);<br>substring[i]=’\0’;<br>if(strstr(longstring, substring)!=NULL)<br>return substring;<br>}<br>}<br>return NULL;<br>}<br>main()<br>{<br>char *str1=malloc(256);<br>char *str2=malloc(256);<br>char *comman=NULL;<br>gets(str1);<br>gets(str2);<br>if(strlen(str1)&gt;strlen(str2)) //将短的字符串放前面<br>comman=commanstring(str2, str1);<br>else<br>comman=commanstring(str1, str2);<br>printf(“the longest comman string is: %s\n”, comman);<br>}<br>28、写一个函数比较两个字符串 str1和 str2的大小，若相等返回0，若 str1大于<br>str2返回1，若 str1小于 str2返回－1<br>int strcmp ( const char * src,const char * dst)<br>{<br>int ret = 0 ;<br>while( ! (ret = *(unsigned char *)src – *(unsigned char *)dst) &amp;&amp; *dst)<br>{<br>++src;<br>++dst;<br>}<br>if ( ret &lt; 0 )<br>ret = -1 ;<br>else if ( ret &gt; 0 )<br>ret = 1 ;<br>return( ret );<br>}<br>29、求1000！的未尾有几个0（用素数相乘的方法来做，如72=2</em>2<em>2</em>3<em>3）;<br>求出1-&gt;1000里,能被5整除的数的个数 n1,能被25整除的数的个数 n2,能被125整除的数的个数<br>n3,<br>能被625整除的数的个数 n4.<br>1000!末尾的零的个数=n1+n2+n3+n4;<br>#include<br>#define NUM 1000<br>int find5(int num){<br>int ret=0;<br>while(num%5==0){<br>num/=5;<br>ret++;<br>}<br>return ret;<br>}<br>int main(){<br>int result=0;<br>int i;<br>for(i=5;i&lt;=NUM;i+=5)<br>{<br>result+=find5(i);<br>}<br>printf(“ the total zero number is %d\n”,result);<br>return 0;<br>}<br>30、有双向循环链表结点定义为：<br>struct node<br>{ int data;<br>struct node *front,*next;<br>};<br>有两个双向循环链表 A，B，知道其头指针为：pHeadA,pHeadB，请写一函数将两链表中 data<br>值相同的结点删除<br>BOOL DeteleNode(Node *pHeader, DataType Value)<br>{<br>if (pHeader == NULL) return;<br>BOOL bRet = FALSE;<br>Node *pNode = pHead;<br>while (pNode != NULL)<br>{<br>if (pNode-&gt;data == Value)<br>{<br>if (pNode-&gt;front == NULL)<br>{<br>pHeader = pNode-&gt;next;<br>pHeader-&gt;front = NULL;<br>}<br>else<br>{<br>if (pNode-&gt;next != NULL)<br>{<br>pNode-&gt;next-&gt;front = pNode-&gt;front;<br>}<br>pNode-&gt;front-&gt;next = pNode-&gt;next;<br>}<br>Node *pNextNode = pNode-&gt;next;<br>delete pNode;<br>pNode = pNextNode;<br>bRet = TRUE;<br>//不要 break 或 return, 删除所有<br>}<br>else<br>{<br>pNode = pNode-&gt;next;<br>}<br>}<br>return bRet;<br>}<br>void DE(Node *pHeadA, Node *pHeadB)<br>{<br>if (pHeadA == NULL || pHeadB == NULL)<br>{<br>return;<br>}<br>Node *pNode = pHeadA;<br>while (pNode != NULL)<br>{<br>if (DeteleNode(pHeadB, pNode-&gt;data))<br>{<br>if (pNode-&gt;front == NULL)<br>{<br>pHeadA = pNode-&gt;next;<br>pHeadA-&gt;front = NULL;<br>}<br>else<br>{<br>pNode-&gt;front-&gt;next = pNode-&gt;next;<br>if (pNode-&gt;next != NULL)<br>{<br>pNode-&gt;next-&gt;front = pNode-&gt;front;<br>}<br>}<br>Node *pNextNode = pNode-&gt;next;<br>delete pNode;<br>pNode = pNextNode;<br>}<br>else<br>{<br>pNode = pNode-&gt;next;<br>}<br>}<br>}<br>31、编程实现：找出两个字符串中最大公共子字符串,如”abccade”,”dgcadde”的最大子串<br>为”cad”<br>int GetCommon(char *s1, char *s2, char *</em>r1, char *<em>r2)<br>{<br>int len1 = strlen(s1);<br>int len2 = strlen(s2);<br>int maxlen = 0;<br>for(int i = 0; i &lt; len1; i++)<br>{<br>for(int j = 0; j &lt; len2; j++)<br>{<br>if(s1[i] == s2[j])<br>{<br>int as = i, bs = j, count = 1;<br>while(as + 1 &lt; len1 &amp;&amp; bs + 1 &lt; len2 &amp;&amp; s1[++as] == s2[++bs])<br>count++;<br>if(count &gt; maxlen)<br>{<br>maxlen = count;<br>*r1 = s1 + i;<br>*r2 = s2 + j;<br>}<br>}<br>}<br>}<br>32、编程实现：把十进制数(long 型)分别以二进制和十六进制形式输出，不能使用 printf 系<br>列库函数<br>char</em> test3(long num) {<br>char* buffer = (char*)malloc(11);<br>buffer[0] = ’0′;<br>buffer[1] = ‘x’;<br>buffer[10] = ‘\0′;<br>char* temp = buffer + 2;<br>for (int i=0; i &lt; 8; i++) {<br>temp[i] = (char)(num&lt;&lt;4*i&gt;&gt;28);<br>temp[i] = temp[i] &gt;= 0 ? temp[i] : temp[i] + 16;<br>temp[i] = temp[i] &lt; 10 ? temp[i] + 48 : temp[i] + 55;<br>}<br>return buffer;<br>}<br>33、输入 N, 打印 N*N 矩阵<br>比如 N = 3，打印：<br>1 2 3<br>8 9 4<br>7 6 5<br>N = 4，打印：<br>1 2 3 4<br>12 13 14 5<br>11 16 15 6<br>10 9 8 7<br>解答：<br>1 #define N 15<br>int s[N][N];<br>void main()<br>{<br>int k = 0, i = 0, j = 0;<br>int a = 1;<br>for( ; k &lt; (N+1)/2; k++ )<br>{<br>while( j &lt; N-k ) s[i][j++] = a++; i++; j–;<br>while( i &lt; N-k ) s[i++][j] = a++; i–; j–;<br>while( j &gt; k-1 ) s[i][j–] = a++; i–; j++;<br>while( i &gt; k ) s[i–][j] = a++; i++; j++;<br>}<br>for( i = 0; i &lt; N; i++ )<br>{<br>for( j = 0; j &lt; N; j++ )<br>cout &lt;&lt; s[i][j] &lt;&lt; ‘\t’;<br>cout &lt;&lt; endl;<br>}<br>}<br>2 define MAX_N 100<br>int matrix[MAX_N][MAX_N];<br>/*<br>*（x,y）：第一个元素的坐标</p>
<ul>
<li>start：第一个元素的值</li>
<li>n：矩阵的大小</li>
<li>/<br>void SetMatrix(int x, int y, int start, int n) {<br>int i, j;<br>if (n &lt;= 0) //递归结束条件<br>return;<br>if (n == 1) { //矩阵大小为1时<br>matrix[x][y] = start;<br>return;<br>}<br>for (i = x; i &lt; x + n-1; i++) //矩阵上部<br>matrix[y][i] = start++;<br>for (j = y; j &lt; y + n-1; j++) //右部<br>matrix[j][x+n-1] = start++;<br>for (i = x+n-1; i &gt; x; i–) //底部<br>matrix[y+n-1][i] = start++;<br>for (j = y+n-1; j &gt; y; j–) //左部<br>matrix[j][x] = start++;<br>SetMatrix(x+1, y+1, start, n-2); //递归<br>}<br>void main() {<br>int i, j;<br>int n;<br>scanf(“%d”, &amp;n);<br>SetMatrix(0, 0, 1, n);<br>//打印螺旋矩阵<br>for(i = 0; i &lt; n; i++) {<br>for (j = 0; j &lt; n; j++)<br>printf(“%4d”, matrix[i][j]);<br>printf(“\n”);<br>}<br>}<br>34、斐波拉契数列递归实现的方法如下：<br>int Funct( int n )<br>{<br>if(n==0) return 1;<br>if(n==1) return 1;<br>retrurn Funct(n-1) + Funct(n-2);<br>}<br>请问，如何不使用递归，来实现上述函数？<br>请教各位高手！<br>解答：int Funct( int n ) // n 为非负整数<br>{<br>int a=0;<br>int b=1;<br>int c;<br>if(n==0) c=1;<br>else if(n==1) c=1;<br>else for(int i=2;i&lt;=n;i++) //应该 n 从2开始算起<br>{<br>c=a+b;<br>a=b;<br>b=c;<br>}<br>return c;<br>}<br>解答：<br>现在大多数系统都是将低字位放在前面，而结构体中位域的申明一般是先声明高位。<br>100 的二进制是 001 100 100<br>低位在前 高位在后<br>001—-s3<br>100—-s2<br>100—-s1<br>所以结果应该是 1<br>如果先申明的在低位则：<br>001—-s1<br>100—-s2<br>100—-s3<br>结果是 4<br>1、原题跟 little-endian，big-endian 没有关系<br>2、原题跟位域的存储空间分配有关，到底是从低字节分配还是从高字节分配，从 Dev C++<br>和 VC7.1上看，都是从低字节开始分配，并且连续分配，中间不空，不像谭的书那样会留空<br>位<br>3、原题跟编译器有关，编译器在未用堆栈空间的默认值分配上有所不同，Dev C++未用空<br>间分配为<br>01110111b，VC7.1下为11001100b,所以在 Dev C++下的结果为5，在 VC7.1下为1。<br>注：PC 一般采用 little-endian，即高高低低，但在网络传输上，一般采用 big-endian，即高<br>低低高，华为是做网络的，所以可能考虑 big-endian 模式，这样输出结果可能为4<br>35、判断一个字符串是不是回文<br>int IsReverseStr(char <em>aStr)<br>{<br>int i,j;<br>int found=1;<br>if(aStr==NULL)<br>return -1;<br>j=strlen(aStr);<br>for(i=0;i<br>if(</em>(aStr+i)!=*(aStr+j-i-1))<br>{<br>found=0;<br>break;<br>}<br>return found;<br>}<br>36、Josephu 问题为：设编号为1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）<br>的人从1开始报数，数到 m 的那个人出列，它的下一位又从1开始报数，数到 m 的那个人又<br>出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。<br>数组实现：<br>#include<br>#include<br>int Josephu(int n, int m)<br>{<br>int flag, i, j = 0;<br>int *arr = (int *)malloc(n * sizeof(int));<br>for (i = 0; i &lt; n; ++i)<br>arr[i] = 1;<br>for (i = 1; i &lt; n; ++i)<br>{<br>flag = 0;<br>while (flag &lt; m)<br>{<br>if (j == n)<br>j = 0;<br>if (arr[j])</li>
</ul>
<p>++flag;<br>++j;<br>}<br>arr[j - 1] = 0;<br>printf(“第%4d 个出局的人是：%4d 号\n”, i, j);<br>}<br>free(arr);<br>return j;<br>}<br>int main()<br>{<br>int n, m;<br>scanf(“%d%d”, &amp;n, &amp;m);<br>printf(“最后胜利的是%d 号！\n”, Josephu(n, m));<br>system(“pause”);<br>return 0;<br>}<br>链表实现：<br>#include<br>#include<br>typedef struct Node<br>{<br>int index;<br>struct Node *next;<br>}JosephuNode;<br>int Josephu(int n, int m)<br>{<br>int i, j;<br>JosephuNode *head, *tail;<br>head = tail = (JosephuNode *)malloc(sizeof(JosephuNode));<br>for (i = 1; i &lt; n; ++i)<br>{<br>tail-&gt;index = i;<br>tail-&gt;next = (JosephuNode *)malloc(sizeof(JosephuNode));<br>tail = tail-&gt;next;<br>}<br>tail-&gt;index = i;<br>tail-&gt;next = head;<br>for (i = 1; tail != head; ++i)<br>{<br>for (j = 1; j &lt; m; ++j)<br>{<br>tail = head;<br>head = head-&gt;next;<br>}<br>tail-&gt;next = head-&gt;next;<br>printf(“第%4d 个出局的人是：%4d 号\n”, i, head-&gt;index);<br>free(head);<br>head = tail-&gt;next;<br>}<br>i = head-&gt;index;<br>free(head);<br>return i;<br>}<br>int main()<br>{<br>int n, m;<br>scanf(“%d%d”, &amp;n, &amp;m);<br>printf(“最后胜利的是%d 号！\n”, Josephu(n, m));<br>system(“pause”);<br>return 0;<br>}<br>37、已知 strcpy 函数的原型是：<br>char * strcpy(char * strDest,const char * strSrc);<br>1.不调用库函数，实现 strcpy 函数。<br>2.解释为什么要返回 char *。<br>解说：<br>1.strcpy 的实现代码<br>char * strcpy(char * strDest,const char * strSrc)<br>{<br>if ((strDest==NULL)||(strSrc==NULL)) file://[/1]<br>throw “Invalid argument(s)”; //[2]<br>char * strDestCopy=strDest; file://[/3]<br>while ((*strDest++=*strSrc++)!=’\0′); file://[/4]<br>return strDestCopy;<br>}<br>错误的做法：<br>[1]<br>(A)不检查指针的有效性，说明答题者不注重代码的健壮性。<br>(B)检查指针的有效性时使用((!strDest)||(!strSrc))或(!(strDest&amp;&amp;strSrc))，说明答题者对 C 语<br>言中类型的隐式转换没有深刻认识。在本例中 char *转换为 bool 即是类型隐式转换，这种功<br>能虽然灵活，但更多的是导致出错概率增大和维护成本升高。所以 C++专门增加了 bool、true、<br>false 三个关键字以提供更安全的条件表达式。<br>(C)检查指针的有效性时使用((strDest==0)||(strSrc==0))，说明答题者不知道使用常量的好处。<br>直接使用字面常量（如本例中的0）会减少程序的可维护性。0虽然简单，但程序中可能出现<br>很多处对指针的检查，万一出现笔误，编译器不能发现，生成的程序内含逻辑错误，很难排<br>除。而使用 NULL 代替0，如果出现拼写错误，编译器就会检查出来。<br>[2]<br>(A)return new string(“Invalid argument(s)”);，说明答题者根本不知道返回值的用途，并且他对<br>内存泄漏也没有警惕心。从函数中返回函数体内分配的内存是十分危险的做法，他把释放内<br>存的义务抛给不知情的调用者，绝大多数情况下，调用者不会释放内存，这导致内存泄漏。<br>(B)return 0;，说明答题者没有掌握异常机制。调用者有可能忘记检查返回值，调用者还可能<br>无法检查返回值（见后面的链式表达式）。妄想让返回值肩负返回正确值和异常值的双重功<br>能，其结果往往是两种功能都失效。应该以抛出异常来代替返回值，这样可以减轻调用者的<br>负担、使错误不会被忽略、增强程序的可维护性。<br>[3]<br>(A)忘记保存原始的 strDest 值，说明答题者逻辑思维不严密。<br>[4]<br>(A)循环写成 while (*strDest++=*strSrc++);，同<a href="B">1</a>。<br>(B)循环写成 while (*strSrc!=’\0′) *strDest++=*strSrc++;，说明答题者对边界条件的检查不力。<br>循环体结束后，strDest 字符串的末尾没有正确地加上’\0′。<br>第四部分：附加部分<br>1、位域 ：<br>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如<br>在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使<br>处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节<br>中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在<br>程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。<br>一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：<br>struct 位域结构名<br>{ 位域列表 };<br>其中位域列表的形式为： 类型说明符 位域名：位域长度<br>例如：<br>struct bs<br>{<br>int a:8;<br>int b:2;<br>int c:6;<br>};<br>位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直<br>接说明这三种方式。例如：<br>struct bs<br>{<br>int a:8;<br>int b:2;<br>int c:6;<br>}data;<br>说明 data 为 bs 变量，共占两个字节。其中位域 a 占8位，位域 b 占2位，位域 c 占6位。对于<br>位域的定义尚有以下几点说明：</p>
<ol>
<li>一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另<br>一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：<br>struct bs<br>{<br>unsigned a:4<br>unsigned :0 /<em>空域</em>/<br>unsigned b:4 /<em>从下一单元开始存放</em>/<br>unsigned c:4<br>}<br>在这个位域定义中，a 占第一字节的4位，后4位填0表示不使用，b 从第二字节开始，占用4<br>位，c 占用4位。</li>
<li>由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能<br>超过8位二进位。</li>
<li>位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：<br>struct k<br>{<br>int a:1<br>int :2 /<em>该2位不能使用</em>/<br>int b:3<br>int c:2<br>};<br>从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。<br>二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名•位域名 位<br>域允许用各种格式输出。<br>main(){<br>struct bs<br>{<br>unsigned a:1;<br>unsigned b:3;<br>unsigned c:4;<br>} bit,*pbit;<br>bit.a=1;<br>bit.b=7;<br>bit.c=15;<br>pri<br>改错：<br>#include<br>int main(void) {<br>int **p;<br>int arr[100];<br>p = &arr;<br>return 0;<br>}<br>解答：<br>搞错了,是指针类型不同,<br>int **p; //二级指针<br>&arr; //得到的是指向第一维为100的数组的指针<br>#include<br>int main(void) {<br>int **p, *q;<br>int arr[100];<br>q = arr;<br>p = &q;<br>return 0;<br>}</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">胡先森</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/10/11/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/">http://yoursite.com/2020/10/11/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com" target="_blank">Mr.Hu</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/10.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/10/15/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E5%A4%87%E5%8F%8A%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/"><img class="prev-cover" data-lazy-src="/img/2.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常见的网络安全设备及默认口令</div></div></a></div><div class="next-post pull-right"><a href="/2020/10/08/Openssl/"><img class="next-cover" data-lazy-src="/img/Openssl.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Openssl————指令</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/09/19/C++核心编程/" title="C++核心编程"><img class="relatedPosts_cover" data-lazy-src="img/C++.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-19</div><div class="relatedPosts_title">C++核心编程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer" style="background-image: url(/img/10.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By 胡先森</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script>function loadValine () {
  function initValine () {
    window.valine = new Valine({
      el: '#vcomment',
      appId: 'Eo4Vh3u0nKU2EUIpOMidpb6L-gzGzoHsz',
      appKey: 'RIFmwqkX4dT5EpJghF6o6DWE',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'https://eo4vh3u0.lc-cn-n1-shared.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    });
    if ('nick,mail') { valine.config.requiredFields= 'nick,mail'.split(',') }
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><style type="text/css">#toggle-sidebar {bottom: 80px}</style><div class="aplayer no-destroy" data-id="7322622901" data-server="tencent" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/third-party/ClickShowText.js" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script></div></body></html><!-- 雪花特效 -->
<script type="text/javascript" src="\js\snow.js"></script>